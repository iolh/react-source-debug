diff --git a/cjs/react-compiler-runtime.development.js b/cjs/react-compiler-runtime.development.js
index 84ceaac6f5558c8f6783fe84a0f6e78953aed2c7..c6b8d78a3ee4ec2a2873653456a249d53467d30f 100644
--- a/cjs/react-compiler-runtime.development.js
+++ b/cjs/react-compiler-runtime.development.js
@@ -1,24 +1,26 @@
-/**
- * @license React
- * react-compiler-runtime.development.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
+'use strict';
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
-  (function () {
-    var ReactSharedInternals =
-      require("react").__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
-    exports.c = function (size) {
-      var dispatcher = ReactSharedInternals.H;
-      null === dispatcher &&
-        console.error(
-          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
-        );
-      return dispatcher.useMemoCache(size);
-    };
-  })();
+var React = require('react');
+
+var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+
+function resolveDispatcher() {
+  var dispatcher = ReactSharedInternals.H;
+  {
+    if (dispatcher === null) {
+      console.error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.');
+    }
+  }
+  // Will result in a null access error if accessed outside render phase. We
+  // intentionally don't throw our own error because this is in a hot path.
+  // Also helps ensure this is inlined.
+  return dispatcher;
+}
+function useMemoCache(size) {
+  var dispatcher = resolveDispatcher();
+  // $FlowFixMe[not-a-function] This is unstable, thus optional
+  return dispatcher.useMemoCache(size);
+}
+
+exports.c = useMemoCache;
+//# sourceMappingURL=react-compiler-runtime.development.js.map
diff --git a/cjs/react-compiler-runtime.development.js.map b/cjs/react-compiler-runtime.development.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..1b452497adae5228c56c66c0126e8b6a0378a831
--- /dev/null
+++ b/cjs/react-compiler-runtime.development.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react-compiler-runtime.development.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSharedInternals.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactHooks.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport * as React from 'react';\n\nconst ReactSharedInternals =\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n\nexport default ReactSharedInternals;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  ReactContext,\n  StartTransitionOptions,\n  Usable,\n  Awaited,\n} from 'shared/ReactTypes';\nimport {REACT_CONSUMER_TYPE} from 'shared/ReactSymbols';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\ntype BasicStateAction<S> = (S => S) | S;\ntype Dispatch<A> = A => void;\n\nfunction resolveDispatcher() {\n  const dispatcher = ReactSharedInternals.H;\n  if (__DEV__) {\n    if (dispatcher === null) {\n      console.error(\n        'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n          ' one of the following reasons:\\n' +\n          '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n          '2. You might be breaking the Rules of Hooks\\n' +\n          '3. You might have more than one copy of React in the same app\\n' +\n          'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.',\n      );\n    }\n  }\n  // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n  return ((dispatcher: any): Dispatcher);\n}\n\nexport function getCacheForType<T>(resourceType: () => T): T {\n  const dispatcher = ReactSharedInternals.A;\n  if (!dispatcher) {\n    // If there is no dispatcher, then we treat this as not being cached.\n    return resourceType();\n  }\n  return dispatcher.getCacheForType(resourceType);\n}\n\nexport function useContext<T>(Context: ReactContext<T>): T {\n  const dispatcher = resolveDispatcher();\n  if (__DEV__) {\n    if (Context.$$typeof === REACT_CONSUMER_TYPE) {\n      console.error(\n        'Calling useContext(Context.Consumer) is not supported and will cause bugs. ' +\n          'Did you mean to call useContext(Context) instead?',\n      );\n    }\n  }\n  return dispatcher.useContext(Context);\n}\n\nexport function useState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n\nexport function useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\n\nexport function useRef<T>(initialValue: T): {current: T} {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\n\nexport function useEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\n\nexport function useInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\n\nexport function useLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\n\nexport function useCallback<T>(\n  callback: T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\n\nexport function useMemo<T>(\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\n\nexport function useImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\n\nexport function useDebugValue<T>(\n  value: T,\n  formatterFn: ?(value: T) => mixed,\n): void {\n  if (__DEV__) {\n    const dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\n\nexport function useTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\n\nexport function useDeferredValue<T>(value: T, initialValue?: T): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value, initialValue);\n}\n\nexport function useId(): string {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\n\nexport function useSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n  );\n}\n\nexport function useCacheRefresh(): <T>(?() => T, ?T) => void {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useCacheRefresh();\n}\n\nexport function use<T>(usable: Usable<T>): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.use(usable);\n}\n\nexport function useMemoCache(size: number): Array<mixed> {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useMemoCache(size);\n}\n\nexport function useEffectEvent<Args, F: (...Array<Args>) => mixed>(\n  callback: F,\n): F {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useEffectEvent(callback);\n}\n\nexport function useOptimistic<S, A>(\n  passthrough: S,\n  reducer: ?(S, A) => S,\n): [S, (A) => void] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useOptimistic(passthrough, reducer);\n}\n\nexport function useActionState<S, P>(\n  action: (Awaited<S>, P) => S,\n  initialState: Awaited<S>,\n  permalink?: string,\n): [Awaited<S>, (P) => void, boolean] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useActionState(action, initialState, permalink);\n}\n"],"names":["ReactSharedInternals","React","__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","resolveDispatcher","dispatcher","H","console","error","useMemoCache","size"],"mappings":";;;;AAWA,IAAMA,oBAAoB,GACxBC,KAAK,CAACC,+DAA+D;;ACWvE,SAASC,iBAAiBA,GAAG;AAC3B,EAAA,IAAMC,UAAU,GAAGJ,oBAAoB,CAACK,CAAC,CAAA;AACzC,EAAa;IACX,IAAID,UAAU,KAAK,IAAI,EAAE;AACvBE,MAAAA,OAAO,CAACC,KAAK,CACX,+GAA+G,GAC7G,kCAAkC,GAClC,wFAAwF,GACxF,+CAA+C,GAC/C,iEAAiE,GACjE,gGACJ,CAAC,CAAA;AACH,KAAA;AACF,GAAA;AACA;AACA;AACA;AACA,EAAA,OAASH,UAAU,CAAA;AACrB,CAAA;AA0KO,SAASI,YAAYA,CAACC,IAAI,EAAwB;AACvD,EAAA,IAAML,UAAU,GAAGD,iBAAiB,EAAE,CAAA;AACtC;AACA,EAAA,OAAOC,UAAU,CAACI,YAAY,CAACC,IAAI,CAAC,CAAA;AACtC;;;;"}
\ No newline at end of file
diff --git a/cjs/react-compiler-runtime.production.js b/cjs/react-compiler-runtime.production.js
index 4d5ade38f0fd3a5bd481be166924d276aae82965..5250ac868354c0a0817fede1302d8256d6f5f553 100644
--- a/cjs/react-compiler-runtime.production.js
+++ b/cjs/react-compiler-runtime.production.js
@@ -1,16 +1,21 @@
-/**
- * @license React
- * react-compiler-runtime.production.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
+'use strict';
 
-"use strict";
-var ReactSharedInternals =
-  require("react").__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
-exports.c = function (size) {
-  return ReactSharedInternals.H.useMemoCache(size);
-};
+var React = require('react');
+
+const ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+
+function resolveDispatcher() {
+  const dispatcher = ReactSharedInternals.H;
+  // Will result in a null access error if accessed outside render phase. We
+  // intentionally don't throw our own error because this is in a hot path.
+  // Also helps ensure this is inlined.
+  return dispatcher;
+}
+function useMemoCache(size) {
+  const dispatcher = resolveDispatcher();
+  // $FlowFixMe[not-a-function] This is unstable, thus optional
+  return dispatcher.useMemoCache(size);
+}
+
+exports.c = useMemoCache;
+//# sourceMappingURL=react-compiler-runtime.production.js.map
diff --git a/cjs/react-compiler-runtime.production.js.map b/cjs/react-compiler-runtime.production.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..f4b9e5d7802fca304f9a402d39aadb5ae39fff4a
--- /dev/null
+++ b/cjs/react-compiler-runtime.production.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react-compiler-runtime.production.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSharedInternals.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactHooks.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport * as React from 'react';\n\nconst ReactSharedInternals =\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n\nexport default ReactSharedInternals;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  ReactContext,\n  StartTransitionOptions,\n  Usable,\n  Awaited,\n} from 'shared/ReactTypes';\nimport {REACT_CONSUMER_TYPE} from 'shared/ReactSymbols';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\ntype BasicStateAction<S> = (S => S) | S;\ntype Dispatch<A> = A => void;\n\nfunction resolveDispatcher() {\n  const dispatcher = ReactSharedInternals.H;\n  if (__DEV__) {\n    if (dispatcher === null) {\n      console.error(\n        'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n          ' one of the following reasons:\\n' +\n          '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n          '2. You might be breaking the Rules of Hooks\\n' +\n          '3. You might have more than one copy of React in the same app\\n' +\n          'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.',\n      );\n    }\n  }\n  // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n  return ((dispatcher: any): Dispatcher);\n}\n\nexport function getCacheForType<T>(resourceType: () => T): T {\n  const dispatcher = ReactSharedInternals.A;\n  if (!dispatcher) {\n    // If there is no dispatcher, then we treat this as not being cached.\n    return resourceType();\n  }\n  return dispatcher.getCacheForType(resourceType);\n}\n\nexport function useContext<T>(Context: ReactContext<T>): T {\n  const dispatcher = resolveDispatcher();\n  if (__DEV__) {\n    if (Context.$$typeof === REACT_CONSUMER_TYPE) {\n      console.error(\n        'Calling useContext(Context.Consumer) is not supported and will cause bugs. ' +\n          'Did you mean to call useContext(Context) instead?',\n      );\n    }\n  }\n  return dispatcher.useContext(Context);\n}\n\nexport function useState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n\nexport function useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\n\nexport function useRef<T>(initialValue: T): {current: T} {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\n\nexport function useEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\n\nexport function useInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\n\nexport function useLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\n\nexport function useCallback<T>(\n  callback: T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\n\nexport function useMemo<T>(\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\n\nexport function useImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\n\nexport function useDebugValue<T>(\n  value: T,\n  formatterFn: ?(value: T) => mixed,\n): void {\n  if (__DEV__) {\n    const dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\n\nexport function useTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\n\nexport function useDeferredValue<T>(value: T, initialValue?: T): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value, initialValue);\n}\n\nexport function useId(): string {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\n\nexport function useSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n  );\n}\n\nexport function useCacheRefresh(): <T>(?() => T, ?T) => void {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useCacheRefresh();\n}\n\nexport function use<T>(usable: Usable<T>): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.use(usable);\n}\n\nexport function useMemoCache(size: number): Array<mixed> {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useMemoCache(size);\n}\n\nexport function useEffectEvent<Args, F: (...Array<Args>) => mixed>(\n  callback: F,\n): F {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useEffectEvent(callback);\n}\n\nexport function useOptimistic<S, A>(\n  passthrough: S,\n  reducer: ?(S, A) => S,\n): [S, (A) => void] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useOptimistic(passthrough, reducer);\n}\n\nexport function useActionState<S, P>(\n  action: (Awaited<S>, P) => S,\n  initialState: Awaited<S>,\n  permalink?: string,\n): [Awaited<S>, (P) => void, boolean] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useActionState(action, initialState, permalink);\n}\n"],"names":["ReactSharedInternals","React","__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","resolveDispatcher","dispatcher","H","useMemoCache","size"],"mappings":";;;;AAWA,MAAMA,oBAAoB,GACxBC,KAAK,CAACC,+DAA+D;;ACWvE,SAASC,iBAAiBA,GAAG;AAC3B,EAAA,MAAMC,UAAU,GAAGJ,oBAAoB,CAACK,CAAC,CAAA;AAazC;AACA;AACA;AACA,EAAA,OAASD,UAAU,CAAA;AACrB,CAAA;AA0KO,SAASE,YAAYA,CAACC,IAAI,EAAwB;AACvD,EAAA,MAAMH,UAAU,GAAGD,iBAAiB,EAAE,CAAA;AACtC;AACA,EAAA,OAAOC,UAAU,CAACE,YAAY,CAACC,IAAI,CAAC,CAAA;AACtC;;;;"}
\ No newline at end of file
diff --git a/cjs/react-compiler-runtime.profiling.js b/cjs/react-compiler-runtime.profiling.js
index 9b93257e37ab256ad01b3c4a3ffc065c145f55a1..dc07f8c3fa6e4fbf141a5914749888eba9fca134 100644
--- a/cjs/react-compiler-runtime.profiling.js
+++ b/cjs/react-compiler-runtime.profiling.js
@@ -1,16 +1,21 @@
-/**
- * @license React
- * react-compiler-runtime.profiling.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
+'use strict';
 
-"use strict";
-var ReactSharedInternals =
-  require("react").__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
-exports.c = function (size) {
-  return ReactSharedInternals.H.useMemoCache(size);
-};
+var React = require('react');
+
+const ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+
+function resolveDispatcher() {
+  const dispatcher = ReactSharedInternals.H;
+  // Will result in a null access error if accessed outside render phase. We
+  // intentionally don't throw our own error because this is in a hot path.
+  // Also helps ensure this is inlined.
+  return dispatcher;
+}
+function useMemoCache(size) {
+  const dispatcher = resolveDispatcher();
+  // $FlowFixMe[not-a-function] This is unstable, thus optional
+  return dispatcher.useMemoCache(size);
+}
+
+exports.c = useMemoCache;
+//# sourceMappingURL=react-compiler-runtime.profiling.js.map
diff --git a/cjs/react-compiler-runtime.profiling.js.map b/cjs/react-compiler-runtime.profiling.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..a6b62a15b225d29ab3400e15d6e23dd94221ebc4
--- /dev/null
+++ b/cjs/react-compiler-runtime.profiling.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react-compiler-runtime.profiling.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSharedInternals.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactHooks.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport * as React from 'react';\n\nconst ReactSharedInternals =\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n\nexport default ReactSharedInternals;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  ReactContext,\n  StartTransitionOptions,\n  Usable,\n  Awaited,\n} from 'shared/ReactTypes';\nimport {REACT_CONSUMER_TYPE} from 'shared/ReactSymbols';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\ntype BasicStateAction<S> = (S => S) | S;\ntype Dispatch<A> = A => void;\n\nfunction resolveDispatcher() {\n  const dispatcher = ReactSharedInternals.H;\n  if (__DEV__) {\n    if (dispatcher === null) {\n      console.error(\n        'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n          ' one of the following reasons:\\n' +\n          '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n          '2. You might be breaking the Rules of Hooks\\n' +\n          '3. You might have more than one copy of React in the same app\\n' +\n          'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.',\n      );\n    }\n  }\n  // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n  return ((dispatcher: any): Dispatcher);\n}\n\nexport function getCacheForType<T>(resourceType: () => T): T {\n  const dispatcher = ReactSharedInternals.A;\n  if (!dispatcher) {\n    // If there is no dispatcher, then we treat this as not being cached.\n    return resourceType();\n  }\n  return dispatcher.getCacheForType(resourceType);\n}\n\nexport function useContext<T>(Context: ReactContext<T>): T {\n  const dispatcher = resolveDispatcher();\n  if (__DEV__) {\n    if (Context.$$typeof === REACT_CONSUMER_TYPE) {\n      console.error(\n        'Calling useContext(Context.Consumer) is not supported and will cause bugs. ' +\n          'Did you mean to call useContext(Context) instead?',\n      );\n    }\n  }\n  return dispatcher.useContext(Context);\n}\n\nexport function useState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n\nexport function useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\n\nexport function useRef<T>(initialValue: T): {current: T} {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\n\nexport function useEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\n\nexport function useInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\n\nexport function useLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\n\nexport function useCallback<T>(\n  callback: T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\n\nexport function useMemo<T>(\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\n\nexport function useImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\n\nexport function useDebugValue<T>(\n  value: T,\n  formatterFn: ?(value: T) => mixed,\n): void {\n  if (__DEV__) {\n    const dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\n\nexport function useTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\n\nexport function useDeferredValue<T>(value: T, initialValue?: T): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value, initialValue);\n}\n\nexport function useId(): string {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\n\nexport function useSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n  );\n}\n\nexport function useCacheRefresh(): <T>(?() => T, ?T) => void {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useCacheRefresh();\n}\n\nexport function use<T>(usable: Usable<T>): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.use(usable);\n}\n\nexport function useMemoCache(size: number): Array<mixed> {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useMemoCache(size);\n}\n\nexport function useEffectEvent<Args, F: (...Array<Args>) => mixed>(\n  callback: F,\n): F {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useEffectEvent(callback);\n}\n\nexport function useOptimistic<S, A>(\n  passthrough: S,\n  reducer: ?(S, A) => S,\n): [S, (A) => void] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useOptimistic(passthrough, reducer);\n}\n\nexport function useActionState<S, P>(\n  action: (Awaited<S>, P) => S,\n  initialState: Awaited<S>,\n  permalink?: string,\n): [Awaited<S>, (P) => void, boolean] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useActionState(action, initialState, permalink);\n}\n"],"names":["ReactSharedInternals","React","__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","resolveDispatcher","dispatcher","H","useMemoCache","size"],"mappings":";;;;AAWA,MAAMA,oBAAoB,GACxBC,KAAK,CAACC,+DAA+D;;ACWvE,SAASC,iBAAiBA,GAAG;AAC3B,EAAA,MAAMC,UAAU,GAAGJ,oBAAoB,CAACK,CAAC,CAAA;AAazC;AACA;AACA;AACA,EAAA,OAASD,UAAU,CAAA;AACrB,CAAA;AA0KO,SAASE,YAAYA,CAACC,IAAI,EAAwB;AACvD,EAAA,MAAMH,UAAU,GAAGD,iBAAiB,EAAE,CAAA;AACtC;AACA,EAAA,OAAOC,UAAU,CAACE,YAAY,CAACC,IAAI,CAAC,CAAA;AACtC;;;;"}
\ No newline at end of file
diff --git a/cjs/react-jsx-dev-runtime.development.js b/cjs/react-jsx-dev-runtime.development.js
index 8dd24a4d7e6e023d8ad336e7ab9d890ae00f1448..8d702ca6e9d963ee85ab0d5e6c5c76b2becaae01 100644
--- a/cjs/react-jsx-dev-runtime.development.js
+++ b/cjs/react-jsx-dev-runtime.development.js
@@ -1,349 +1,553 @@
-/**
- * @license React
- * react-jsx-dev-runtime.development.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
+'use strict';
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
-  (function () {
-    function getComponentNameFromType(type) {
-      if (null == type) return null;
-      if ("function" === typeof type)
-        return type.$$typeof === REACT_CLIENT_REFERENCE
-          ? null
-          : type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
-      switch (type) {
-        case REACT_FRAGMENT_TYPE:
-          return "Fragment";
-        case REACT_PROFILER_TYPE:
-          return "Profiler";
-        case REACT_STRICT_MODE_TYPE:
-          return "StrictMode";
-        case REACT_SUSPENSE_TYPE:
-          return "Suspense";
-        case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
-        case REACT_ACTIVITY_TYPE:
-          return "Activity";
-      }
-      if ("object" === typeof type)
-        switch (
-          ("number" === typeof type.tag &&
-            console.error(
-              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
-            ),
-          type.$$typeof)
-        ) {
-          case REACT_PORTAL_TYPE:
-            return "Portal";
-          case REACT_CONTEXT_TYPE:
-            return (type.displayName || "Context") + ".Provider";
-          case REACT_CONSUMER_TYPE:
-            return (type._context.displayName || "Context") + ".Consumer";
-          case REACT_FORWARD_REF_TYPE:
-            var innerType = type.render;
-            type = type.displayName;
-            type ||
-              ((type = innerType.displayName || innerType.name || ""),
-              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
-            return type;
-          case REACT_MEMO_TYPE:
-            return (
-              (innerType = type.displayName || null),
-              null !== innerType
-                ? innerType
-                : getComponentNameFromType(type.type) || "Memo"
-            );
-          case REACT_LAZY_TYPE:
-            innerType = type._payload;
-            type = type._init;
-            try {
-              return getComponentNameFromType(type(innerType));
-            } catch (x) {}
-        }
+var React = require('react');
+
+// -----------------------------------------------------------------------------
+// Land or remove (zero effort)
+//
+// Flags that can likely be deleted or landed without consequences
+// -----------------------------------------------------------------------------
+
+var ownerStackLimit = 1e4;
+
+var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+var REACT_PORTAL_TYPE = Symbol.for('react.portal');
+var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
+var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
+var REACT_CONSUMER_TYPE = Symbol.for('react.consumer');
+var REACT_CONTEXT_TYPE = Symbol.for('react.context');
+var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
+var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
+var REACT_MEMO_TYPE = Symbol.for('react.memo');
+var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+var REACT_ACTIVITY_TYPE = Symbol.for('react.activity');
+var REACT_VIEW_TRANSITION_TYPE = Symbol.for('react.view_transition');
+
+// Keep in sync with react-reconciler/getComponentNameFromFiber
+function getWrappedName(outerType, innerType, wrapperName) {
+  var displayName = outerType.displayName;
+  if (displayName) {
+    return displayName;
+  }
+  var functionName = innerType.displayName || innerType.name || '';
+  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
+}
+
+// Keep in sync with react-reconciler/getComponentNameFromFiber
+function getContextName(type) {
+  return type.displayName || 'Context';
+}
+var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
+
+// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
+function getComponentNameFromType(type) {
+  if (type == null) {
+    // Host root, text node or just invalid type.
+    return null;
+  }
+  if (typeof type === 'function') {
+    if (type.$$typeof === REACT_CLIENT_REFERENCE) {
+      // TODO: Create a convention for naming client references with debug info.
       return null;
     }
-    function testStringCoercion(value) {
-      return "" + value;
-    }
-    function checkKeyStringCoercion(value) {
-      try {
-        testStringCoercion(value);
-        var JSCompiler_inline_result = !1;
-      } catch (e) {
-        JSCompiler_inline_result = !0;
+    return type.displayName || type.name || null;
+  }
+  if (typeof type === 'string') {
+    return type;
+  }
+  switch (type) {
+    case REACT_FRAGMENT_TYPE:
+      return 'Fragment';
+    case REACT_PROFILER_TYPE:
+      return 'Profiler';
+    case REACT_STRICT_MODE_TYPE:
+      return 'StrictMode';
+    case REACT_SUSPENSE_TYPE:
+      return 'Suspense';
+    case REACT_SUSPENSE_LIST_TYPE:
+      return 'SuspenseList';
+    case REACT_ACTIVITY_TYPE:
+      return 'Activity';
+    case REACT_VIEW_TRANSITION_TYPE:
+      {
+        return 'ViewTransition';
       }
-      if (JSCompiler_inline_result) {
-        JSCompiler_inline_result = console;
-        var JSCompiler_temp_const = JSCompiler_inline_result.error;
-        var JSCompiler_inline_result$jscomp$0 =
-          ("function" === typeof Symbol &&
-            Symbol.toStringTag &&
-            value[Symbol.toStringTag]) ||
-          value.constructor.name ||
-          "Object";
-        JSCompiler_temp_const.call(
-          JSCompiler_inline_result,
-          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
-          JSCompiler_inline_result$jscomp$0
-        );
-        return testStringCoercion(value);
+  }
+  if (typeof type === 'object') {
+    {
+      if (typeof type.tag === 'number') {
+        console.error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
       }
     }
-    function getTaskName(type) {
-      if (type === REACT_FRAGMENT_TYPE) return "<>";
-      if (
-        "object" === typeof type &&
-        null !== type &&
-        type.$$typeof === REACT_LAZY_TYPE
-      )
-        return "<...>";
-      try {
-        var name = getComponentNameFromType(type);
-        return name ? "<" + name + ">" : "<...>";
-      } catch (x) {
-        return "<...>";
-      }
+    switch (type.$$typeof) {
+      case REACT_PORTAL_TYPE:
+        return 'Portal';
+      case REACT_CONTEXT_TYPE:
+        var context = type;
+        return getContextName(context);
+      case REACT_CONSUMER_TYPE:
+        var consumer = type;
+        return getContextName(consumer._context) + '.Consumer';
+      case REACT_FORWARD_REF_TYPE:
+        return getWrappedName(type, type.render, 'ForwardRef');
+      case REACT_MEMO_TYPE:
+        var outerName = type.displayName || null;
+        if (outerName !== null) {
+          return outerName;
+        }
+        return getComponentNameFromType(type.type) || 'Memo';
+      case REACT_LAZY_TYPE:
+        {
+          var lazyComponent = type;
+          var payload = lazyComponent._payload;
+          var init = lazyComponent._init;
+          try {
+            return getComponentNameFromType(init(payload));
+          } catch (x) {
+            return null;
+          }
+        }
     }
-    function getOwner() {
-      var dispatcher = ReactSharedInternals.A;
-      return null === dispatcher ? null : dispatcher.getOwner();
+  }
+  return null;
+}
+
+var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+
+// $FlowFixMe[method-unbinding]
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+
+/*
+ * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol
+ * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
+ *
+ * The functions in this module will throw an easier-to-understand,
+ * easier-to-debug exception with a clear errors message message explaining the
+ * problem. (Instead of a confusing exception thrown inside the implementation
+ * of the `value` object).
+ */
+
+// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
+function typeName(value) {
+  {
+    // toStringTag is needed for namespaced types like Temporal.Instant
+    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
+    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
+    // $FlowFixMe[incompatible-return]
+    return type;
+  }
+}
+
+// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
+function willCoercionThrow(value) {
+  {
+    try {
+      testStringCoercion(value);
+      return false;
+    } catch (e) {
+      return true;
     }
-    function UnknownOwner() {
-      return Error("react-stack-top-frame");
+  }
+}
+
+/** @noinline */
+function testStringCoercion(value) {
+  // If you ended up here by following an exception call stack, here's what's
+  // happened: you supplied an object or symbol value to React (as a prop, key,
+  // DOM attribute, CSS property, string ref, etc.) and when React tried to
+  // coerce it to a string using `'' + value`, an exception was thrown.
+  //
+  // The most common types that will cause this exception are `Symbol` instances
+  // and Temporal objects like `Temporal.Instant`. But any object that has a
+  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
+  // exception. (Library authors do this to prevent users from using built-in
+  // numeric operators like `+` or comparison operators like `>=` because custom
+  // methods are needed to perform accurate arithmetic or comparison.)
+  //
+  // To fix the problem, coerce this object or symbol value to a string before
+  // passing it to React. The most reliable way is usually `String(value)`.
+  //
+  // To find which value is throwing, check the browser or debugger console.
+  // Before this exception was thrown, there should be `console.error` output
+  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
+  // problem and how that type was used: key, atrribute, input value prop, etc.
+  // In most cases, this console output also shows the component and its
+  // ancestor components where the exception happened.
+  //
+  // eslint-disable-next-line react-internal/safe-string-coercion
+  return '' + value;
+}
+function checkKeyStringCoercion(value) {
+  {
+    if (willCoercionThrow(value)) {
+      console.error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));
+      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
     }
-    function hasValidKey(config) {
-      if (hasOwnProperty.call(config, "key")) {
-        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
-        if (getter && getter.isReactWarning) return !1;
-      }
-      return void 0 !== config.key;
+  }
+}
+
+var isArrayImpl = Array.isArray;
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+var createTask =
+// eslint-disable-next-line react-internal/no-production-logging
+console.createTask ?
+// eslint-disable-next-line react-internal/no-production-logging
+console.createTask : function () {
+  return null;
+};
+function getTaskName(type) {
+  if (type === REACT_FRAGMENT_TYPE) {
+    return '<>';
+  }
+  if (typeof type === 'object' && type !== null && type.$$typeof === REACT_LAZY_TYPE) {
+    // We don't want to eagerly initialize the initializer in DEV mode so we can't
+    // call it to extract the type so we don't know the type of this component.
+    return '<...>';
+  }
+  try {
+    var name = getComponentNameFromType(type);
+    return name ? '<' + name + '>' : '<...>';
+  } catch (x) {
+    return '<...>';
+  }
+}
+function getOwner() {
+  {
+    var dispatcher = ReactSharedInternals.A;
+    if (dispatcher === null) {
+      return null;
     }
-    function defineKeyPropWarningGetter(props, displayName) {
-      function warnAboutAccessingKey() {
-        specialPropKeyWarningShown ||
-          ((specialPropKeyWarningShown = !0),
-          console.error(
-            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
-            displayName
-          ));
+    return dispatcher.getOwner();
+  }
+}
+
+/** @noinline */
+function UnknownOwner() {
+  /** @noinline */
+  return function () {
+    return Error('react-stack-top-frame');
+  }();
+}
+var createFakeCallStack = {
+  react_stack_bottom_frame: function (callStackForError) {
+    return callStackForError();
+  }
+};
+var specialPropKeyWarningShown;
+var didWarnAboutElementRef;
+var unknownOwnerDebugStack;
+var unknownOwnerDebugTask;
+{
+  didWarnAboutElementRef = {};
+
+  // We use this technique to trick minifiers to preserve the function name.
+  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(createFakeCallStack, UnknownOwner)();
+  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
+}
+function hasValidKey(config) {
+  {
+    if (hasOwnProperty.call(config, 'key')) {
+      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
+      if (getter && getter.isReactWarning) {
+        return false;
       }
-      warnAboutAccessingKey.isReactWarning = !0;
-      Object.defineProperty(props, "key", {
-        get: warnAboutAccessingKey,
-        configurable: !0
-      });
     }
-    function elementRefGetterWithDeprecationWarning() {
-      var componentName = getComponentNameFromType(this.type);
-      didWarnAboutElementRef[componentName] ||
-        ((didWarnAboutElementRef[componentName] = !0),
-        console.error(
-          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
-        ));
-      componentName = this.props.ref;
-      return void 0 !== componentName ? componentName : null;
+  }
+  return config.key !== undefined;
+}
+function defineKeyPropWarningGetter(props, displayName) {
+  {
+    var warnAboutAccessingKey = function () {
+      if (!specialPropKeyWarningShown) {
+        specialPropKeyWarningShown = true;
+        console.error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://react.dev/link/special-props)', displayName);
+      }
+    };
+    warnAboutAccessingKey.isReactWarning = true;
+    Object.defineProperty(props, 'key', {
+      get: warnAboutAccessingKey,
+      configurable: true
+    });
+  }
+}
+function elementRefGetterWithDeprecationWarning() {
+  {
+    var componentName = getComponentNameFromType(this.type);
+    if (!didWarnAboutElementRef[componentName]) {
+      didWarnAboutElementRef[componentName] = true;
+      console.error('Accessing element.ref was removed in React 19. ref is now a ' + 'regular prop. It will be removed from the JSX Element ' + 'type in a future release.');
     }
-    function ReactElement(
-      type,
-      key,
-      self,
-      source,
-      owner,
-      props,
-      debugStack,
-      debugTask
-    ) {
-      self = props.ref;
-      type = {
-        $$typeof: REACT_ELEMENT_TYPE,
-        type: type,
-        key: key,
-        props: props,
-        _owner: owner
-      };
-      null !== (void 0 !== self ? self : null)
-        ? Object.defineProperty(type, "ref", {
-            enumerable: !1,
-            get: elementRefGetterWithDeprecationWarning
-          })
-        : Object.defineProperty(type, "ref", { enumerable: !1, value: null });
-      type._store = {};
-      Object.defineProperty(type._store, "validated", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: 0
+
+    // An undefined `element.ref` is coerced to `null` for
+    // backwards compatibility.
+    var refProp = this.props.ref;
+    return refProp !== undefined ? refProp : null;
+  }
+}
+
+/**
+ * Factory method to create a new React element. This no longer adheres to
+ * the class pattern, so do not use new to call it. Also, instanceof check
+ * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check
+ * if something is a React Element.
+ *
+ * @param {*} type
+ * @param {*} props
+ * @param {*} key
+ * @param {string|object} ref
+ * @param {*} owner
+ * @param {*} self A *temporary* helper to detect places where `this` is
+ * different from the `owner` when React.createElement is called, so that we
+ * can warn. We want to get rid of owner and replace string `ref`s with arrow
+ * functions, and as long as `this` and owner are the same, there will be no
+ * change in behavior.
+ * @param {*} source An annotation object (added by a transpiler or otherwise)
+ * indicating filename, line number, and/or other information.
+ * @internal
+ */
+function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
+  // Ignore whatever was passed as the ref argument and treat `props.ref` as
+  // the source of truth. The only thing we use this for is `element.ref`,
+  // which will log a deprecation warning on access. In the next release, we
+  // can remove `element.ref` as well as the `ref` argument.
+  var refProp = props.ref;
+
+  // An undefined `element.ref` is coerced to `null` for
+  // backwards compatibility.
+  var ref = refProp !== undefined ? refProp : null;
+  var element;
+  {
+    // In dev, make `ref` a non-enumerable property with a warning. It's non-
+    // enumerable so that test matchers and serializers don't access it and
+    // trigger the warning.
+    //
+    // `ref` will be removed from the element completely in a future release.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      // Built-in properties that belong on the element
+      type: type,
+      key: key,
+      props: props,
+      // Record the component responsible for creating this element.
+      _owner: owner
+    };
+    if (ref !== null) {
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
+        get: elementRefGetterWithDeprecationWarning
       });
-      Object.defineProperty(type, "_debugInfo", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
+    } else {
+      // Don't warn on access if a ref is not given. This reduces false
+      // positives in cases where a test serializer uses
+      // getOwnPropertyDescriptors to compare objects, like Jest does, which is
+      // a problem because it bypasses non-enumerability.
+      //
+      // So unfortunately this will trigger a false positive warning in Jest
+      // when the diff is printed:
+      //
+      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);
+      //
+      // A bit sketchy, but this is what we've done for the `props.key` and
+      // `props.ref` accessors for years, which implies it will be good enough
+      // for `element.ref`, too. Let's see if anyone complains.
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
         value: null
       });
-      Object.defineProperty(type, "_debugStack", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: debugStack
-      });
-      Object.defineProperty(type, "_debugTask", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: debugTask
+    }
+  }
+  {
+    // The validation flag is currently mutative. We put it on
+    // an external backing store so that we can freeze the whole object.
+    // This can be replaced with a WeakMap once they are implemented in
+    // commonly used development environments.
+    element._store = {};
+
+    // To make comparing ReactElements easier for testing purposes, we make
+    // the validation flag non-enumerable (where possible, which should
+    // include every environment we run tests in), so the test framework
+    // ignores it.
+    Object.defineProperty(element._store, 'validated', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: 0
+    });
+    // debugInfo contains Server Component debug information.
+    Object.defineProperty(element, '_debugInfo', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: null
+    });
+    Object.defineProperty(element, '_debugStack', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugStack
+    });
+    Object.defineProperty(element, '_debugTask', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugTask
+    });
+    if (Object.freeze) {
+      Object.freeze(element.props);
+      Object.freeze(element);
+    }
+  }
+  return element;
+}
+var didWarnAboutKeySpread = {};
+
+/**
+ * https://github.com/reactjs/rfcs/pull/107
+ * @param {*} type
+ * @param {object} props
+ * @param {string} key
+ */
+function jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {
+  var trackActualOwner = ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;
+  return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, (trackActualOwner ? Error('react-stack-top-frame') : unknownOwnerDebugStack), (trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask));
+}
+function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
+  {
+    // We don't warn for invalid element type here because with owner stacks,
+    // we error in the renderer. The renderer is the only one that knows what
+    // types are valid for this particular renderer so we let it error there.
+
+    // Skip key warning if the type isn't valid since our key validation logic
+    // doesn't expect a non-string/function type and can throw confusing
+    // errors. We don't want exception behavior to differ between dev and
+    // prod. (Rendering will throw with a helpful message and as soon as the
+    // type is fixed, the key warnings will appear.)
+    // With owner stacks, we no longer need the type here so this comment is
+    // no longer true. Which is why we can run this even for invalid types.
+    var children = config.children;
+    if (children !== undefined) {
+      if (isStaticChildren) {
+        if (isArray(children)) {
+          for (var i = 0; i < children.length; i++) {
+            validateChildKeys(children[i]);
+          }
+          if (Object.freeze) {
+            Object.freeze(children);
+          }
+        } else {
+          console.error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
+        }
+      } else {
+        validateChildKeys(children);
+      }
+    }
+
+    // Warn about key spread regardless of whether the type is valid.
+    if (hasOwnProperty.call(config, 'key')) {
+      var componentName = getComponentNameFromType(type);
+      var keys = Object.keys(config).filter(function (k) {
+        return k !== 'key';
       });
-      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
-      return type;
+      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';
+      if (!didWarnAboutKeySpread[componentName + beforeExample]) {
+        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';
+        console.error('A props object containing a "key" prop is being spread into JSX:\n' + '  let props = %s;\n' + '  <%s {...props} />\n' + 'React keys must be passed directly to JSX without using spread:\n' + '  let props = %s;\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
+        didWarnAboutKeySpread[componentName + beforeExample] = true;
+      }
+    }
+    var key = null;
+
+    // Currently, key can be spread in as a prop. This causes a potential
+    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
+    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
+    // but as an intermediary step, we will use jsxDEV for everything except
+    // <div {...props} key="Hi" />, because we aren't currently able to tell if
+    // key is explicitly declared to be undefined or not.
+    if (maybeKey !== undefined) {
+      {
+        checkKeyStringCoercion(maybeKey);
+      }
+      key = '' + maybeKey;
     }
-    function jsxDEVImpl(
-      type,
-      config,
-      maybeKey,
-      isStaticChildren,
-      source,
-      self,
-      debugStack,
-      debugTask
-    ) {
-      var children = config.children;
-      if (void 0 !== children)
-        if (isStaticChildren)
-          if (isArrayImpl(children)) {
-            for (
-              isStaticChildren = 0;
-              isStaticChildren < children.length;
-              isStaticChildren++
-            )
-              validateChildKeys(children[isStaticChildren]);
-            Object.freeze && Object.freeze(children);
-          } else
-            console.error(
-              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
-            );
-        else validateChildKeys(children);
-      if (hasOwnProperty.call(config, "key")) {
-        children = getComponentNameFromType(type);
-        var keys = Object.keys(config).filter(function (k) {
-          return "key" !== k;
-        });
-        isStaticChildren =
-          0 < keys.length
-            ? "{key: someKey, " + keys.join(": ..., ") + ": ...}"
-            : "{key: someKey}";
-        didWarnAboutKeySpread[children + isStaticChildren] ||
-          ((keys =
-            0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}"),
-          console.error(
-            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
-            isStaticChildren,
-            children,
-            keys,
-            children
-          ),
-          (didWarnAboutKeySpread[children + isStaticChildren] = !0));
+    if (hasValidKey(config)) {
+      {
+        checkKeyStringCoercion(config.key);
       }
-      children = null;
-      void 0 !== maybeKey &&
-        (checkKeyStringCoercion(maybeKey), (children = "" + maybeKey));
-      hasValidKey(config) &&
-        (checkKeyStringCoercion(config.key), (children = "" + config.key));
-      if ("key" in config) {
-        maybeKey = {};
-        for (var propName in config)
-          "key" !== propName && (maybeKey[propName] = config[propName]);
-      } else maybeKey = config;
-      children &&
-        defineKeyPropWarningGetter(
-          maybeKey,
-          "function" === typeof type
-            ? type.displayName || type.name || "Unknown"
-            : type
-        );
-      return ReactElement(
-        type,
-        children,
-        self,
-        source,
-        getOwner(),
-        maybeKey,
-        debugStack,
-        debugTask
-      );
+      key = '' + config.key;
     }
-    function validateChildKeys(node) {
-      "object" === typeof node &&
-        null !== node &&
-        node.$$typeof === REACT_ELEMENT_TYPE &&
-        node._store &&
-        (node._store.validated = 1);
+    var props;
+    if (!('key' in config)) {
+      // If key was not spread in, we can reuse the original props object. This
+      // only works for `jsx`, not `createElement`, because `jsx` is a compiler
+      // target and the compiler always passes a new object. For `createElement`,
+      // we can't assume a new object is passed every time because it can be
+      // called manually.
+      //
+      // Spreading key is a warning in dev. In a future release, we will not
+      // remove a spread key from the props object. (But we'll still warn.) We'll
+      // always pass the object straight through.
+      props = config;
+    } else {
+      // We need to remove reserved props (key, prop, ref). Create a fresh props
+      // object and copy over all the non-reserved props. We don't use `delete`
+      // because in V8 it will deopt the object to dictionary mode.
+      props = {};
+      for (var propName in config) {
+        // Skip over reserved prop names
+        if (propName !== 'key') {
+          props[propName] = config[propName];
+        }
+      }
     }
-    var React = require("react"),
-      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
-      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
-    Symbol.for("react.provider");
-    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
-      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
-      ReactSharedInternals =
-        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
-      hasOwnProperty = Object.prototype.hasOwnProperty,
-      isArrayImpl = Array.isArray,
-      createTask = console.createTask
-        ? console.createTask
-        : function () {
-            return null;
-          };
-    React = {
-      "react-stack-bottom-frame": function (callStackForError) {
-        return callStackForError();
+    if (key) {
+      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
+      defineKeyPropWarningGetter(props, displayName);
+    }
+    return ReactElement(type, key, self, source, getOwner(), props, debugStack, debugTask);
+  }
+}
+
+/**
+ * Ensure that every element either is passed in a static location, in an
+ * array with an explicit keys property defined, or in an object literal
+ * with valid key property.
+ *
+ * @internal
+ * @param {ReactNode} node Statically passed child of any type.
+ * @param {*} parentType node's parent's type.
+ */
+function validateChildKeys(node, parentType) {
+  {
+    // With owner stacks is, no warnings happens. All we do is
+    // mark elements as being in a valid static child position so they
+    // don't need keys.
+    if (isValidElement(node)) {
+      if (node._store) {
+        node._store.validated = 1;
       }
-    };
-    var specialPropKeyWarningShown;
-    var didWarnAboutElementRef = {};
-    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(
-      React,
-      UnknownOwner
-    )();
-    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
-    var didWarnAboutKeySpread = {};
-    exports.Fragment = REACT_FRAGMENT_TYPE;
-    exports.jsxDEV = function (
-      type,
-      config,
-      maybeKey,
-      isStaticChildren,
-      source,
-      self
-    ) {
-      var trackActualOwner =
-        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
-      return jsxDEVImpl(
-        type,
-        config,
-        maybeKey,
-        isStaticChildren,
-        source,
-        self,
-        trackActualOwner
-          ? Error("react-stack-top-frame")
-          : unknownOwnerDebugStack,
-        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
-      );
-    };
-  })();
+    }
+  }
+}
+
+/**
+ * Verifies the object is a ReactElement.
+ * See https://reactjs.org/docs/react-api.html#isvalidelement
+ * @param {?object} object
+ * @return {boolean} True if `object` is a ReactElement.
+ * @final
+ */
+function isValidElement(object) {
+  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
+}
+
+var jsxDEV = jsxDEV$1 ;
+
+exports.Fragment = REACT_FRAGMENT_TYPE;
+exports.jsxDEV = jsxDEV;
+//# sourceMappingURL=react-jsx-dev-runtime.development.js.map
diff --git a/cjs/react-jsx-dev-runtime.development.js.map b/cjs/react-jsx-dev-runtime.development.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..40145db334b968df0d1e0c644f5243dd3571fbf8
--- /dev/null
+++ b/cjs/react-jsx-dev-runtime.development.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react-jsx-dev-runtime.development.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactFeatureFlags.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/getComponentNameFromType.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSharedInternals.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/hasOwnProperty.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/CheckStringCoercion.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/isArray.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXElement.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSX.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n */\n\n// -----------------------------------------------------------------------------\n// Land or remove (zero effort)\n//\n// Flags that can likely be deleted or landed without consequences\n// -----------------------------------------------------------------------------\n\n// None\n\n// -----------------------------------------------------------------------------\n// Killswitch\n//\n// Flags that exist solely to turn off a change in case it causes a regression\n// when it rolls out to prod. We should remove these as soon as possible.\n// -----------------------------------------------------------------------------\n\nexport const enableHydrationLaneScheduling = true;\n\n// -----------------------------------------------------------------------------\n// Land or remove (moderate effort)\n//\n// Flags that can be probably deleted or landed, but might require extra effort\n// like migrating internal callers or performance testing.\n// -----------------------------------------------------------------------------\n\n// TODO: Finish rolling out in www\nexport const favorSafetyOverHydrationPerf = true;\n\n// Need to remove didTimeout argument from Scheduler before landing\nexport const disableSchedulerTimeoutInWorkLoop = false;\n\n// -----------------------------------------------------------------------------\n// Slated for removal in the future (significant effort)\n//\n// These are experiments that didn't work out, and never shipped, but we can't\n// delete from the codebase until we migrate internal callers.\n// -----------------------------------------------------------------------------\n\n// Add a callback property to suspense to notify which promises are currently\n// in the update queue. This allows reporting and tracing of what is causing\n// the user to see a loading state.\n//\n// Also allows hydration callbacks to fire when a dehydrated boundary gets\n// hydrated or deleted.\n//\n// This will eventually be replaced by the Transition Tracing proposal.\nexport const enableSuspenseCallback = false;\n\n// Experimental Scope support.\nexport const enableScopeAPI = false;\n\n// Experimental Create Event Handle API.\nexport const enableCreateEventHandleAPI = false;\n\n// Support legacy Primer support on internal FB www\nexport const enableLegacyFBSupport = false;\n\n// -----------------------------------------------------------------------------\n// Ongoing experiments\n//\n// These are features that we're either actively exploring or are reasonably\n// likely to include in an upcoming release.\n// -----------------------------------------------------------------------------\n\n// Yield to the browser event loop and not just the scheduler event loop before passive effects.\n// Fix gated tests that fail with this flag enabled before turning it back on.\nexport const enableYieldingBeforePassive = false;\n\n// Experiment to intentionally yield less to block high framerate animations.\nexport const enableThrottledScheduling = false;\n\nexport const enableLegacyCache = __EXPERIMENTAL__;\n\nexport const enableAsyncIterableChildren = __EXPERIMENTAL__;\n\nexport const enableTaint = __EXPERIMENTAL__;\n\nexport const enablePostpone = __EXPERIMENTAL__;\n\nexport const enableHalt = __EXPERIMENTAL__;\n\nexport const enableViewTransition = __EXPERIMENTAL__;\n\nexport const enableGestureTransition = __EXPERIMENTAL__;\n\nexport const enableScrollEndPolyfill = __EXPERIMENTAL__;\n\nexport const enableSuspenseyImages = false;\n\nexport const enableFizzBlockingRender = __EXPERIMENTAL__; // rel=\"expect\"\n\nexport const enableSrcObject = __EXPERIMENTAL__;\n\nexport const enableHydrationChangeEvent = __EXPERIMENTAL__;\n\nexport const enableDefaultTransitionIndicator = __EXPERIMENTAL__;\n\n/**\n * Switches Fiber creation to a simple object instead of a constructor.\n */\nexport const enableObjectFiber = false;\n\nexport const enableTransitionTracing = false;\n\n// FB-only usage. The new API has different semantics.\nexport const enableLegacyHidden = false;\n\n// Enables unstable_avoidThisFallback feature in Fiber\nexport const enableSuspenseAvoidThisFallback = false;\n\nexport const enableCPUSuspense = __EXPERIMENTAL__;\n\n// Test this at Meta before enabling.\nexport const enableNoCloningMemoCache = false;\n\nexport const enableUseEffectEventHook = __EXPERIMENTAL__;\n\n// Test in www before enabling in open source.\n// Enables DOM-server to stream its instruction set as data-attributes\n// (handled with an MutationObserver) instead of inline-scripts\nexport const enableFizzExternalRuntime = __EXPERIMENTAL__;\n\nexport const alwaysThrottleRetries = true;\n\nexport const passChildrenWhenCloningPersistedNodes = false;\n\n/**\n * Enables a new Fiber flag used in persisted mode to reduce the number\n * of cloned host components.\n */\nexport const enablePersistedModeClonedFlag = false;\n\nexport const enableEagerAlternateStateNodeCleanup = true;\n\n/**\n * Enables an expiration time for retry lanes to avoid starvation.\n */\nexport const enableRetryLaneExpiration = false;\nexport const retryLaneExpirationMs = 5000;\nexport const syncLaneExpirationMs = 250;\nexport const transitionLaneExpirationMs = 5000;\n\n/**\n * Enables a new error detection for infinite render loops from updates caused\n * by setState or similar outside of the component owning the state.\n */\nexport const enableInfiniteRenderLoopDetection = false;\n\nexport const enableLazyPublicInstanceInFabric = false;\n\nexport const enableFragmentRefs = __EXPERIMENTAL__;\n\n// -----------------------------------------------------------------------------\n// Ready for next major.\n//\n// Alias __NEXT_MAJOR__ to __EXPERIMENTAL__ for easier skimming.\n// -----------------------------------------------------------------------------\n\n// TODO: Anything that's set to `true` in this section should either be cleaned\n// up (if it's on everywhere, including Meta and RN builds) or moved to a\n// different section of this file.\n\n// const __NEXT_MAJOR__ = __EXPERIMENTAL__;\n\n// Renames the internal symbol for elements since they have changed signature/constructor\nexport const renameElementSymbol = true;\n\n/**\n * Enables a fix to run insertion effect cleanup on hidden subtrees.\n */\nexport const enableHiddenSubtreeInsertionEffectCleanup = false;\n\n/**\n * Removes legacy style context defined using static `contextTypes` and consumed with static `childContextTypes`.\n */\nexport const disableLegacyContext = true;\n/**\n * Removes legacy style context just from function components.\n */\nexport const disableLegacyContextForFunctionComponents = true;\n\n// Enable the moveBefore() alternative to insertBefore(). This preserves states of moves.\nexport const enableMoveBefore = false;\n\n// Disabled caching behavior of `react/cache` in client runtimes.\nexport const disableClientCache = true;\n\n// Warn on any usage of ReactTestRenderer\nexport const enableReactTestRendererWarning = true;\n\n// Disables legacy mode\n// This allows us to land breaking changes to remove legacy mode APIs in experimental builds\n// before removing them in stable in the next Major\nexport const disableLegacyMode = true;\n\n// -----------------------------------------------------------------------------\n// Chopping Block\n//\n// Planned feature deprecations and breaking changes. Sorted roughly in order of\n// when we plan to enable them.\n// -----------------------------------------------------------------------------\n\n// -----------------------------------------------------------------------------\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nexport const disableCommentsAsDOMContainers = true;\n\nexport const enableTrustedTypesIntegration = false;\n\n// Prevent the value and checked attributes from syncing with their related\n// DOM properties\nexport const disableInputAttributeSyncing = false;\n\n// Disables children for <textarea> elements\nexport const disableTextareaChildren = false;\n\n// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n\n// Gather advanced timing metrics for Profiler subtrees.\nexport const enableProfilerTimer = __PROFILE__;\n\n// Adds performance.measure() marks using Chrome extensions to allow formatted\n// Component rendering tracks to show up in the Performance tab.\n// This flag will be used for both Server Component and Client Component tracks.\n// All calls should also be gated on enableProfilerTimer.\nexport const enableComponentPerformanceTrack = __EXPERIMENTAL__;\n\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nexport const enableSchedulingProfiler: boolean =\n  !enableComponentPerformanceTrack && __PROFILE__;\n\n// Record durations for commit and passive effects phases.\nexport const enableProfilerCommitHooks = __PROFILE__;\n\n// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nexport const enableProfilerNestedUpdatePhase = __PROFILE__;\n\nexport const enableAsyncDebugInfo = __EXPERIMENTAL__;\n\n// Track which Fiber(s) schedule render work.\nexport const enableUpdaterTracking = __PROFILE__;\n\nexport const ownerStackLimit = 1e4;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {LazyComponent} from 'react/src/ReactLazy';\nimport type {ReactContext, ReactConsumerType} from 'shared/ReactTypes';\n\nimport {\n  REACT_CONTEXT_TYPE,\n  REACT_CONSUMER_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_TRACING_MARKER_TYPE,\n  REACT_VIEW_TRANSITION_TYPE,\n  REACT_ACTIVITY_TYPE,\n} from 'shared/ReactSymbols';\n\nimport {\n  enableTransitionTracing,\n  enableViewTransition,\n} from './ReactFeatureFlags';\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getWrappedName(\n  outerType: mixed,\n  innerType: any,\n  wrapperName: string,\n): string {\n  const displayName = (outerType: any).displayName;\n  if (displayName) {\n    return displayName;\n  }\n  const functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? `${wrapperName}(${functionName})` : wrapperName;\n}\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type: ReactContext<any>) {\n  return type.displayName || 'Context';\n}\n\nconst REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\n// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nexport default function getComponentNameFromType(type: mixed): string | null {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n  if (typeof type === 'function') {\n    if ((type: any).$$typeof === REACT_CLIENT_REFERENCE) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n    return (type: any).displayName || type.name || null;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n    case REACT_ACTIVITY_TYPE:\n      return 'Activity';\n    case REACT_VIEW_TRANSITION_TYPE:\n      if (enableViewTransition) {\n        return 'ViewTransition';\n      }\n    // Fall through\n    case REACT_TRACING_MARKER_TYPE:\n      if (enableTransitionTracing) {\n        return 'TracingMarker';\n      }\n  }\n  if (typeof type === 'object') {\n    if (__DEV__) {\n      if (typeof (type: any).tag === 'number') {\n        console.error(\n          'Received an unexpected object in getComponentNameFromType(). ' +\n            'This is likely a bug in React. Please file an issue.',\n        );\n      }\n    }\n    switch (type.$$typeof) {\n      case REACT_PORTAL_TYPE:\n        return 'Portal';\n      case REACT_CONTEXT_TYPE:\n        const context: ReactContext<any> = (type: any);\n        return getContextName(context);\n      case REACT_CONSUMER_TYPE:\n        const consumer: ReactConsumerType<any> = (type: any);\n        return getContextName(consumer._context) + '.Consumer';\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n      case REACT_MEMO_TYPE:\n        const outerName = (type: any).displayName || null;\n        if (outerName !== null) {\n          return outerName;\n        }\n        return getComponentNameFromType(type.type) || 'Memo';\n      case REACT_LAZY_TYPE: {\n        const lazyComponent: LazyComponent<any, any> = (type: any);\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n        try {\n          return getComponentNameFromType(init(payload));\n        } catch (x) {\n          return null;\n        }\n      }\n    }\n  }\n  return null;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport * as React from 'react';\n\nconst ReactSharedInternals =\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n\nexport default ReactSharedInternals;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// $FlowFixMe[method-unbinding]\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport default hasOwnProperty;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value: mixed): string {\n  if (__DEV__) {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    const hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    const type =\n      (hasToStringTag && (value: any)[Symbol.toStringTag]) ||\n      (value: any).constructor.name ||\n      'Object';\n    // $FlowFixMe[incompatible-return]\n    return type;\n  }\n}\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value: mixed): boolean {\n  if (__DEV__) {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\n/** @noinline */\nfunction testStringCoercion(value: mixed) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + (value: any);\n}\n\nexport function checkAttributeStringCoercion(\n  value: mixed,\n  attributeName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` attribute is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        attributeName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkKeyStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided key is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkPropStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` prop is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkOptionStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` option is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkCSSPropertyStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` CSS property is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkHtmlStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided HTML markup uses a value of unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkFormFieldValueStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'Form field values (value, checked, defaultValue, or defaultChecked props)' +\n          ' must be strings, not %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\ndeclare function isArray(a: mixed): boolean %checks(Array.isArray(a));\n\nconst isArrayImpl = Array.isArray;\n\nfunction isArray(a: mixed): boolean {\n  return isArrayImpl(a);\n}\n\nexport default isArray;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport assign from 'shared/assign';\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\nimport isArray from 'shared/isArray';\nimport {ownerStackLimit} from 'shared/ReactFeatureFlags';\n\nconst createTask =\n  // eslint-disable-next-line react-internal/no-production-logging\n  __DEV__ && console.createTask\n    ? // eslint-disable-next-line react-internal/no-production-logging\n      console.createTask\n    : () => null;\n\nfunction getTaskName(type) {\n  if (type === REACT_FRAGMENT_TYPE) {\n    return '<>';\n  }\n  if (\n    typeof type === 'object' &&\n    type !== null &&\n    type.$$typeof === REACT_LAZY_TYPE\n  ) {\n    // We don't want to eagerly initialize the initializer in DEV mode so we can't\n    // call it to extract the type so we don't know the type of this component.\n    return '<...>';\n  }\n  try {\n    const name = getComponentNameFromType(type);\n    return name ? '<' + name + '>' : '<...>';\n  } catch (x) {\n    return '<...>';\n  }\n}\n\nfunction getOwner() {\n  if (__DEV__) {\n    const dispatcher = ReactSharedInternals.A;\n    if (dispatcher === null) {\n      return null;\n    }\n    return dispatcher.getOwner();\n  }\n  return null;\n}\n\n/** @noinline */\nfunction UnknownOwner() {\n  /** @noinline */\n  return (() => Error('react-stack-top-frame'))();\n}\nconst createFakeCallStack = {\n  react_stack_bottom_frame: function (callStackForError) {\n    return callStackForError();\n  },\n};\n\nlet specialPropKeyWarningShown;\nlet didWarnAboutElementRef;\nlet didWarnAboutOldJSXRuntime;\nlet unknownOwnerDebugStack;\nlet unknownOwnerDebugTask;\n\nif (__DEV__) {\n  didWarnAboutElementRef = {};\n\n  // We use this technique to trick minifiers to preserve the function name.\n  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(\n    createFakeCallStack,\n    UnknownOwner,\n  )();\n  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://react.dev/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction elementRefGetterWithDeprecationWarning() {\n  if (__DEV__) {\n    const componentName = getComponentNameFromType(this.type);\n    if (!didWarnAboutElementRef[componentName]) {\n      didWarnAboutElementRef[componentName] = true;\n      console.error(\n        'Accessing element.ref was removed in React 19. ref is now a ' +\n          'regular prop. It will be removed from the JSX Element ' +\n          'type in a future release.',\n      );\n    }\n\n    // An undefined `element.ref` is coerced to `null` for\n    // backwards compatibility.\n    const refProp = this.props.ref;\n    return refProp !== undefined ? refProp : null;\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nfunction ReactElement(\n  type,\n  key,\n  self,\n  source,\n  owner,\n  props,\n  debugStack,\n  debugTask,\n) {\n  // Ignore whatever was passed as the ref argument and treat `props.ref` as\n  // the source of truth. The only thing we use this for is `element.ref`,\n  // which will log a deprecation warning on access. In the next release, we\n  // can remove `element.ref` as well as the `ref` argument.\n  const refProp = props.ref;\n\n  // An undefined `element.ref` is coerced to `null` for\n  // backwards compatibility.\n  const ref = refProp !== undefined ? refProp : null;\n\n  let element;\n  if (__DEV__) {\n    // In dev, make `ref` a non-enumerable property with a warning. It's non-\n    // enumerable so that test matchers and serializers don't access it and\n    // trigger the warning.\n    //\n    // `ref` will be removed from the element completely in a future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n\n      props,\n\n      // Record the component responsible for creating this element.\n      _owner: owner,\n    };\n    if (ref !== null) {\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        get: elementRefGetterWithDeprecationWarning,\n      });\n    } else {\n      // Don't warn on access if a ref is not given. This reduces false\n      // positives in cases where a test serializer uses\n      // getOwnPropertyDescriptors to compare objects, like Jest does, which is\n      // a problem because it bypasses non-enumerability.\n      //\n      // So unfortunately this will trigger a false positive warning in Jest\n      // when the diff is printed:\n      //\n      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);\n      //\n      // A bit sketchy, but this is what we've done for the `props.key` and\n      // `props.ref` accessors for years, which implies it will be good enough\n      // for `element.ref`, too. Let's see if anyone complains.\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        value: null,\n      });\n    }\n  } else {\n    // In prod, `ref` is a regular property and _owner doesn't exist.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n      ref,\n\n      props,\n    };\n  }\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: 0,\n    });\n    // debugInfo contains Server Component debug information.\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null,\n    });\n    Object.defineProperty(element, '_debugStack', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugStack,\n    });\n    Object.defineProperty(element, '_debugTask', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugTask,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxProd(type, config, maybeKey) {\n  let key = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  let props;\n  if (!('key' in config)) {\n    // If key was not spread in, we can reuse the original props object. This\n    // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n    // target and the compiler always passes a new object. For `createElement`,\n    // we can't assume a new object is passed every time because it can be\n    // called manually.\n    //\n    // Spreading key is a warning in dev. In a future release, we will not\n    // remove a spread key from the props object. (But we'll still warn.) We'll\n    // always pass the object straight through.\n    props = config;\n  } else {\n    // We need to remove reserved props (key, prop, ref). Create a fresh props\n    // object and copy over all the non-reserved props. We don't use `delete`\n    // because in V8 it will deopt the object to dictionary mode.\n    props = {};\n    for (const propName in config) {\n      // Skip over reserved prop names\n      if (propName !== 'key') {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    undefined,\n    undefined,\n  );\n}\n\n// While `jsxDEV` should never be called when running in production, we do\n// support `jsx` and `jsxs` when running in development. This supports the case\n// where a third-party dependency ships code that was compiled for production;\n// we want to still provide warnings in development.\n//\n// So these functions are the _dev_ implementations of the _production_\n// API signatures.\n//\n// Since these functions are dev-only, it's ok to add an indirection here. They\n// only exist to provide different versions of `isStaticChildren`. (We shouldn't\n// use this pattern for the prod versions, though, because it will add an call\n// frame.)\nexport function jsxProdSignatureRunningInDevWithDynamicChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = false;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nexport function jsxProdSignatureRunningInDevWithStaticChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = true;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nconst didWarnAboutKeySpread = {};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return jsxDEVImpl(\n    type,\n    config,\n    maybeKey,\n    isStaticChildren,\n    source,\n    self,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nfunction jsxDEVImpl(\n  type,\n  config,\n  maybeKey,\n  isStaticChildren,\n  source,\n  self,\n  debugStack,\n  debugTask,\n) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    // With owner stacks, we no longer need the type here so this comment is\n    // no longer true. Which is why we can run this even for invalid types.\n    const children = config.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          console.error(\n            'React.jsx: Static children should always be an array. ' +\n              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n              'Use the Babel transform instead.',\n          );\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n\n    // Warn about key spread regardless of whether the type is valid.\n    if (hasOwnProperty.call(config, 'key')) {\n      const componentName = getComponentNameFromType(type);\n      const keys = Object.keys(config).filter(k => k !== 'key');\n      const beforeExample =\n        keys.length > 0\n          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'\n          : '{key: someKey}';\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        const afterExample =\n          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n        console.error(\n          'A props object containing a \"key\" prop is being spread into JSX:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s {...props} />\\n' +\n            'React keys must be passed directly to JSX without using spread:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s key={someKey} {...props} />',\n          beforeExample,\n          componentName,\n          afterExample,\n          componentName,\n        );\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    let key = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    let props;\n    if (!('key' in config)) {\n      // If key was not spread in, we can reuse the original props object. This\n      // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n      // target and the compiler always passes a new object. For `createElement`,\n      // we can't assume a new object is passed every time because it can be\n      // called manually.\n      //\n      // Spreading key is a warning in dev. In a future release, we will not\n      // remove a spread key from the props object. (But we'll still warn.) We'll\n      // always pass the object straight through.\n      props = config;\n    } else {\n      // We need to remove reserved props (key, prop, ref). Create a fresh props\n      // object and copy over all the non-reserved props. We don't use `delete`\n      // because in V8 it will deopt the object to dictionary mode.\n      props = {};\n      for (const propName in config) {\n        // Skip over reserved prop names\n        if (propName !== 'key') {\n          props[propName] = config[propName];\n        }\n      }\n    }\n\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    return ReactElement(\n      type,\n      key,\n      self,\n      source,\n      getOwner(),\n      props,\n      debugStack,\n      debugTask,\n    );\n  }\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n  }\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const clonedElement = ReactElement(\n    oldElement.type,\n    newKey,\n    undefined,\n    undefined,\n    !__DEV__ ? undefined : oldElement._owner,\n    oldElement.props,\n    __DEV__ && oldElement._debugStack,\n    __DEV__ && oldElement._debugTask,\n  );\n  if (__DEV__) {\n    // The cloned element should inherit the original element's key validation.\n    if (oldElement._store) {\n      clonedElement._store.validated = oldElement._store.validated;\n    }\n  }\n  return clonedElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = !__DEV__ ? undefined : element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      owner = __DEV__ ? getOwner() : undefined;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // ...and maybe these, too, though we currently rely on them for\n        // warnings and debug information in dev. Need to decide if we're OK\n        // with dropping them. In the jsx() runtime it's not an issue because\n        // the data gets passed as separate arguments instead of props, but\n        // it would be nice to stop relying on them entirely so we can drop\n        // them from the internal Fiber field.\n        propName !== '__self' &&\n        propName !== '__source' &&\n        // Undefined `ref` is ignored by cloneElement. We treat it the same as\n        // if the property were missing. This is mostly for\n        // backwards compatibility.\n        !(propName === 'ref' && config.ref === undefined)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  const clonedElement = ReactElement(\n    element.type,\n    key,\n    undefined,\n    undefined,\n    owner,\n    props,\n    __DEV__ && element._debugStack,\n    __DEV__ && element._debugTask,\n  );\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], clonedElement.type);\n  }\n\n  return clonedElement;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    // With owner stacks is, no warnings happens. All we do is\n    // mark elements as being in a valid static child position so they\n    // don't need keys.\n    if (isValidElement(node)) {\n      if (node._store) {\n        node._store.validated = 1;\n      }\n    }\n  }\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport {REACT_FRAGMENT_TYPE} from 'shared/ReactSymbols';\nimport {\n  jsxProd,\n  jsxProdSignatureRunningInDevWithDynamicChildren,\n  jsxProdSignatureRunningInDevWithStaticChildren,\n  jsxDEV as _jsxDEV,\n} from './ReactJSXElement';\n\nconst jsx: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithDynamicChildren\n  : jsxProd;\n// we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\nconst jsxs: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithStaticChildren\n  : jsxProd;\n\nconst jsxDEV: any = __DEV__ ? _jsxDEV : undefined;\n\nexport {REACT_FRAGMENT_TYPE as Fragment, jsx, jsxs, jsxDEV};\n"],"names":["ownerStackLimit","REACT_ELEMENT_TYPE","Symbol","for","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_CONSUMER_TYPE","REACT_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_ACTIVITY_TYPE","REACT_VIEW_TRANSITION_TYPE","getWrappedName","outerType","innerType","wrapperName","displayName","functionName","name","getContextName","type","REACT_CLIENT_REFERENCE","getComponentNameFromType","$$typeof","tag","console","error","context","consumer","_context","render","outerName","lazyComponent","payload","_payload","init","_init","x","ReactSharedInternals","React","__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","hasOwnProperty","Object","prototype","typeName","value","hasToStringTag","toStringTag","constructor","willCoercionThrow","testStringCoercion","e","checkKeyStringCoercion","isArrayImpl","Array","isArray","a","createTask","getTaskName","getOwner","dispatcher","A","UnknownOwner","Error","createFakeCallStack","react_stack_bottom_frame","callStackForError","specialPropKeyWarningShown","didWarnAboutElementRef","unknownOwnerDebugStack","unknownOwnerDebugTask","bind","hasValidKey","config","call","getter","getOwnPropertyDescriptor","get","isReactWarning","key","undefined","defineKeyPropWarningGetter","props","warnAboutAccessingKey","defineProperty","configurable","elementRefGetterWithDeprecationWarning","componentName","refProp","ref","ReactElement","self","source","owner","debugStack","debugTask","element","_owner","enumerable","_store","writable","freeze","didWarnAboutKeySpread","jsxDEV","maybeKey","isStaticChildren","trackActualOwner","recentlyCreatedOwnerStacks","jsxDEVImpl","children","i","length","validateChildKeys","keys","filter","k","beforeExample","join","afterExample","propName","node","parentType","isValidElement","validated","object","_jsxDEV"],"mappings":"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"}
\ No newline at end of file
diff --git a/cjs/react-jsx-dev-runtime.production.js b/cjs/react-jsx-dev-runtime.production.js
index 22ad88648e07b02e4d3f311ade499ba1ac5b7738..1574772f257ae4910c7bdfe2ca8e5ba710507b6b 100644
--- a/cjs/react-jsx-dev-runtime.production.js
+++ b/cjs/react-jsx-dev-runtime.production.js
@@ -1,14 +1,9 @@
-/**
- * @license React
- * react-jsx-dev-runtime.production.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
+'use strict';
+
+const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+
+const jsxDEV = undefined;
 
-"use strict";
-var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
 exports.Fragment = REACT_FRAGMENT_TYPE;
-exports.jsxDEV = void 0;
+exports.jsxDEV = jsxDEV;
+//# sourceMappingURL=react-jsx-dev-runtime.production.js.map
diff --git a/cjs/react-jsx-dev-runtime.production.js.map b/cjs/react-jsx-dev-runtime.production.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..a4da1395ea0cbb5a5d429e36154f42d11234e0f0
--- /dev/null
+++ b/cjs/react-jsx-dev-runtime.production.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react-jsx-dev-runtime.production.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSX.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport {REACT_FRAGMENT_TYPE} from 'shared/ReactSymbols';\nimport {\n  jsxProd,\n  jsxProdSignatureRunningInDevWithDynamicChildren,\n  jsxProdSignatureRunningInDevWithStaticChildren,\n  jsxDEV as _jsxDEV,\n} from './ReactJSXElement';\n\nconst jsx: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithDynamicChildren\n  : jsxProd;\n// we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\nconst jsxs: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithStaticChildren\n  : jsxProd;\n\nconst jsxDEV: any = __DEV__ ? _jsxDEV : undefined;\n\nexport {REACT_FRAGMENT_TYPE as Fragment, jsx, jsxs, jsxDEV};\n"],"names":["REACT_FRAGMENT_TYPE","Symbol","for","jsxDEV","undefined"],"mappings":";;AAqBO,MAAMA,mBAAmB,GAAWC,MAAM,CAACC,GAAG,CAAC,gBAAgB;;ACItE,MAAMC,MAAM,GAA4BC;;;;;"}
\ No newline at end of file
diff --git a/cjs/react-jsx-dev-runtime.profiling.js b/cjs/react-jsx-dev-runtime.profiling.js
index f9e8942f4d6742eb1943b239809e3927143800b4..fc14096f950a8451d10d6902d44542ca3d64ddc9 100644
--- a/cjs/react-jsx-dev-runtime.profiling.js
+++ b/cjs/react-jsx-dev-runtime.profiling.js
@@ -1,14 +1,9 @@
-/**
- * @license React
- * react-jsx-dev-runtime.profiling.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
+'use strict';
+
+const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+
+const jsxDEV = undefined;
 
-"use strict";
-var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
 exports.Fragment = REACT_FRAGMENT_TYPE;
-exports.jsxDEV = void 0;
+exports.jsxDEV = jsxDEV;
+//# sourceMappingURL=react-jsx-dev-runtime.profiling.js.map
diff --git a/cjs/react-jsx-dev-runtime.profiling.js.map b/cjs/react-jsx-dev-runtime.profiling.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..ced38df54f782f30608d63ea5826762ddb0a2a7a
--- /dev/null
+++ b/cjs/react-jsx-dev-runtime.profiling.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react-jsx-dev-runtime.profiling.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSX.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport {REACT_FRAGMENT_TYPE} from 'shared/ReactSymbols';\nimport {\n  jsxProd,\n  jsxProdSignatureRunningInDevWithDynamicChildren,\n  jsxProdSignatureRunningInDevWithStaticChildren,\n  jsxDEV as _jsxDEV,\n} from './ReactJSXElement';\n\nconst jsx: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithDynamicChildren\n  : jsxProd;\n// we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\nconst jsxs: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithStaticChildren\n  : jsxProd;\n\nconst jsxDEV: any = __DEV__ ? _jsxDEV : undefined;\n\nexport {REACT_FRAGMENT_TYPE as Fragment, jsx, jsxs, jsxDEV};\n"],"names":["REACT_FRAGMENT_TYPE","Symbol","for","jsxDEV","undefined"],"mappings":";;AAqBO,MAAMA,mBAAmB,GAAWC,MAAM,CAACC,GAAG,CAAC,gBAAgB;;ACItE,MAAMC,MAAM,GAA4BC;;;;;"}
\ No newline at end of file
diff --git a/cjs/react-jsx-dev-runtime.react-server.development.js b/cjs/react-jsx-dev-runtime.react-server.development.js
index 9052d7ec6948b2957a29c20981d0e01a321e48df..19c6a9ed7bbc38cc1f5bd791d10fca5af1222bdf 100644
--- a/cjs/react-jsx-dev-runtime.react-server.development.js
+++ b/cjs/react-jsx-dev-runtime.react-server.development.js
@@ -1,385 +1,591 @@
-/**
- * @license React
- * react-jsx-dev-runtime.react-server.development.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
+'use strict';
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
-  (function () {
-    function getComponentNameFromType(type) {
-      if (null == type) return null;
-      if ("function" === typeof type)
-        return type.$$typeof === REACT_CLIENT_REFERENCE
-          ? null
-          : type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
-      switch (type) {
-        case REACT_FRAGMENT_TYPE:
-          return "Fragment";
-        case REACT_PROFILER_TYPE:
-          return "Profiler";
-        case REACT_STRICT_MODE_TYPE:
-          return "StrictMode";
-        case REACT_SUSPENSE_TYPE:
-          return "Suspense";
-        case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
-        case REACT_ACTIVITY_TYPE:
-          return "Activity";
-      }
-      if ("object" === typeof type)
-        switch (
-          ("number" === typeof type.tag &&
-            console.error(
-              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
-            ),
-          type.$$typeof)
-        ) {
-          case REACT_PORTAL_TYPE:
-            return "Portal";
-          case REACT_CONTEXT_TYPE:
-            return (type.displayName || "Context") + ".Provider";
-          case REACT_CONSUMER_TYPE:
-            return (type._context.displayName || "Context") + ".Consumer";
-          case REACT_FORWARD_REF_TYPE:
-            var innerType = type.render;
-            type = type.displayName;
-            type ||
-              ((type = innerType.displayName || innerType.name || ""),
-              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
-            return type;
-          case REACT_MEMO_TYPE:
-            return (
-              (innerType = type.displayName || null),
-              null !== innerType
-                ? innerType
-                : getComponentNameFromType(type.type) || "Memo"
-            );
-          case REACT_LAZY_TYPE:
-            innerType = type._payload;
-            type = type._init;
-            try {
-              return getComponentNameFromType(type(innerType));
-            } catch (x) {}
-        }
+var React = require('react');
+
+// -----------------------------------------------------------------------------
+// Land or remove (zero effort)
+//
+// Flags that can likely be deleted or landed without consequences
+// -----------------------------------------------------------------------------
+
+var ownerStackLimit = 1e4;
+
+var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+var REACT_PORTAL_TYPE = Symbol.for('react.portal');
+var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
+var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
+var REACT_CONSUMER_TYPE = Symbol.for('react.consumer');
+var REACT_CONTEXT_TYPE = Symbol.for('react.context');
+var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
+var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
+var REACT_MEMO_TYPE = Symbol.for('react.memo');
+var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+var REACT_ACTIVITY_TYPE = Symbol.for('react.activity');
+var REACT_VIEW_TRANSITION_TYPE = Symbol.for('react.view_transition');
+
+// Keep in sync with react-reconciler/getComponentNameFromFiber
+function getWrappedName(outerType, innerType, wrapperName) {
+  var displayName = outerType.displayName;
+  if (displayName) {
+    return displayName;
+  }
+  var functionName = innerType.displayName || innerType.name || '';
+  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
+}
+
+// Keep in sync with react-reconciler/getComponentNameFromFiber
+function getContextName(type) {
+  return type.displayName || 'Context';
+}
+var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
+
+// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
+function getComponentNameFromType(type) {
+  if (type == null) {
+    // Host root, text node or just invalid type.
+    return null;
+  }
+  if (typeof type === 'function') {
+    if (type.$$typeof === REACT_CLIENT_REFERENCE) {
+      // TODO: Create a convention for naming client references with debug info.
       return null;
     }
-    function testStringCoercion(value) {
-      return "" + value;
-    }
-    function checkKeyStringCoercion(value) {
-      try {
-        testStringCoercion(value);
-        var JSCompiler_inline_result = !1;
-      } catch (e) {
-        JSCompiler_inline_result = !0;
+    return type.displayName || type.name || null;
+  }
+  if (typeof type === 'string') {
+    return type;
+  }
+  switch (type) {
+    case REACT_FRAGMENT_TYPE:
+      return 'Fragment';
+    case REACT_PROFILER_TYPE:
+      return 'Profiler';
+    case REACT_STRICT_MODE_TYPE:
+      return 'StrictMode';
+    case REACT_SUSPENSE_TYPE:
+      return 'Suspense';
+    case REACT_SUSPENSE_LIST_TYPE:
+      return 'SuspenseList';
+    case REACT_ACTIVITY_TYPE:
+      return 'Activity';
+    case REACT_VIEW_TRANSITION_TYPE:
+      {
+        return 'ViewTransition';
       }
-      if (JSCompiler_inline_result) {
-        JSCompiler_inline_result = console;
-        var JSCompiler_temp_const = JSCompiler_inline_result.error;
-        var JSCompiler_inline_result$jscomp$0 =
-          ("function" === typeof Symbol &&
-            Symbol.toStringTag &&
-            value[Symbol.toStringTag]) ||
-          value.constructor.name ||
-          "Object";
-        JSCompiler_temp_const.call(
-          JSCompiler_inline_result,
-          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
-          JSCompiler_inline_result$jscomp$0
-        );
-        return testStringCoercion(value);
+  }
+  if (typeof type === 'object') {
+    {
+      if (typeof type.tag === 'number') {
+        console.error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
       }
     }
-    function getTaskName(type) {
-      if (type === REACT_FRAGMENT_TYPE) return "<>";
-      if (
-        "object" === typeof type &&
-        null !== type &&
-        type.$$typeof === REACT_LAZY_TYPE
-      )
-        return "<...>";
-      try {
-        var name = getComponentNameFromType(type);
-        return name ? "<" + name + ">" : "<...>";
-      } catch (x) {
-        return "<...>";
-      }
+    switch (type.$$typeof) {
+      case REACT_PORTAL_TYPE:
+        return 'Portal';
+      case REACT_CONTEXT_TYPE:
+        var context = type;
+        return getContextName(context);
+      case REACT_CONSUMER_TYPE:
+        var consumer = type;
+        return getContextName(consumer._context) + '.Consumer';
+      case REACT_FORWARD_REF_TYPE:
+        return getWrappedName(type, type.render, 'ForwardRef');
+      case REACT_MEMO_TYPE:
+        var outerName = type.displayName || null;
+        if (outerName !== null) {
+          return outerName;
+        }
+        return getComponentNameFromType(type.type) || 'Memo';
+      case REACT_LAZY_TYPE:
+        {
+          var lazyComponent = type;
+          var payload = lazyComponent._payload;
+          var init = lazyComponent._init;
+          try {
+            return getComponentNameFromType(init(payload));
+          } catch (x) {
+            return null;
+          }
+        }
+    }
+  }
+  return null;
+}
+
+var ReactSharedInternalsServer =
+// $FlowFixMe: It's defined in the one we resolve to.
+React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+if (!ReactSharedInternalsServer) {
+  throw new Error('The "react" package in this environment is not configured correctly. ' + 'The "react-server" condition must be enabled in any environment that ' + 'runs React Server Components.');
+}
+
+// $FlowFixMe[method-unbinding]
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+
+/*
+ * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol
+ * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
+ *
+ * The functions in this module will throw an easier-to-understand,
+ * easier-to-debug exception with a clear errors message message explaining the
+ * problem. (Instead of a confusing exception thrown inside the implementation
+ * of the `value` object).
+ */
+
+// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
+function typeName(value) {
+  {
+    // toStringTag is needed for namespaced types like Temporal.Instant
+    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
+    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
+    // $FlowFixMe[incompatible-return]
+    return type;
+  }
+}
+
+// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
+function willCoercionThrow(value) {
+  {
+    try {
+      testStringCoercion(value);
+      return false;
+    } catch (e) {
+      return true;
     }
-    function getOwner() {
-      var dispatcher = ReactSharedInternalsServer.A;
-      return null === dispatcher ? null : dispatcher.getOwner();
+  }
+}
+
+/** @noinline */
+function testStringCoercion(value) {
+  // If you ended up here by following an exception call stack, here's what's
+  // happened: you supplied an object or symbol value to React (as a prop, key,
+  // DOM attribute, CSS property, string ref, etc.) and when React tried to
+  // coerce it to a string using `'' + value`, an exception was thrown.
+  //
+  // The most common types that will cause this exception are `Symbol` instances
+  // and Temporal objects like `Temporal.Instant`. But any object that has a
+  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
+  // exception. (Library authors do this to prevent users from using built-in
+  // numeric operators like `+` or comparison operators like `>=` because custom
+  // methods are needed to perform accurate arithmetic or comparison.)
+  //
+  // To fix the problem, coerce this object or symbol value to a string before
+  // passing it to React. The most reliable way is usually `String(value)`.
+  //
+  // To find which value is throwing, check the browser or debugger console.
+  // Before this exception was thrown, there should be `console.error` output
+  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
+  // problem and how that type was used: key, atrribute, input value prop, etc.
+  // In most cases, this console output also shows the component and its
+  // ancestor components where the exception happened.
+  //
+  // eslint-disable-next-line react-internal/safe-string-coercion
+  return '' + value;
+}
+function checkKeyStringCoercion(value) {
+  {
+    if (willCoercionThrow(value)) {
+      console.error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));
+      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
     }
-    function UnknownOwner() {
-      return Error("react-stack-top-frame");
+  }
+}
+
+var isArrayImpl = Array.isArray;
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+var createTask =
+// eslint-disable-next-line react-internal/no-production-logging
+console.createTask ?
+// eslint-disable-next-line react-internal/no-production-logging
+console.createTask : function () {
+  return null;
+};
+function getTaskName(type) {
+  if (type === REACT_FRAGMENT_TYPE) {
+    return '<>';
+  }
+  if (typeof type === 'object' && type !== null && type.$$typeof === REACT_LAZY_TYPE) {
+    // We don't want to eagerly initialize the initializer in DEV mode so we can't
+    // call it to extract the type so we don't know the type of this component.
+    return '<...>';
+  }
+  try {
+    var name = getComponentNameFromType(type);
+    return name ? '<' + name + '>' : '<...>';
+  } catch (x) {
+    return '<...>';
+  }
+}
+function getOwner() {
+  {
+    var dispatcher = ReactSharedInternalsServer.A;
+    if (dispatcher === null) {
+      return null;
     }
-    function hasValidKey(config) {
-      if (hasOwnProperty.call(config, "key")) {
-        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
-        if (getter && getter.isReactWarning) return !1;
+    return dispatcher.getOwner();
+  }
+}
+
+/** @noinline */
+function UnknownOwner() {
+  /** @noinline */
+  return function () {
+    return Error('react-stack-top-frame');
+  }();
+}
+var createFakeCallStack = {
+  react_stack_bottom_frame: function (callStackForError) {
+    return callStackForError();
+  }
+};
+var specialPropKeyWarningShown;
+var didWarnAboutElementRef;
+var unknownOwnerDebugStack;
+var unknownOwnerDebugTask;
+{
+  didWarnAboutElementRef = {};
+
+  // We use this technique to trick minifiers to preserve the function name.
+  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(createFakeCallStack, UnknownOwner)();
+  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
+}
+function hasValidKey(config) {
+  {
+    if (hasOwnProperty.call(config, 'key')) {
+      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
+      if (getter && getter.isReactWarning) {
+        return false;
       }
-      return void 0 !== config.key;
     }
-    function defineKeyPropWarningGetter(props, displayName) {
-      function warnAboutAccessingKey() {
-        specialPropKeyWarningShown ||
-          ((specialPropKeyWarningShown = !0),
-          console.error(
-            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
-            displayName
-          ));
+  }
+  return config.key !== undefined;
+}
+function defineKeyPropWarningGetter(props, displayName) {
+  {
+    var warnAboutAccessingKey = function () {
+      if (!specialPropKeyWarningShown) {
+        specialPropKeyWarningShown = true;
+        console.error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://react.dev/link/special-props)', displayName);
       }
-      warnAboutAccessingKey.isReactWarning = !0;
-      Object.defineProperty(props, "key", {
-        get: warnAboutAccessingKey,
-        configurable: !0
-      });
-    }
-    function elementRefGetterWithDeprecationWarning() {
-      var componentName = getComponentNameFromType(this.type);
-      didWarnAboutElementRef[componentName] ||
-        ((didWarnAboutElementRef[componentName] = !0),
-        console.error(
-          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
-        ));
-      componentName = this.props.ref;
-      return void 0 !== componentName ? componentName : null;
+    };
+    warnAboutAccessingKey.isReactWarning = true;
+    Object.defineProperty(props, 'key', {
+      get: warnAboutAccessingKey,
+      configurable: true
+    });
+  }
+}
+function elementRefGetterWithDeprecationWarning() {
+  {
+    var componentName = getComponentNameFromType(this.type);
+    if (!didWarnAboutElementRef[componentName]) {
+      didWarnAboutElementRef[componentName] = true;
+      console.error('Accessing element.ref was removed in React 19. ref is now a ' + 'regular prop. It will be removed from the JSX Element ' + 'type in a future release.');
     }
-    function ReactElement(
-      type,
-      key,
-      self,
-      source,
-      owner,
-      props,
-      debugStack,
-      debugTask
-    ) {
-      self = props.ref;
-      type = {
-        $$typeof: REACT_ELEMENT_TYPE,
-        type: type,
-        key: key,
-        props: props,
-        _owner: owner
-      };
-      null !== (void 0 !== self ? self : null)
-        ? Object.defineProperty(type, "ref", {
-            enumerable: !1,
-            get: elementRefGetterWithDeprecationWarning
-          })
-        : Object.defineProperty(type, "ref", { enumerable: !1, value: null });
-      type._store = {};
-      Object.defineProperty(type._store, "validated", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: 0
+
+    // An undefined `element.ref` is coerced to `null` for
+    // backwards compatibility.
+    var refProp = this.props.ref;
+    return refProp !== undefined ? refProp : null;
+  }
+}
+
+/**
+ * Factory method to create a new React element. This no longer adheres to
+ * the class pattern, so do not use new to call it. Also, instanceof check
+ * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check
+ * if something is a React Element.
+ *
+ * @param {*} type
+ * @param {*} props
+ * @param {*} key
+ * @param {string|object} ref
+ * @param {*} owner
+ * @param {*} self A *temporary* helper to detect places where `this` is
+ * different from the `owner` when React.createElement is called, so that we
+ * can warn. We want to get rid of owner and replace string `ref`s with arrow
+ * functions, and as long as `this` and owner are the same, there will be no
+ * change in behavior.
+ * @param {*} source An annotation object (added by a transpiler or otherwise)
+ * indicating filename, line number, and/or other information.
+ * @internal
+ */
+function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
+  // Ignore whatever was passed as the ref argument and treat `props.ref` as
+  // the source of truth. The only thing we use this for is `element.ref`,
+  // which will log a deprecation warning on access. In the next release, we
+  // can remove `element.ref` as well as the `ref` argument.
+  var refProp = props.ref;
+
+  // An undefined `element.ref` is coerced to `null` for
+  // backwards compatibility.
+  var ref = refProp !== undefined ? refProp : null;
+  var element;
+  {
+    // In dev, make `ref` a non-enumerable property with a warning. It's non-
+    // enumerable so that test matchers and serializers don't access it and
+    // trigger the warning.
+    //
+    // `ref` will be removed from the element completely in a future release.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      // Built-in properties that belong on the element
+      type: type,
+      key: key,
+      props: props,
+      // Record the component responsible for creating this element.
+      _owner: owner
+    };
+    if (ref !== null) {
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
+        get: elementRefGetterWithDeprecationWarning
       });
-      Object.defineProperty(type, "_debugInfo", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
+    } else {
+      // Don't warn on access if a ref is not given. This reduces false
+      // positives in cases where a test serializer uses
+      // getOwnPropertyDescriptors to compare objects, like Jest does, which is
+      // a problem because it bypasses non-enumerability.
+      //
+      // So unfortunately this will trigger a false positive warning in Jest
+      // when the diff is printed:
+      //
+      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);
+      //
+      // A bit sketchy, but this is what we've done for the `props.key` and
+      // `props.ref` accessors for years, which implies it will be good enough
+      // for `element.ref`, too. Let's see if anyone complains.
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
         value: null
       });
-      Object.defineProperty(type, "_debugStack", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: debugStack
-      });
-      Object.defineProperty(type, "_debugTask", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: debugTask
+    }
+  }
+  {
+    // The validation flag is currently mutative. We put it on
+    // an external backing store so that we can freeze the whole object.
+    // This can be replaced with a WeakMap once they are implemented in
+    // commonly used development environments.
+    element._store = {};
+
+    // To make comparing ReactElements easier for testing purposes, we make
+    // the validation flag non-enumerable (where possible, which should
+    // include every environment we run tests in), so the test framework
+    // ignores it.
+    Object.defineProperty(element._store, 'validated', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: 0
+    });
+    // debugInfo contains Server Component debug information.
+    Object.defineProperty(element, '_debugInfo', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: null
+    });
+    Object.defineProperty(element, '_debugStack', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugStack
+    });
+    Object.defineProperty(element, '_debugTask', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugTask
+    });
+    if (Object.freeze) {
+      Object.freeze(element.props);
+      Object.freeze(element);
+    }
+  }
+  return element;
+}
+
+// While `jsxDEV` should never be called when running in production, we do
+// support `jsx` and `jsxs` when running in development. This supports the case
+// where a third-party dependency ships code that was compiled for production;
+// we want to still provide warnings in development.
+//
+// So these functions are the _dev_ implementations of the _production_
+// API signatures.
+//
+// Since these functions are dev-only, it's ok to add an indirection here. They
+// only exist to provide different versions of `isStaticChildren`. (We shouldn't
+// use this pattern for the prod versions, though, because it will add an call
+// frame.)
+function jsxProdSignatureRunningInDevWithDynamicChildren(type, config, maybeKey, source, self) {
+  {
+    var isStaticChildren = false;
+    var trackActualOwner = ReactSharedInternalsServer.recentlyCreatedOwnerStacks++ < ownerStackLimit;
+    return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, (trackActualOwner ? Error('react-stack-top-frame') : unknownOwnerDebugStack), (trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask));
+  }
+}
+function jsxProdSignatureRunningInDevWithStaticChildren(type, config, maybeKey, source, self) {
+  {
+    var isStaticChildren = true;
+    var trackActualOwner = ReactSharedInternalsServer.recentlyCreatedOwnerStacks++ < ownerStackLimit;
+    return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, (trackActualOwner ? Error('react-stack-top-frame') : unknownOwnerDebugStack), (trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask));
+  }
+}
+var didWarnAboutKeySpread = {};
+
+/**
+ * https://github.com/reactjs/rfcs/pull/107
+ * @param {*} type
+ * @param {object} props
+ * @param {string} key
+ */
+function jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {
+  var trackActualOwner = ReactSharedInternalsServer.recentlyCreatedOwnerStacks++ < ownerStackLimit;
+  return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, (trackActualOwner ? Error('react-stack-top-frame') : unknownOwnerDebugStack), (trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask));
+}
+function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
+  {
+    // We don't warn for invalid element type here because with owner stacks,
+    // we error in the renderer. The renderer is the only one that knows what
+    // types are valid for this particular renderer so we let it error there.
+
+    // Skip key warning if the type isn't valid since our key validation logic
+    // doesn't expect a non-string/function type and can throw confusing
+    // errors. We don't want exception behavior to differ between dev and
+    // prod. (Rendering will throw with a helpful message and as soon as the
+    // type is fixed, the key warnings will appear.)
+    // With owner stacks, we no longer need the type here so this comment is
+    // no longer true. Which is why we can run this even for invalid types.
+    var children = config.children;
+    if (children !== undefined) {
+      if (isStaticChildren) {
+        if (isArray(children)) {
+          for (var i = 0; i < children.length; i++) {
+            validateChildKeys(children[i]);
+          }
+          if (Object.freeze) {
+            Object.freeze(children);
+          }
+        } else {
+          console.error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
+        }
+      } else {
+        validateChildKeys(children);
+      }
+    }
+
+    // Warn about key spread regardless of whether the type is valid.
+    if (hasOwnProperty.call(config, 'key')) {
+      var componentName = getComponentNameFromType(type);
+      var keys = Object.keys(config).filter(function (k) {
+        return k !== 'key';
       });
-      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
-      return type;
+      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';
+      if (!didWarnAboutKeySpread[componentName + beforeExample]) {
+        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';
+        console.error('A props object containing a "key" prop is being spread into JSX:\n' + '  let props = %s;\n' + '  <%s {...props} />\n' + 'React keys must be passed directly to JSX without using spread:\n' + '  let props = %s;\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
+        didWarnAboutKeySpread[componentName + beforeExample] = true;
+      }
+    }
+    var key = null;
+
+    // Currently, key can be spread in as a prop. This causes a potential
+    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
+    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
+    // but as an intermediary step, we will use jsxDEV for everything except
+    // <div {...props} key="Hi" />, because we aren't currently able to tell if
+    // key is explicitly declared to be undefined or not.
+    if (maybeKey !== undefined) {
+      {
+        checkKeyStringCoercion(maybeKey);
+      }
+      key = '' + maybeKey;
     }
-    function jsxDEVImpl(
-      type,
-      config,
-      maybeKey,
-      isStaticChildren,
-      source,
-      self,
-      debugStack,
-      debugTask
-    ) {
-      var children = config.children;
-      if (void 0 !== children)
-        if (isStaticChildren)
-          if (isArrayImpl(children)) {
-            for (
-              isStaticChildren = 0;
-              isStaticChildren < children.length;
-              isStaticChildren++
-            )
-              validateChildKeys(children[isStaticChildren]);
-            Object.freeze && Object.freeze(children);
-          } else
-            console.error(
-              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
-            );
-        else validateChildKeys(children);
-      if (hasOwnProperty.call(config, "key")) {
-        children = getComponentNameFromType(type);
-        var keys = Object.keys(config).filter(function (k) {
-          return "key" !== k;
-        });
-        isStaticChildren =
-          0 < keys.length
-            ? "{key: someKey, " + keys.join(": ..., ") + ": ...}"
-            : "{key: someKey}";
-        didWarnAboutKeySpread[children + isStaticChildren] ||
-          ((keys =
-            0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}"),
-          console.error(
-            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
-            isStaticChildren,
-            children,
-            keys,
-            children
-          ),
-          (didWarnAboutKeySpread[children + isStaticChildren] = !0));
+    if (hasValidKey(config)) {
+      {
+        checkKeyStringCoercion(config.key);
       }
-      children = null;
-      void 0 !== maybeKey &&
-        (checkKeyStringCoercion(maybeKey), (children = "" + maybeKey));
-      hasValidKey(config) &&
-        (checkKeyStringCoercion(config.key), (children = "" + config.key));
-      if ("key" in config) {
-        maybeKey = {};
-        for (var propName in config)
-          "key" !== propName && (maybeKey[propName] = config[propName]);
-      } else maybeKey = config;
-      children &&
-        defineKeyPropWarningGetter(
-          maybeKey,
-          "function" === typeof type
-            ? type.displayName || type.name || "Unknown"
-            : type
-        );
-      return ReactElement(
-        type,
-        children,
-        self,
-        source,
-        getOwner(),
-        maybeKey,
-        debugStack,
-        debugTask
-      );
+      key = '' + config.key;
     }
-    function validateChildKeys(node) {
-      "object" === typeof node &&
-        null !== node &&
-        node.$$typeof === REACT_ELEMENT_TYPE &&
-        node._store &&
-        (node._store.validated = 1);
+    var props;
+    if (!('key' in config)) {
+      // If key was not spread in, we can reuse the original props object. This
+      // only works for `jsx`, not `createElement`, because `jsx` is a compiler
+      // target and the compiler always passes a new object. For `createElement`,
+      // we can't assume a new object is passed every time because it can be
+      // called manually.
+      //
+      // Spreading key is a warning in dev. In a future release, we will not
+      // remove a spread key from the props object. (But we'll still warn.) We'll
+      // always pass the object straight through.
+      props = config;
+    } else {
+      // We need to remove reserved props (key, prop, ref). Create a fresh props
+      // object and copy over all the non-reserved props. We don't use `delete`
+      // because in V8 it will deopt the object to dictionary mode.
+      props = {};
+      for (var propName in config) {
+        // Skip over reserved prop names
+        if (propName !== 'key') {
+          props[propName] = config[propName];
+        }
+      }
     }
-    var React = require("react"),
-      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
-      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
-    Symbol.for("react.provider");
-    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
-      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
-      ReactSharedInternalsServer =
-        React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
-    if (!ReactSharedInternalsServer)
-      throw Error(
-        'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
-      );
-    var hasOwnProperty = Object.prototype.hasOwnProperty,
-      isArrayImpl = Array.isArray,
-      createTask = console.createTask
-        ? console.createTask
-        : function () {
-            return null;
-          };
-    React = {
-      "react-stack-bottom-frame": function (callStackForError) {
-        return callStackForError();
+    if (key) {
+      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
+      defineKeyPropWarningGetter(props, displayName);
+    }
+    return ReactElement(type, key, self, source, getOwner(), props, debugStack, debugTask);
+  }
+}
+
+/**
+ * Ensure that every element either is passed in a static location, in an
+ * array with an explicit keys property defined, or in an object literal
+ * with valid key property.
+ *
+ * @internal
+ * @param {ReactNode} node Statically passed child of any type.
+ * @param {*} parentType node's parent's type.
+ */
+function validateChildKeys(node, parentType) {
+  {
+    // With owner stacks is, no warnings happens. All we do is
+    // mark elements as being in a valid static child position so they
+    // don't need keys.
+    if (isValidElement(node)) {
+      if (node._store) {
+        node._store.validated = 1;
       }
-    };
-    var specialPropKeyWarningShown;
-    var didWarnAboutElementRef = {};
-    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(
-      React,
-      UnknownOwner
-    )();
-    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
-    var didWarnAboutKeySpread = {};
-    exports.Fragment = REACT_FRAGMENT_TYPE;
-    exports.jsx = function (type, config, maybeKey, source, self) {
-      var trackActualOwner =
-        1e4 > ReactSharedInternalsServer.recentlyCreatedOwnerStacks++;
-      return jsxDEVImpl(
-        type,
-        config,
-        maybeKey,
-        !1,
-        source,
-        self,
-        trackActualOwner
-          ? Error("react-stack-top-frame")
-          : unknownOwnerDebugStack,
-        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
-      );
-    };
-    exports.jsxDEV = function (
-      type,
-      config,
-      maybeKey,
-      isStaticChildren,
-      source,
-      self
-    ) {
-      var trackActualOwner =
-        1e4 > ReactSharedInternalsServer.recentlyCreatedOwnerStacks++;
-      return jsxDEVImpl(
-        type,
-        config,
-        maybeKey,
-        isStaticChildren,
-        source,
-        self,
-        trackActualOwner
-          ? Error("react-stack-top-frame")
-          : unknownOwnerDebugStack,
-        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
-      );
-    };
-    exports.jsxs = function (type, config, maybeKey, source, self) {
-      var trackActualOwner =
-        1e4 > ReactSharedInternalsServer.recentlyCreatedOwnerStacks++;
-      return jsxDEVImpl(
-        type,
-        config,
-        maybeKey,
-        !0,
-        source,
-        self,
-        trackActualOwner
-          ? Error("react-stack-top-frame")
-          : unknownOwnerDebugStack,
-        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
-      );
-    };
-  })();
+    }
+  }
+}
+
+/**
+ * Verifies the object is a ReactElement.
+ * See https://reactjs.org/docs/react-api.html#isvalidelement
+ * @param {?object} object
+ * @return {boolean} True if `object` is a ReactElement.
+ * @final
+ */
+function isValidElement(object) {
+  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
+}
+
+var jsx = jsxProdSignatureRunningInDevWithDynamicChildren ;
+// we may want to special case jsxs internally to take advantage of static children.
+// for now we can ship identical prod functions
+var jsxs = jsxProdSignatureRunningInDevWithStaticChildren ;
+var jsxDEV = jsxDEV$1 ;
+
+exports.Fragment = REACT_FRAGMENT_TYPE;
+exports.jsx = jsx;
+exports.jsxDEV = jsxDEV;
+exports.jsxs = jsxs;
+//# sourceMappingURL=react-jsx-dev-runtime.react-server.development.js.map
diff --git a/cjs/react-jsx-dev-runtime.react-server.development.js.map b/cjs/react-jsx-dev-runtime.react-server.development.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..09995c2e360538e9154f489553b83f44db70ab49
--- /dev/null
+++ b/cjs/react-jsx-dev-runtime.react-server.development.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react-jsx-dev-runtime.react-server.development.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactFeatureFlags.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/getComponentNameFromType.js","/Users/liuhao/maodun/react-source-debug/react/packages/react-server/src/ReactSharedInternalsServer.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/hasOwnProperty.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/CheckStringCoercion.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/isArray.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXElement.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXServer.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n */\n\n// -----------------------------------------------------------------------------\n// Land or remove (zero effort)\n//\n// Flags that can likely be deleted or landed without consequences\n// -----------------------------------------------------------------------------\n\n// None\n\n// -----------------------------------------------------------------------------\n// Killswitch\n//\n// Flags that exist solely to turn off a change in case it causes a regression\n// when it rolls out to prod. We should remove these as soon as possible.\n// -----------------------------------------------------------------------------\n\nexport const enableHydrationLaneScheduling = true;\n\n// -----------------------------------------------------------------------------\n// Land or remove (moderate effort)\n//\n// Flags that can be probably deleted or landed, but might require extra effort\n// like migrating internal callers or performance testing.\n// -----------------------------------------------------------------------------\n\n// TODO: Finish rolling out in www\nexport const favorSafetyOverHydrationPerf = true;\n\n// Need to remove didTimeout argument from Scheduler before landing\nexport const disableSchedulerTimeoutInWorkLoop = false;\n\n// -----------------------------------------------------------------------------\n// Slated for removal in the future (significant effort)\n//\n// These are experiments that didn't work out, and never shipped, but we can't\n// delete from the codebase until we migrate internal callers.\n// -----------------------------------------------------------------------------\n\n// Add a callback property to suspense to notify which promises are currently\n// in the update queue. This allows reporting and tracing of what is causing\n// the user to see a loading state.\n//\n// Also allows hydration callbacks to fire when a dehydrated boundary gets\n// hydrated or deleted.\n//\n// This will eventually be replaced by the Transition Tracing proposal.\nexport const enableSuspenseCallback = false;\n\n// Experimental Scope support.\nexport const enableScopeAPI = false;\n\n// Experimental Create Event Handle API.\nexport const enableCreateEventHandleAPI = false;\n\n// Support legacy Primer support on internal FB www\nexport const enableLegacyFBSupport = false;\n\n// -----------------------------------------------------------------------------\n// Ongoing experiments\n//\n// These are features that we're either actively exploring or are reasonably\n// likely to include in an upcoming release.\n// -----------------------------------------------------------------------------\n\n// Yield to the browser event loop and not just the scheduler event loop before passive effects.\n// Fix gated tests that fail with this flag enabled before turning it back on.\nexport const enableYieldingBeforePassive = false;\n\n// Experiment to intentionally yield less to block high framerate animations.\nexport const enableThrottledScheduling = false;\n\nexport const enableLegacyCache = __EXPERIMENTAL__;\n\nexport const enableAsyncIterableChildren = __EXPERIMENTAL__;\n\nexport const enableTaint = __EXPERIMENTAL__;\n\nexport const enablePostpone = __EXPERIMENTAL__;\n\nexport const enableHalt = __EXPERIMENTAL__;\n\nexport const enableViewTransition = __EXPERIMENTAL__;\n\nexport const enableGestureTransition = __EXPERIMENTAL__;\n\nexport const enableScrollEndPolyfill = __EXPERIMENTAL__;\n\nexport const enableSuspenseyImages = false;\n\nexport const enableFizzBlockingRender = __EXPERIMENTAL__; // rel=\"expect\"\n\nexport const enableSrcObject = __EXPERIMENTAL__;\n\nexport const enableHydrationChangeEvent = __EXPERIMENTAL__;\n\nexport const enableDefaultTransitionIndicator = __EXPERIMENTAL__;\n\n/**\n * Switches Fiber creation to a simple object instead of a constructor.\n */\nexport const enableObjectFiber = false;\n\nexport const enableTransitionTracing = false;\n\n// FB-only usage. The new API has different semantics.\nexport const enableLegacyHidden = false;\n\n// Enables unstable_avoidThisFallback feature in Fiber\nexport const enableSuspenseAvoidThisFallback = false;\n\nexport const enableCPUSuspense = __EXPERIMENTAL__;\n\n// Test this at Meta before enabling.\nexport const enableNoCloningMemoCache = false;\n\nexport const enableUseEffectEventHook = __EXPERIMENTAL__;\n\n// Test in www before enabling in open source.\n// Enables DOM-server to stream its instruction set as data-attributes\n// (handled with an MutationObserver) instead of inline-scripts\nexport const enableFizzExternalRuntime = __EXPERIMENTAL__;\n\nexport const alwaysThrottleRetries = true;\n\nexport const passChildrenWhenCloningPersistedNodes = false;\n\n/**\n * Enables a new Fiber flag used in persisted mode to reduce the number\n * of cloned host components.\n */\nexport const enablePersistedModeClonedFlag = false;\n\nexport const enableEagerAlternateStateNodeCleanup = true;\n\n/**\n * Enables an expiration time for retry lanes to avoid starvation.\n */\nexport const enableRetryLaneExpiration = false;\nexport const retryLaneExpirationMs = 5000;\nexport const syncLaneExpirationMs = 250;\nexport const transitionLaneExpirationMs = 5000;\n\n/**\n * Enables a new error detection for infinite render loops from updates caused\n * by setState or similar outside of the component owning the state.\n */\nexport const enableInfiniteRenderLoopDetection = false;\n\nexport const enableLazyPublicInstanceInFabric = false;\n\nexport const enableFragmentRefs = __EXPERIMENTAL__;\n\n// -----------------------------------------------------------------------------\n// Ready for next major.\n//\n// Alias __NEXT_MAJOR__ to __EXPERIMENTAL__ for easier skimming.\n// -----------------------------------------------------------------------------\n\n// TODO: Anything that's set to `true` in this section should either be cleaned\n// up (if it's on everywhere, including Meta and RN builds) or moved to a\n// different section of this file.\n\n// const __NEXT_MAJOR__ = __EXPERIMENTAL__;\n\n// Renames the internal symbol for elements since they have changed signature/constructor\nexport const renameElementSymbol = true;\n\n/**\n * Enables a fix to run insertion effect cleanup on hidden subtrees.\n */\nexport const enableHiddenSubtreeInsertionEffectCleanup = false;\n\n/**\n * Removes legacy style context defined using static `contextTypes` and consumed with static `childContextTypes`.\n */\nexport const disableLegacyContext = true;\n/**\n * Removes legacy style context just from function components.\n */\nexport const disableLegacyContextForFunctionComponents = true;\n\n// Enable the moveBefore() alternative to insertBefore(). This preserves states of moves.\nexport const enableMoveBefore = false;\n\n// Disabled caching behavior of `react/cache` in client runtimes.\nexport const disableClientCache = true;\n\n// Warn on any usage of ReactTestRenderer\nexport const enableReactTestRendererWarning = true;\n\n// Disables legacy mode\n// This allows us to land breaking changes to remove legacy mode APIs in experimental builds\n// before removing them in stable in the next Major\nexport const disableLegacyMode = true;\n\n// -----------------------------------------------------------------------------\n// Chopping Block\n//\n// Planned feature deprecations and breaking changes. Sorted roughly in order of\n// when we plan to enable them.\n// -----------------------------------------------------------------------------\n\n// -----------------------------------------------------------------------------\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nexport const disableCommentsAsDOMContainers = true;\n\nexport const enableTrustedTypesIntegration = false;\n\n// Prevent the value and checked attributes from syncing with their related\n// DOM properties\nexport const disableInputAttributeSyncing = false;\n\n// Disables children for <textarea> elements\nexport const disableTextareaChildren = false;\n\n// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n\n// Gather advanced timing metrics for Profiler subtrees.\nexport const enableProfilerTimer = __PROFILE__;\n\n// Adds performance.measure() marks using Chrome extensions to allow formatted\n// Component rendering tracks to show up in the Performance tab.\n// This flag will be used for both Server Component and Client Component tracks.\n// All calls should also be gated on enableProfilerTimer.\nexport const enableComponentPerformanceTrack = __EXPERIMENTAL__;\n\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nexport const enableSchedulingProfiler: boolean =\n  !enableComponentPerformanceTrack && __PROFILE__;\n\n// Record durations for commit and passive effects phases.\nexport const enableProfilerCommitHooks = __PROFILE__;\n\n// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nexport const enableProfilerNestedUpdatePhase = __PROFILE__;\n\nexport const enableAsyncDebugInfo = __EXPERIMENTAL__;\n\n// Track which Fiber(s) schedule render work.\nexport const enableUpdaterTracking = __PROFILE__;\n\nexport const ownerStackLimit = 1e4;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {LazyComponent} from 'react/src/ReactLazy';\nimport type {ReactContext, ReactConsumerType} from 'shared/ReactTypes';\n\nimport {\n  REACT_CONTEXT_TYPE,\n  REACT_CONSUMER_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_TRACING_MARKER_TYPE,\n  REACT_VIEW_TRANSITION_TYPE,\n  REACT_ACTIVITY_TYPE,\n} from 'shared/ReactSymbols';\n\nimport {\n  enableTransitionTracing,\n  enableViewTransition,\n} from './ReactFeatureFlags';\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getWrappedName(\n  outerType: mixed,\n  innerType: any,\n  wrapperName: string,\n): string {\n  const displayName = (outerType: any).displayName;\n  if (displayName) {\n    return displayName;\n  }\n  const functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? `${wrapperName}(${functionName})` : wrapperName;\n}\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type: ReactContext<any>) {\n  return type.displayName || 'Context';\n}\n\nconst REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\n// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nexport default function getComponentNameFromType(type: mixed): string | null {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n  if (typeof type === 'function') {\n    if ((type: any).$$typeof === REACT_CLIENT_REFERENCE) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n    return (type: any).displayName || type.name || null;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n    case REACT_ACTIVITY_TYPE:\n      return 'Activity';\n    case REACT_VIEW_TRANSITION_TYPE:\n      if (enableViewTransition) {\n        return 'ViewTransition';\n      }\n    // Fall through\n    case REACT_TRACING_MARKER_TYPE:\n      if (enableTransitionTracing) {\n        return 'TracingMarker';\n      }\n  }\n  if (typeof type === 'object') {\n    if (__DEV__) {\n      if (typeof (type: any).tag === 'number') {\n        console.error(\n          'Received an unexpected object in getComponentNameFromType(). ' +\n            'This is likely a bug in React. Please file an issue.',\n        );\n      }\n    }\n    switch (type.$$typeof) {\n      case REACT_PORTAL_TYPE:\n        return 'Portal';\n      case REACT_CONTEXT_TYPE:\n        const context: ReactContext<any> = (type: any);\n        return getContextName(context);\n      case REACT_CONSUMER_TYPE:\n        const consumer: ReactConsumerType<any> = (type: any);\n        return getContextName(consumer._context) + '.Consumer';\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n      case REACT_MEMO_TYPE:\n        const outerName = (type: any).displayName || null;\n        if (outerName !== null) {\n          return outerName;\n        }\n        return getComponentNameFromType(type.type) || 'Memo';\n      case REACT_LAZY_TYPE: {\n        const lazyComponent: LazyComponent<any, any> = (type: any);\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n        try {\n          return getComponentNameFromType(init(payload));\n        } catch (x) {\n          return null;\n        }\n      }\n    }\n  }\n  return null;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {SharedStateServer} from 'react/src/ReactSharedInternalsServer';\n\nimport * as React from 'react';\n\nconst ReactSharedInternalsServer: SharedStateServer =\n  // $FlowFixMe: It's defined in the one we resolve to.\n  React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n\nif (!ReactSharedInternalsServer) {\n  throw new Error(\n    'The \"react\" package in this environment is not configured correctly. ' +\n      'The \"react-server\" condition must be enabled in any environment that ' +\n      'runs React Server Components.',\n  );\n}\n\nexport default ReactSharedInternalsServer;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// $FlowFixMe[method-unbinding]\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport default hasOwnProperty;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value: mixed): string {\n  if (__DEV__) {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    const hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    const type =\n      (hasToStringTag && (value: any)[Symbol.toStringTag]) ||\n      (value: any).constructor.name ||\n      'Object';\n    // $FlowFixMe[incompatible-return]\n    return type;\n  }\n}\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value: mixed): boolean {\n  if (__DEV__) {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\n/** @noinline */\nfunction testStringCoercion(value: mixed) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + (value: any);\n}\n\nexport function checkAttributeStringCoercion(\n  value: mixed,\n  attributeName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` attribute is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        attributeName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkKeyStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided key is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkPropStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` prop is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkOptionStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` option is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkCSSPropertyStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` CSS property is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkHtmlStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided HTML markup uses a value of unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkFormFieldValueStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'Form field values (value, checked, defaultValue, or defaultChecked props)' +\n          ' must be strings, not %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\ndeclare function isArray(a: mixed): boolean %checks(Array.isArray(a));\n\nconst isArrayImpl = Array.isArray;\n\nfunction isArray(a: mixed): boolean {\n  return isArrayImpl(a);\n}\n\nexport default isArray;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport assign from 'shared/assign';\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\nimport isArray from 'shared/isArray';\nimport {ownerStackLimit} from 'shared/ReactFeatureFlags';\n\nconst createTask =\n  // eslint-disable-next-line react-internal/no-production-logging\n  __DEV__ && console.createTask\n    ? // eslint-disable-next-line react-internal/no-production-logging\n      console.createTask\n    : () => null;\n\nfunction getTaskName(type) {\n  if (type === REACT_FRAGMENT_TYPE) {\n    return '<>';\n  }\n  if (\n    typeof type === 'object' &&\n    type !== null &&\n    type.$$typeof === REACT_LAZY_TYPE\n  ) {\n    // We don't want to eagerly initialize the initializer in DEV mode so we can't\n    // call it to extract the type so we don't know the type of this component.\n    return '<...>';\n  }\n  try {\n    const name = getComponentNameFromType(type);\n    return name ? '<' + name + '>' : '<...>';\n  } catch (x) {\n    return '<...>';\n  }\n}\n\nfunction getOwner() {\n  if (__DEV__) {\n    const dispatcher = ReactSharedInternals.A;\n    if (dispatcher === null) {\n      return null;\n    }\n    return dispatcher.getOwner();\n  }\n  return null;\n}\n\n/** @noinline */\nfunction UnknownOwner() {\n  /** @noinline */\n  return (() => Error('react-stack-top-frame'))();\n}\nconst createFakeCallStack = {\n  react_stack_bottom_frame: function (callStackForError) {\n    return callStackForError();\n  },\n};\n\nlet specialPropKeyWarningShown;\nlet didWarnAboutElementRef;\nlet didWarnAboutOldJSXRuntime;\nlet unknownOwnerDebugStack;\nlet unknownOwnerDebugTask;\n\nif (__DEV__) {\n  didWarnAboutElementRef = {};\n\n  // We use this technique to trick minifiers to preserve the function name.\n  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(\n    createFakeCallStack,\n    UnknownOwner,\n  )();\n  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://react.dev/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction elementRefGetterWithDeprecationWarning() {\n  if (__DEV__) {\n    const componentName = getComponentNameFromType(this.type);\n    if (!didWarnAboutElementRef[componentName]) {\n      didWarnAboutElementRef[componentName] = true;\n      console.error(\n        'Accessing element.ref was removed in React 19. ref is now a ' +\n          'regular prop. It will be removed from the JSX Element ' +\n          'type in a future release.',\n      );\n    }\n\n    // An undefined `element.ref` is coerced to `null` for\n    // backwards compatibility.\n    const refProp = this.props.ref;\n    return refProp !== undefined ? refProp : null;\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nfunction ReactElement(\n  type,\n  key,\n  self,\n  source,\n  owner,\n  props,\n  debugStack,\n  debugTask,\n) {\n  // Ignore whatever was passed as the ref argument and treat `props.ref` as\n  // the source of truth. The only thing we use this for is `element.ref`,\n  // which will log a deprecation warning on access. In the next release, we\n  // can remove `element.ref` as well as the `ref` argument.\n  const refProp = props.ref;\n\n  // An undefined `element.ref` is coerced to `null` for\n  // backwards compatibility.\n  const ref = refProp !== undefined ? refProp : null;\n\n  let element;\n  if (__DEV__) {\n    // In dev, make `ref` a non-enumerable property with a warning. It's non-\n    // enumerable so that test matchers and serializers don't access it and\n    // trigger the warning.\n    //\n    // `ref` will be removed from the element completely in a future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n\n      props,\n\n      // Record the component responsible for creating this element.\n      _owner: owner,\n    };\n    if (ref !== null) {\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        get: elementRefGetterWithDeprecationWarning,\n      });\n    } else {\n      // Don't warn on access if a ref is not given. This reduces false\n      // positives in cases where a test serializer uses\n      // getOwnPropertyDescriptors to compare objects, like Jest does, which is\n      // a problem because it bypasses non-enumerability.\n      //\n      // So unfortunately this will trigger a false positive warning in Jest\n      // when the diff is printed:\n      //\n      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);\n      //\n      // A bit sketchy, but this is what we've done for the `props.key` and\n      // `props.ref` accessors for years, which implies it will be good enough\n      // for `element.ref`, too. Let's see if anyone complains.\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        value: null,\n      });\n    }\n  } else {\n    // In prod, `ref` is a regular property and _owner doesn't exist.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n      ref,\n\n      props,\n    };\n  }\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: 0,\n    });\n    // debugInfo contains Server Component debug information.\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null,\n    });\n    Object.defineProperty(element, '_debugStack', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugStack,\n    });\n    Object.defineProperty(element, '_debugTask', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugTask,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxProd(type, config, maybeKey) {\n  let key = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  let props;\n  if (!('key' in config)) {\n    // If key was not spread in, we can reuse the original props object. This\n    // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n    // target and the compiler always passes a new object. For `createElement`,\n    // we can't assume a new object is passed every time because it can be\n    // called manually.\n    //\n    // Spreading key is a warning in dev. In a future release, we will not\n    // remove a spread key from the props object. (But we'll still warn.) We'll\n    // always pass the object straight through.\n    props = config;\n  } else {\n    // We need to remove reserved props (key, prop, ref). Create a fresh props\n    // object and copy over all the non-reserved props. We don't use `delete`\n    // because in V8 it will deopt the object to dictionary mode.\n    props = {};\n    for (const propName in config) {\n      // Skip over reserved prop names\n      if (propName !== 'key') {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    undefined,\n    undefined,\n  );\n}\n\n// While `jsxDEV` should never be called when running in production, we do\n// support `jsx` and `jsxs` when running in development. This supports the case\n// where a third-party dependency ships code that was compiled for production;\n// we want to still provide warnings in development.\n//\n// So these functions are the _dev_ implementations of the _production_\n// API signatures.\n//\n// Since these functions are dev-only, it's ok to add an indirection here. They\n// only exist to provide different versions of `isStaticChildren`. (We shouldn't\n// use this pattern for the prod versions, though, because it will add an call\n// frame.)\nexport function jsxProdSignatureRunningInDevWithDynamicChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = false;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nexport function jsxProdSignatureRunningInDevWithStaticChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = true;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nconst didWarnAboutKeySpread = {};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return jsxDEVImpl(\n    type,\n    config,\n    maybeKey,\n    isStaticChildren,\n    source,\n    self,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nfunction jsxDEVImpl(\n  type,\n  config,\n  maybeKey,\n  isStaticChildren,\n  source,\n  self,\n  debugStack,\n  debugTask,\n) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    // With owner stacks, we no longer need the type here so this comment is\n    // no longer true. Which is why we can run this even for invalid types.\n    const children = config.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          console.error(\n            'React.jsx: Static children should always be an array. ' +\n              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n              'Use the Babel transform instead.',\n          );\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n\n    // Warn about key spread regardless of whether the type is valid.\n    if (hasOwnProperty.call(config, 'key')) {\n      const componentName = getComponentNameFromType(type);\n      const keys = Object.keys(config).filter(k => k !== 'key');\n      const beforeExample =\n        keys.length > 0\n          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'\n          : '{key: someKey}';\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        const afterExample =\n          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n        console.error(\n          'A props object containing a \"key\" prop is being spread into JSX:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s {...props} />\\n' +\n            'React keys must be passed directly to JSX without using spread:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s key={someKey} {...props} />',\n          beforeExample,\n          componentName,\n          afterExample,\n          componentName,\n        );\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    let key = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    let props;\n    if (!('key' in config)) {\n      // If key was not spread in, we can reuse the original props object. This\n      // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n      // target and the compiler always passes a new object. For `createElement`,\n      // we can't assume a new object is passed every time because it can be\n      // called manually.\n      //\n      // Spreading key is a warning in dev. In a future release, we will not\n      // remove a spread key from the props object. (But we'll still warn.) We'll\n      // always pass the object straight through.\n      props = config;\n    } else {\n      // We need to remove reserved props (key, prop, ref). Create a fresh props\n      // object and copy over all the non-reserved props. We don't use `delete`\n      // because in V8 it will deopt the object to dictionary mode.\n      props = {};\n      for (const propName in config) {\n        // Skip over reserved prop names\n        if (propName !== 'key') {\n          props[propName] = config[propName];\n        }\n      }\n    }\n\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    return ReactElement(\n      type,\n      key,\n      self,\n      source,\n      getOwner(),\n      props,\n      debugStack,\n      debugTask,\n    );\n  }\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n  }\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const clonedElement = ReactElement(\n    oldElement.type,\n    newKey,\n    undefined,\n    undefined,\n    !__DEV__ ? undefined : oldElement._owner,\n    oldElement.props,\n    __DEV__ && oldElement._debugStack,\n    __DEV__ && oldElement._debugTask,\n  );\n  if (__DEV__) {\n    // The cloned element should inherit the original element's key validation.\n    if (oldElement._store) {\n      clonedElement._store.validated = oldElement._store.validated;\n    }\n  }\n  return clonedElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = !__DEV__ ? undefined : element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      owner = __DEV__ ? getOwner() : undefined;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // ...and maybe these, too, though we currently rely on them for\n        // warnings and debug information in dev. Need to decide if we're OK\n        // with dropping them. In the jsx() runtime it's not an issue because\n        // the data gets passed as separate arguments instead of props, but\n        // it would be nice to stop relying on them entirely so we can drop\n        // them from the internal Fiber field.\n        propName !== '__self' &&\n        propName !== '__source' &&\n        // Undefined `ref` is ignored by cloneElement. We treat it the same as\n        // if the property were missing. This is mostly for\n        // backwards compatibility.\n        !(propName === 'ref' && config.ref === undefined)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  const clonedElement = ReactElement(\n    element.type,\n    key,\n    undefined,\n    undefined,\n    owner,\n    props,\n    __DEV__ && element._debugStack,\n    __DEV__ && element._debugTask,\n  );\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], clonedElement.type);\n  }\n\n  return clonedElement;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    // With owner stacks is, no warnings happens. All we do is\n    // mark elements as being in a valid static child position so they\n    // don't need keys.\n    if (isValidElement(node)) {\n      if (node._store) {\n        node._store.validated = 1;\n      }\n    }\n  }\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport {REACT_FRAGMENT_TYPE} from 'shared/ReactSymbols';\nimport {\n  jsxProd,\n  jsxProdSignatureRunningInDevWithDynamicChildren,\n  jsxProdSignatureRunningInDevWithStaticChildren,\n  jsxDEV as _jsxDEV,\n} from './ReactJSXElement';\n\nconst jsx: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithDynamicChildren\n  : jsxProd;\n// we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\nconst jsxs: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithStaticChildren\n  : jsxProd;\n\nconst jsxDEV: any = __DEV__ ? _jsxDEV : undefined;\n\nexport {REACT_FRAGMENT_TYPE as Fragment, jsx, jsxs, jsxDEV};\n"],"names":["ownerStackLimit","REACT_ELEMENT_TYPE","Symbol","for","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_CONSUMER_TYPE","REACT_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_ACTIVITY_TYPE","REACT_VIEW_TRANSITION_TYPE","getWrappedName","outerType","innerType","wrapperName","displayName","functionName","name","getContextName","type","REACT_CLIENT_REFERENCE","getComponentNameFromType","$$typeof","tag","console","error","context","consumer","_context","render","outerName","lazyComponent","payload","_payload","init","_init","x","ReactSharedInternalsServer","React","__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","Error","hasOwnProperty","Object","prototype","typeName","value","hasToStringTag","toStringTag","constructor","willCoercionThrow","testStringCoercion","e","checkKeyStringCoercion","isArrayImpl","Array","isArray","a","createTask","getTaskName","getOwner","dispatcher","ReactSharedInternals","A","UnknownOwner","createFakeCallStack","react_stack_bottom_frame","callStackForError","specialPropKeyWarningShown","didWarnAboutElementRef","unknownOwnerDebugStack","unknownOwnerDebugTask","bind","hasValidKey","config","call","getter","getOwnPropertyDescriptor","get","isReactWarning","key","undefined","defineKeyPropWarningGetter","props","warnAboutAccessingKey","defineProperty","configurable","elementRefGetterWithDeprecationWarning","componentName","refProp","ref","ReactElement","self","source","owner","debugStack","debugTask","element","_owner","enumerable","_store","writable","freeze","jsxProdSignatureRunningInDevWithDynamicChildren","maybeKey","isStaticChildren","trackActualOwner","recentlyCreatedOwnerStacks","jsxDEVImpl","jsxProdSignatureRunningInDevWithStaticChildren","didWarnAboutKeySpread","jsxDEV","children","i","length","validateChildKeys","keys","filter","k","beforeExample","join","afterExample","propName","node","parentType","isValidElement","validated","object","jsx","jsxs","_jsxDEV"],"mappings":";;;;AASA;AACA;AACA;AACA;AACA;;AAsPO,IAAMA,eAAe,GAAG,GAAG;;AClP3B,IAAMC,kBAAkB,GAC3BC,MAAM,CAACC,GAAG,CAAC,4BAA4B,CAAC,CACf,CAAA;AACtB,IAAMC,iBAAiB,GAAWF,MAAM,CAACC,GAAG,CAAC,cAAc,CAAC,CAAA;AAC5D,IAAME,mBAAmB,GAAWH,MAAM,CAACC,GAAG,CAAC,gBAAgB,EAAC;AAChE,IAAMG,sBAAsB,GAAWJ,MAAM,CAACC,GAAG,CAAC,mBAAmB,CAAC,CAAA;AACtE,IAAMI,mBAAmB,GAAWL,MAAM,CAACC,GAAG,CAAC,gBAAgB,CAAC,CAAA;AAChE,IAAMK,mBAAmB,GAAWN,MAAM,CAACC,GAAG,CAAC,gBAAgB,CAAC,CAAA;AAChE,IAAMM,kBAAkB,GAAWP,MAAM,CAACC,GAAG,CAAC,eAAe,CAAC,CAAA;AAC9D,IAAMO,sBAAsB,GAAWR,MAAM,CAACC,GAAG,CAAC,mBAAmB,CAAC,CAAA;AACtE,IAAMQ,mBAAmB,GAAWT,MAAM,CAACC,GAAG,CAAC,gBAAgB,CAAC,CAAA;AAChE,IAAMS,wBAAwB,GAAWV,MAAM,CAACC,GAAG,CACxD,qBACF,CAAC,CAAA;AACM,IAAMU,eAAe,GAAWX,MAAM,CAACC,GAAG,CAAC,YAAY,CAAC,CAAA;AACxD,IAAMW,eAAe,GAAWZ,MAAM,CAACC,GAAG,CAAC,YAAY,CAAC,CAAA;AAExD,IAAMY,mBAAmB,GAAWb,MAAM,CAACC,GAAG,CAAC,gBAAgB,CAAC,CAAA;AAchE,IAAMa,0BAA0B,GAAWd,MAAM,CAACC,GAAG,CAC1D,uBACF,CAAC;;AChBD;AACA,SAASc,cAAcA,CACrBC,SAAS,EACTC,SAAS,EACTC,WAAW,EACH;AACR,EAAA,IAAMC,WAAW,GAAIH,SAAS,CAAOG,WAAW,CAAA;AAChD,EAAA,IAAIA,WAAW,EAAE;AACf,IAAA,OAAOA,WAAW,CAAA;AACpB,GAAA;EACA,IAAMC,YAAY,GAAGH,SAAS,CAACE,WAAW,IAAIF,SAAS,CAACI,IAAI,IAAI,EAAE,CAAA;EAClE,OAAOD,YAAY,KAAK,EAAE,GAAMF,WAAW,GAAIE,GAAAA,GAAAA,YAAY,SAAMF,WAAW,CAAA;AAC9E,CAAA;;AAEA;AACA,SAASI,cAAcA,CAACC,IAAI,EAAqB;AAC/C,EAAA,OAAOA,IAAI,CAACJ,WAAW,IAAI,SAAS,CAAA;AACtC,CAAA;AAEA,IAAMK,sBAAsB,GAAGxB,MAAM,CAACC,GAAG,CAAC,wBAAwB,CAAC,CAAA;;AAEnE;AACe,SAASwB,wBAAwBA,CAACF,IAAI,EAAwB;EAC3E,IAAIA,IAAI,IAAI,IAAI,EAAE;AAChB;AACA,IAAA,OAAO,IAAI,CAAA;AACb,GAAA;AACA,EAAA,IAAI,OAAOA,IAAI,KAAK,UAAU,EAAE;AAC9B,IAAA,IAAKA,IAAI,CAAOG,QAAQ,KAAKF,sBAAsB,EAAE;AACnD;AACA,MAAA,OAAO,IAAI,CAAA;AACb,KAAA;IACA,OAAQD,IAAI,CAAOJ,WAAW,IAAII,IAAI,CAACF,IAAI,IAAI,IAAI,CAAA;AACrD,GAAA;AACA,EAAA,IAAI,OAAOE,IAAI,KAAK,QAAQ,EAAE;AAC5B,IAAA,OAAOA,IAAI,CAAA;AACb,GAAA;AACA,EAAA,QAAQA,IAAI;AACV,IAAA,KAAKpB,mBAAmB;AACtB,MAAA,OAAO,UAAU,CAAA;AACnB,IAAA,KAAKE,mBAAmB;AACtB,MAAA,OAAO,UAAU,CAAA;AACnB,IAAA,KAAKD,sBAAsB;AACzB,MAAA,OAAO,YAAY,CAAA;AACrB,IAAA,KAAKK,mBAAmB;AACtB,MAAA,OAAO,UAAU,CAAA;AACnB,IAAA,KAAKC,wBAAwB;AAC3B,MAAA,OAAO,cAAc,CAAA;AACvB,IAAA,KAAKG,mBAAmB;AACtB,MAAA,OAAO,UAAU,CAAA;AACnB,IAAA,KAAKC,0BAA0B;AAC7B,MAA0B;AACxB,QAAA,OAAO,gBAAgB,CAAA;AACzB,OAAA;AAMJ,GAAA;AACA,EAAA,IAAI,OAAOS,IAAI,KAAK,QAAQ,EAAE;AAC5B,IAAa;AACX,MAAA,IAAI,OAAQA,IAAI,CAAOI,GAAG,KAAK,QAAQ,EAAE;AACvCC,QAAAA,OAAO,CAACC,KAAK,CACX,+DAA+D,GAC7D,sDACJ,CAAC,CAAA;AACH,OAAA;AACF,KAAA;IACA,QAAQN,IAAI,CAACG,QAAQ;AACnB,MAAA,KAAKxB,iBAAiB;AACpB,QAAA,OAAO,QAAQ,CAAA;AACjB,MAAA,KAAKK,kBAAkB;QACrB,IAAMuB,OAAO,GAAuBP,IAAU,CAAA;QAC9C,OAAOD,cAAc,CAACQ,OAAO,CAAC,CAAA;AAChC,MAAA,KAAKxB,mBAAmB;QACtB,IAAMyB,QAAQ,GAA4BR,IAAU,CAAA;AACpD,QAAA,OAAOD,cAAc,CAACS,QAAQ,CAACC,QAAQ,CAAC,GAAG,WAAW,CAAA;AACxD,MAAA,KAAKxB,sBAAsB;QACzB,OAAOO,cAAc,CAACQ,IAAI,EAAEA,IAAI,CAACU,MAAM,EAAE,YAAY,CAAC,CAAA;AACxD,MAAA,KAAKtB,eAAe;AAClB,QAAA,IAAMuB,SAAS,GAAIX,IAAI,CAAOJ,WAAW,IAAI,IAAI,CAAA;QACjD,IAAIe,SAAS,KAAK,IAAI,EAAE;AACtB,UAAA,OAAOA,SAAS,CAAA;AAClB,SAAA;AACA,QAAA,OAAOT,wBAAwB,CAACF,IAAI,CAACA,IAAI,CAAC,IAAI,MAAM,CAAA;AACtD,MAAA,KAAKX,eAAe;AAAE,QAAA;UACpB,IAAMuB,aAAa,GAA6BZ,IAAU,CAAA;AAC1D,UAAA,IAAMa,OAAO,GAAGD,aAAa,CAACE,QAAQ,CAAA;AACtC,UAAA,IAAMC,IAAI,GAAGH,aAAa,CAACI,KAAK,CAAA;UAChC,IAAI;AACF,YAAA,OAAOd,wBAAwB,CAACa,IAAI,CAACF,OAAO,CAAC,CAAC,CAAA;WAC/C,CAAC,OAAOI,CAAC,EAAE;AACV,YAAA,OAAO,IAAI,CAAA;AACb,WAAA;AACF,SAAA;AACF,KAAA;AACF,GAAA;AACA,EAAA,OAAO,IAAI,CAAA;AACb;;ACxHA,IAAMC,0BAA0B;AAC9B;AACAC,KAAK,CAACC,+DAA+D,CAAA;AAEvE,IAAI,CAACF,0BAA0B,EAAE;EAC/B,MAAM,IAAIG,KAAK,CACb,uEAAuE,GACrE,uEAAuE,GACvE,+BACJ,CAAC,CAAA;AACH;;ACdA;AACA,IAAMC,cAAc,GAAGC,MAAM,CAACC,SAAS,CAACF,cAAc;;ACDtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAASG,QAAQA,CAACC,KAAK,EAAiB;AACtC,EAAa;AACX;IACA,IAAMC,cAAc,GAAG,OAAOlD,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACmD,WAAW,CAAA;AACzE,IAAA,IAAM5B,IAAI,GACP2B,cAAc,IAAKD,KAAK,CAAOjD,MAAM,CAACmD,WAAW,CAAC,IAClDF,KAAK,CAAOG,WAAW,CAAC/B,IAAI,IAC7B,QAAQ,CAAA;AACV;AACA,IAAA,OAAOE,IAAI,CAAA;AACb,GAAA;AACF,CAAA;;AAEA;AACA,SAAS8B,iBAAiBA,CAACJ,KAAK,EAAkB;AAChD,EAAa;IACX,IAAI;MACFK,kBAAkB,CAACL,KAAK,CAAC,CAAA;AACzB,MAAA,OAAO,KAAK,CAAA;KACb,CAAC,OAAOM,CAAC,EAAE;AACV,MAAA,OAAO,IAAI,CAAA;AACb,KAAA;AACF,GAAA;AACF,CAAA;;AAEA;AACA,SAASD,kBAAkBA,CAACL,KAAK,EAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACA,OAAO,EAAE,GAAIA,KAAW,CAAA;AAC1B,CAAA;AAmBO,SAASO,sBAAsBA,CAACP,KAAK,EAAwB;AAClE,EAAa;AACX,IAAA,IAAII,iBAAiB,CAACJ,KAAK,CAAC,EAAE;MAC5BrB,OAAO,CAACC,KAAK,CACX,6CAA6C,GAC3C,+DAA+D,EACjEmB,QAAQ,CAACC,KAAK,CAChB,CAAC,CAAA;AACD,MAAA,OAAOK,kBAAkB,CAACL,KAAK,CAAC,CAAC;AACnC,KAAA;AACF,GAAA;AACF;;AC1FA,IAAMQ,WAAW,GAAGC,KAAK,CAACC,OAAO,CAAA;AAEjC,SAASA,OAAOA,CAACC,CAAC,EAAkB;EAClC,OAAOH,WAAW,CAACG,CAAC,CAAC,CAAA;AACvB;;ACKA,IAAMC,UAAU;AACd;AACWjC,OAAO,CAACiC,UAAU;AACzB;AACAjC,OAAO,CAACiC,UAAU,GAClB,YAAA;AAAA,EAAA,OAAM,IAAI,CAAA;AAAA,CAAA,CAAA;AAEhB,SAASC,WAAWA,CAACvC,IAAI,EAAE;EACzB,IAAIA,IAAI,KAAKpB,mBAAmB,EAAE;AAChC,IAAA,OAAO,IAAI,CAAA;AACb,GAAA;AACA,EAAA,IACE,OAAOoB,IAAI,KAAK,QAAQ,IACxBA,IAAI,KAAK,IAAI,IACbA,IAAI,CAACG,QAAQ,KAAKd,eAAe,EACjC;AACA;AACA;AACA,IAAA,OAAO,OAAO,CAAA;AAChB,GAAA;EACA,IAAI;AACF,IAAA,IAAMS,IAAI,GAAGI,wBAAwB,CAACF,IAAI,CAAC,CAAA;IAC3C,OAAOF,IAAI,GAAG,GAAG,GAAGA,IAAI,GAAG,GAAG,GAAG,OAAO,CAAA;GACzC,CAAC,OAAOmB,CAAC,EAAE;AACV,IAAA,OAAO,OAAO,CAAA;AAChB,GAAA;AACF,CAAA;AAEA,SAASuB,QAAQA,GAAG;AAClB,EAAa;AACX,IAAA,IAAMC,UAAU,GAAGC,0BAAoB,CAACC,CAAC,CAAA;IACzC,IAAIF,UAAU,KAAK,IAAI,EAAE;AACvB,MAAA,OAAO,IAAI,CAAA;AACb,KAAA;AACA,IAAA,OAAOA,UAAU,CAACD,QAAQ,EAAE,CAAA;AAC9B,GAAA;AAEF,CAAA;;AAEA;AACA,SAASI,YAAYA,GAAG;AACtB;EACA,OAAQ,YAAA;IAAA,OAAMvB,KAAK,CAAC,uBAAuB,CAAC,CAAA;AAAA,GAAA,EAAG,CAAA;AACjD,CAAA;AACA,IAAMwB,mBAAmB,GAAG;AAC1BC,EAAAA,wBAAwB,EAAE,UAAUC,iBAAiB,EAAE;IACrD,OAAOA,iBAAiB,EAAE,CAAA;AAC5B,GAAA;AACF,CAAC,CAAA;AAED,IAAIC,0BAA0B,CAAA;AAC9B,IAAIC,sBAAsB,CAAA;AAE1B,IAAIC,sBAAsB,CAAA;AAC1B,IAAIC,qBAAqB,CAAA;AAEZ;EACXF,sBAAsB,GAAG,EAAE,CAAA;;AAE3B;AACAC,EAAAA,sBAAsB,GAAGL,mBAAmB,CAACC,wBAAwB,CAACM,IAAI,CACxEP,mBAAmB,EACnBD,YACF,CAAC,EAAE,CAAA;AACHO,EAAAA,qBAAqB,GAAGb,UAAU,CAACC,WAAW,CAACK,YAAY,CAAC,CAAC,CAAA;AAC/D,CAAA;AAcA,SAASS,WAAWA,CAACC,MAAM,EAAE;AAC3B,EAAa;IACX,IAAIhC,cAAc,CAACiC,IAAI,CAACD,MAAM,EAAE,KAAK,CAAC,EAAE;MACtC,IAAME,MAAM,GAAGjC,MAAM,CAACkC,wBAAwB,CAACH,MAAM,EAAE,KAAK,CAAC,CAACI,GAAG,CAAA;AACjE,MAAA,IAAIF,MAAM,IAAIA,MAAM,CAACG,cAAc,EAAE;AACnC,QAAA,OAAO,KAAK,CAAA;AACd,OAAA;AACF,KAAA;AACF,GAAA;AACA,EAAA,OAAOL,MAAM,CAACM,GAAG,KAAKC,SAAS,CAAA;AACjC,CAAA;AAEA,SAASC,0BAA0BA,CAACC,KAAK,EAAEnE,WAAW,EAAE;AACtD,EAAa;AACX,IAAA,IAAMoE,qBAAqB,GAAG,YAAY;MACxC,IAAI,CAAChB,0BAA0B,EAAE;AAC/BA,QAAAA,0BAA0B,GAAG,IAAI,CAAA;AACjC3C,QAAAA,OAAO,CAACC,KAAK,CACX,2DAA2D,GACzD,gEAAgE,GAChE,sEAAsE,GACtE,8CAA8C,EAChDV,WACF,CAAC,CAAA;AACH,OAAA;KACD,CAAA;IACDoE,qBAAqB,CAACL,cAAc,GAAG,IAAI,CAAA;AAC3CpC,IAAAA,MAAM,CAAC0C,cAAc,CAACF,KAAK,EAAE,KAAK,EAAE;AAClCL,MAAAA,GAAG,EAAEM,qBAAqB;AAC1BE,MAAAA,YAAY,EAAE,IAAA;AAChB,KAAC,CAAC,CAAA;AACJ,GAAA;AACF,CAAA;AAEA,SAASC,sCAAsCA,GAAG;AAChD,EAAa;AACX,IAAA,IAAMC,aAAa,GAAGlE,wBAAwB,CAAC,IAAI,CAACF,IAAI,CAAC,CAAA;AACzD,IAAA,IAAI,CAACiD,sBAAsB,CAACmB,aAAa,CAAC,EAAE;AAC1CnB,MAAAA,sBAAsB,CAACmB,aAAa,CAAC,GAAG,IAAI,CAAA;MAC5C/D,OAAO,CAACC,KAAK,CACX,8DAA8D,GAC5D,wDAAwD,GACxD,2BACJ,CAAC,CAAA;AACH,KAAA;;AAEA;AACA;AACA,IAAA,IAAM+D,OAAO,GAAG,IAAI,CAACN,KAAK,CAACO,GAAG,CAAA;AAC9B,IAAA,OAAOD,OAAO,KAAKR,SAAS,GAAGQ,OAAO,GAAG,IAAI,CAAA;AAC/C,GAAA;AACF,CAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,YAAYA,CACnBvE,IAAI,EACJ4D,GAAG,EACHY,IAAI,EACJC,MAAM,EACNC,KAAK,EACLX,KAAK,EACLY,UAAU,EACVC,SAAS,EACT;AACA;AACA;AACA;AACA;AACA,EAAA,IAAMP,OAAO,GAAGN,KAAK,CAACO,GAAG,CAAA;;AAEzB;AACA;EACA,IAAMA,GAAG,GAAGD,OAAO,KAAKR,SAAS,GAAGQ,OAAO,GAAG,IAAI,CAAA;AAElD,EAAA,IAAIQ,OAAO,CAAA;AACX,EAAa;AACX;AACA;AACA;AACA;AACA;AACAA,IAAAA,OAAO,GAAG;AACR;AACA1E,MAAAA,QAAQ,EAAE3B,kBAAkB;AAE5B;AACAwB,MAAAA,IAAI,EAAJA,IAAI;AACJ4D,MAAAA,GAAG,EAAHA,GAAG;AAEHG,MAAAA,KAAK,EAALA,KAAK;AAEL;AACAe,MAAAA,MAAM,EAAEJ,KAAAA;KACT,CAAA;IACD,IAAIJ,GAAG,KAAK,IAAI,EAAE;AAChB/C,MAAAA,MAAM,CAAC0C,cAAc,CAACY,OAAO,EAAE,KAAK,EAAE;AACpCE,QAAAA,UAAU,EAAE,KAAK;AACjBrB,QAAAA,GAAG,EAAES,sCAAAA;AACP,OAAC,CAAC,CAAA;AACJ,KAAC,MAAM;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA5C,MAAAA,MAAM,CAAC0C,cAAc,CAACY,OAAO,EAAE,KAAK,EAAE;AACpCE,QAAAA,UAAU,EAAE,KAAK;AACjBrD,QAAAA,KAAK,EAAE,IAAA;AACT,OAAC,CAAC,CAAA;AACJ,KAAA;AACF,GAaA;AAEA,EAAa;AACX;AACA;AACA;AACA;AACAmD,IAAAA,OAAO,CAACG,MAAM,GAAG,EAAE,CAAA;;AAEnB;AACA;AACA;AACA;IACAzD,MAAM,CAAC0C,cAAc,CAACY,OAAO,CAACG,MAAM,EAAE,WAAW,EAAE;AACjDd,MAAAA,YAAY,EAAE,KAAK;AACnBa,MAAAA,UAAU,EAAE,KAAK;AACjBE,MAAAA,QAAQ,EAAE,IAAI;AACdvD,MAAAA,KAAK,EAAE,CAAA;AACT,KAAC,CAAC,CAAA;AACF;AACAH,IAAAA,MAAM,CAAC0C,cAAc,CAACY,OAAO,EAAE,YAAY,EAAE;AAC3CX,MAAAA,YAAY,EAAE,KAAK;AACnBa,MAAAA,UAAU,EAAE,KAAK;AACjBE,MAAAA,QAAQ,EAAE,IAAI;AACdvD,MAAAA,KAAK,EAAE,IAAA;AACT,KAAC,CAAC,CAAA;AACFH,IAAAA,MAAM,CAAC0C,cAAc,CAACY,OAAO,EAAE,aAAa,EAAE;AAC5CX,MAAAA,YAAY,EAAE,KAAK;AACnBa,MAAAA,UAAU,EAAE,KAAK;AACjBE,MAAAA,QAAQ,EAAE,IAAI;AACdvD,MAAAA,KAAK,EAAEiD,UAAAA;AACT,KAAC,CAAC,CAAA;AACFpD,IAAAA,MAAM,CAAC0C,cAAc,CAACY,OAAO,EAAE,YAAY,EAAE;AAC3CX,MAAAA,YAAY,EAAE,KAAK;AACnBa,MAAAA,UAAU,EAAE,KAAK;AACjBE,MAAAA,QAAQ,EAAE,IAAI;AACdvD,MAAAA,KAAK,EAAEkD,SAAAA;AACT,KAAC,CAAC,CAAA;IACF,IAAIrD,MAAM,CAAC2D,MAAM,EAAE;AACjB3D,MAAAA,MAAM,CAAC2D,MAAM,CAACL,OAAO,CAACd,KAAK,CAAC,CAAA;AAC5BxC,MAAAA,MAAM,CAAC2D,MAAM,CAACL,OAAO,CAAC,CAAA;AACxB,KAAA;AACF,GAAA;AAEA,EAAA,OAAOA,OAAO,CAAA;AAChB,CAAA;;AAoEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASM,+CAA+CA,CAC7DnF,IAAI,EACJsD,MAAM,EACN8B,QAAQ,EACRX,MAAM,EACND,IAAI,EACJ;AACA,EAAa;IACX,IAAMa,gBAAgB,GAAG,KAAK,CAAA;IAC9B,IAAMC,gBAAgB,GAEpB5C,0BAAoB,CAAC6C,0BAA0B,EAAE,GAAGhH,eAAe,CAAA;AACrE,IAAA,OAAOiH,UAAU,CACfxF,IAAI,EACJsD,MAAM,EACN8B,QAAQ,EACRC,gBAAgB,EAChBZ,MAAM,EACND,IAAI,EAEDc,CAAAA,gBAAgB,GACbjE,KAAK,CAAC,uBAAuB,CAAC,GAC9B6B,sBAAsB,CAAC,EACtB,CACJoC,gBAAgB,GACbhD,UAAU,CAACC,WAAW,CAACvC,IAAI,CAAC,CAAC,GAC7BmD,qBAAqB,CAC7B,CAAC,CAAA;AACH,GAAA;AACF,CAAA;AAEO,SAASsC,8CAA8CA,CAC5DzF,IAAI,EACJsD,MAAM,EACN8B,QAAQ,EACRX,MAAM,EACND,IAAI,EACJ;AACA,EAAa;IACX,IAAMa,gBAAgB,GAAG,IAAI,CAAA;IAC7B,IAAMC,gBAAgB,GAEpB5C,0BAAoB,CAAC6C,0BAA0B,EAAE,GAAGhH,eAAe,CAAA;AACrE,IAAA,OAAOiH,UAAU,CACfxF,IAAI,EACJsD,MAAM,EACN8B,QAAQ,EACRC,gBAAgB,EAChBZ,MAAM,EACND,IAAI,EAEDc,CAAAA,gBAAgB,GACbjE,KAAK,CAAC,uBAAuB,CAAC,GAC9B6B,sBAAsB,CAAC,EACtB,CACJoC,gBAAgB,GACbhD,UAAU,CAACC,WAAW,CAACvC,IAAI,CAAC,CAAC,GAC7BmD,qBAAqB,CAC7B,CAAC,CAAA;AACH,GAAA;AACF,CAAA;AAEA,IAAMuC,qBAAqB,GAAG,EAAE,CAAA;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,QAAMA,CAAC3F,IAAI,EAAEsD,MAAM,EAAE8B,QAAQ,EAAEC,gBAAgB,EAAEZ,MAAM,EAAED,IAAI,EAAE;EAC7E,IAAMc,gBAAgB,GAEpB5C,0BAAoB,CAAC6C,0BAA0B,EAAE,GAAGhH,eAAe,CAAA;AACrE,EAAA,OAAOiH,UAAU,CACfxF,IAAI,EACJsD,MAAM,EACN8B,QAAQ,EACRC,gBAAgB,EAChBZ,MAAM,EACND,IAAI,EAEDc,CAAAA,gBAAgB,GACbjE,KAAK,CAAC,uBAAuB,CAAC,GAC9B6B,sBAAsB,CAAC,EACtB,CACJoC,gBAAgB,GACbhD,UAAU,CAACC,WAAW,CAACvC,IAAI,CAAC,CAAC,GAC7BmD,qBAAqB,CAC7B,CAAC,CAAA;AACH,CAAA;AAEA,SAASqC,UAAUA,CACjBxF,IAAI,EACJsD,MAAM,EACN8B,QAAQ,EACRC,gBAAgB,EAChBZ,MAAM,EACND,IAAI,EACJG,UAAU,EACVC,SAAS,EACT;AACA,EAAa;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAA,IAAMgB,QAAQ,GAAGtC,MAAM,CAACsC,QAAQ,CAAA;IAChC,IAAIA,QAAQ,KAAK/B,SAAS,EAAE;AAC1B,MAAA,IAAIwB,gBAAgB,EAAE;AACpB,QAAA,IAAIjD,OAAO,CAACwD,QAAQ,CAAC,EAAE;AACrB,UAAA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,QAAQ,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;AACxCE,YAAAA,iBAAiB,CAACH,QAAQ,CAACC,CAAC,CAAO,CAAC,CAAA;AACtC,WAAA;UAEA,IAAItE,MAAM,CAAC2D,MAAM,EAAE;AACjB3D,YAAAA,MAAM,CAAC2D,MAAM,CAACU,QAAQ,CAAC,CAAA;AACzB,WAAA;AACF,SAAC,MAAM;UACLvF,OAAO,CAACC,KAAK,CACX,wDAAwD,GACtD,gEAAgE,GAChE,kCACJ,CAAC,CAAA;AACH,SAAA;AACF,OAAC,MAAM;AACLyF,QAAAA,iBAAiB,CAACH,QAAc,CAAC,CAAA;AACnC,OAAA;AACF,KAAA;;AAEA;IACA,IAAItE,cAAc,CAACiC,IAAI,CAACD,MAAM,EAAE,KAAK,CAAC,EAAE;AACtC,MAAA,IAAMc,aAAa,GAAGlE,wBAAwB,CAACF,IAAI,CAAC,CAAA;AACpD,MAAA,IAAMgG,IAAI,GAAGzE,MAAM,CAACyE,IAAI,CAAC1C,MAAM,CAAC,CAAC2C,MAAM,CAAC,UAAAC,CAAC,EAAA;QAAA,OAAIA,CAAC,KAAK,KAAK,CAAA;OAAC,CAAA,CAAA;AACzD,MAAA,IAAMC,aAAa,GACjBH,IAAI,CAACF,MAAM,GAAG,CAAC,GACX,iBAAiB,GAAGE,IAAI,CAACI,IAAI,CAAC,SAAS,CAAC,GAAG,QAAQ,GACnD,gBAAgB,CAAA;AACtB,MAAA,IAAI,CAACV,qBAAqB,CAACtB,aAAa,GAAG+B,aAAa,CAAC,EAAE;AACzD,QAAA,IAAME,YAAY,GAChBL,IAAI,CAACF,MAAM,GAAG,CAAC,GAAG,GAAG,GAAGE,IAAI,CAACI,IAAI,CAAC,SAAS,CAAC,GAAG,QAAQ,GAAG,IAAI,CAAA;QAChE/F,OAAO,CAACC,KAAK,CACX,oEAAoE,GAClE,qBAAqB,GACrB,uBAAuB,GACvB,mEAAmE,GACnE,qBAAqB,GACrB,mCAAmC,EACrC6F,aAAa,EACb/B,aAAa,EACbiC,YAAY,EACZjC,aACF,CAAC,CAAA;AACDsB,QAAAA,qBAAqB,CAACtB,aAAa,GAAG+B,aAAa,CAAC,GAAG,IAAI,CAAA;AAC7D,OAAA;AACF,KAAA;IAEA,IAAIvC,GAAG,GAAG,IAAI,CAAA;;AAEd;AACA;AACA;AACA;AACA;AACA;IACA,IAAIwB,QAAQ,KAAKvB,SAAS,EAAE;AAC1B,MAAa;QACX5B,sBAAsB,CAACmD,QAAQ,CAAC,CAAA;AAClC,OAAA;MACAxB,GAAG,GAAG,EAAE,GAAGwB,QAAQ,CAAA;AACrB,KAAA;AAEA,IAAA,IAAI/B,WAAW,CAACC,MAAM,CAAC,EAAE;AACvB,MAAa;AACXrB,QAAAA,sBAAsB,CAACqB,MAAM,CAACM,GAAG,CAAC,CAAA;AACpC,OAAA;AACAA,MAAAA,GAAG,GAAG,EAAE,GAAGN,MAAM,CAACM,GAAG,CAAA;AACvB,KAAA;AAEA,IAAA,IAAIG,KAAK,CAAA;AACT,IAAA,IAAI,EAAE,KAAK,IAAIT,MAAM,CAAC,EAAE;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAS,MAAAA,KAAK,GAAGT,MAAM,CAAA;AAChB,KAAC,MAAM;AACL;AACA;AACA;MACAS,KAAK,GAAG,EAAE,CAAA;AACV,MAAA,KAAK,IAAMuC,QAAQ,IAAIhD,MAAM,EAAE;AAC7B;QACA,IAAIgD,QAAQ,KAAK,KAAK,EAAE;AACtBvC,UAAAA,KAAK,CAACuC,QAAQ,CAAC,GAAGhD,MAAM,CAACgD,QAAQ,CAAC,CAAA;AACpC,SAAA;AACF,OAAA;AACF,KAAA;AAEA,IAAA,IAAI1C,GAAG,EAAE;AACP,MAAA,IAAMhE,WAAW,GACf,OAAOI,IAAI,KAAK,UAAU,GACtBA,IAAI,CAACJ,WAAW,IAAII,IAAI,CAACF,IAAI,IAAI,SAAS,GAC1CE,IAAI,CAAA;AACV8D,MAAAA,0BAA0B,CAACC,KAAK,EAAEnE,WAAW,CAAC,CAAA;AAChD,KAAA;AAEA,IAAA,OAAO2E,YAAY,CACjBvE,IAAI,EACJ4D,GAAG,EACHY,IAAI,EACJC,MAAM,EACNjC,QAAQ,EAAE,EACVuB,KAAK,EACLY,UAAU,EACVC,SACF,CAAC,CAAA;AACH,GAAA;AACF,CAAA;;AAkPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmB,iBAAiBA,CAACQ,IAAI,EAAEC,UAAU,EAAE;AAC3C,EAAa;AACX;AACA;AACA;AACA,IAAA,IAAIC,cAAc,CAACF,IAAI,CAAC,EAAE;MACxB,IAAIA,IAAI,CAACvB,MAAM,EAAE;AACfuB,QAAAA,IAAI,CAACvB,MAAM,CAAC0B,SAAS,GAAG,CAAC,CAAA;AAC3B,OAAA;AACF,KAAA;AACF,GAAA;AACF,CAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASD,cAAcA,CAACE,MAAM,EAAE;AACrC,EAAA,OACE,OAAOA,MAAM,KAAK,QAAQ,IAC1BA,MAAM,KAAK,IAAI,IACfA,MAAM,CAACxG,QAAQ,KAAK3B,kBAAkB,CAAA;AAE1C;;ACj2BA,IAAMoI,GAAG,GACLzB,+CAA+C,EACxC;AACX;AACA;AACA,IAAM0B,IAAI,GACNpB,8CAA8C,EACvC;AAEX,IAAME,MAAM,GAAkBmB,QAAO;;;;;;;"}
\ No newline at end of file
diff --git a/cjs/react-jsx-dev-runtime.react-server.production.js b/cjs/react-jsx-dev-runtime.react-server.production.js
index 0664121996a97e23e0e3585e7e2404200f43c2a5..f132ed8358f9a9c9a101dcc9f8c7943b5e84746a 100644
--- a/cjs/react-jsx-dev-runtime.react-server.production.js
+++ b/cjs/react-jsx-dev-runtime.react-server.production.js
@@ -1,40 +1,126 @@
+'use strict';
+
+var React = require('react');
+
+const REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+
+const ReactSharedInternalsServer =
+// $FlowFixMe: It's defined in the one we resolve to.
+React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+if (!ReactSharedInternalsServer) {
+  throw new Error('The "react" package in this environment is not configured correctly. ' + 'The "react-server" condition must be enabled in any environment that ' + 'runs React Server Components.');
+}
+
+function getOwner() {
+  return null;
+}
+function hasValidKey(config) {
+  return config.key !== undefined;
+}
+
 /**
- * @license React
- * react-jsx-dev-runtime.react-server.production.js
+ * Factory method to create a new React element. This no longer adheres to
+ * the class pattern, so do not use new to call it. Also, instanceof check
+ * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check
+ * if something is a React Element.
  *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
+ * @param {*} type
+ * @param {*} props
+ * @param {*} key
+ * @param {string|object} ref
+ * @param {*} owner
+ * @param {*} self A *temporary* helper to detect places where `this` is
+ * different from the `owner` when React.createElement is called, so that we
+ * can warn. We want to get rid of owner and replace string `ref`s with arrow
+ * functions, and as long as `this` and owner are the same, there will be no
+ * change in behavior.
+ * @param {*} source An annotation object (added by a transpiler or otherwise)
+ * indicating filename, line number, and/or other information.
+ * @internal
  */
+function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
+  // Ignore whatever was passed as the ref argument and treat `props.ref` as
+  // the source of truth. The only thing we use this for is `element.ref`,
+  // which will log a deprecation warning on access. In the next release, we
+  // can remove `element.ref` as well as the `ref` argument.
+  const refProp = props.ref;
+
+  // An undefined `element.ref` is coerced to `null` for
+  // backwards compatibility.
+  const ref = refProp !== undefined ? refProp : null;
+  let element;
+  {
+    // In prod, `ref` is a regular property and _owner doesn't exist.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      // Built-in properties that belong on the element
+      type,
+      key,
+      ref,
+      props
+    };
+  }
+  return element;
+}
 
-"use strict";
-var React = require("react"),
-  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
-if (!React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE)
-  throw Error(
-    'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
-  );
+/**
+ * https://github.com/reactjs/rfcs/pull/107
+ * @param {*} type
+ * @param {object} props
+ * @param {string} key
+ */
 function jsxProd(type, config, maybeKey) {
-  var key = null;
-  void 0 !== maybeKey && (key = "" + maybeKey);
-  void 0 !== config.key && (key = "" + config.key);
-  if ("key" in config) {
-    maybeKey = {};
-    for (var propName in config)
-      "key" !== propName && (maybeKey[propName] = config[propName]);
-  } else maybeKey = config;
-  config = maybeKey.ref;
-  return {
-    $$typeof: REACT_ELEMENT_TYPE,
-    type: type,
-    key: key,
-    ref: void 0 !== config ? config : null,
-    props: maybeKey
-  };
+  let key = null;
+
+  // Currently, key can be spread in as a prop. This causes a potential
+  // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
+  // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
+  // but as an intermediary step, we will use jsxDEV for everything except
+  // <div {...props} key="Hi" />, because we aren't currently able to tell if
+  // key is explicitly declared to be undefined or not.
+  if (maybeKey !== undefined) {
+    key = '' + maybeKey;
+  }
+  if (hasValidKey(config)) {
+    key = '' + config.key;
+  }
+  let props;
+  if (!('key' in config)) {
+    // If key was not spread in, we can reuse the original props object. This
+    // only works for `jsx`, not `createElement`, because `jsx` is a compiler
+    // target and the compiler always passes a new object. For `createElement`,
+    // we can't assume a new object is passed every time because it can be
+    // called manually.
+    //
+    // Spreading key is a warning in dev. In a future release, we will not
+    // remove a spread key from the props object. (But we'll still warn.) We'll
+    // always pass the object straight through.
+    props = config;
+  } else {
+    // We need to remove reserved props (key, prop, ref). Create a fresh props
+    // object and copy over all the non-reserved props. We don't use `delete`
+    // because in V8 it will deopt the object to dictionary mode.
+    props = {};
+    for (const propName in config) {
+      // Skip over reserved prop names
+      if (propName !== 'key') {
+        props[propName] = config[propName];
+      }
+    }
+  }
+  return ReactElement(type, key, undefined, undefined, getOwner(), props);
 }
+
+const jsx = jsxProd;
+// we may want to special case jsxs internally to take advantage of static children.
+// for now we can ship identical prod functions
+const jsxs = jsxProd;
+const jsxDEV = undefined;
+
 exports.Fragment = REACT_FRAGMENT_TYPE;
-exports.jsx = jsxProd;
-exports.jsxDEV = void 0;
-exports.jsxs = jsxProd;
+exports.jsx = jsx;
+exports.jsxDEV = jsxDEV;
+exports.jsxs = jsxs;
+//# sourceMappingURL=react-jsx-dev-runtime.react-server.production.js.map
diff --git a/cjs/react-jsx-dev-runtime.react-server.production.js.map b/cjs/react-jsx-dev-runtime.react-server.production.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..16e91abfd007398fb263e314469c05671a82053f
--- /dev/null
+++ b/cjs/react-jsx-dev-runtime.react-server.production.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react-jsx-dev-runtime.react-server.production.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/react-server/src/ReactSharedInternalsServer.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXElement.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXServer.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {SharedStateServer} from 'react/src/ReactSharedInternalsServer';\n\nimport * as React from 'react';\n\nconst ReactSharedInternalsServer: SharedStateServer =\n  // $FlowFixMe: It's defined in the one we resolve to.\n  React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n\nif (!ReactSharedInternalsServer) {\n  throw new Error(\n    'The \"react\" package in this environment is not configured correctly. ' +\n      'The \"react-server\" condition must be enabled in any environment that ' +\n      'runs React Server Components.',\n  );\n}\n\nexport default ReactSharedInternalsServer;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport assign from 'shared/assign';\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\nimport isArray from 'shared/isArray';\nimport {ownerStackLimit} from 'shared/ReactFeatureFlags';\n\nconst createTask =\n  // eslint-disable-next-line react-internal/no-production-logging\n  __DEV__ && console.createTask\n    ? // eslint-disable-next-line react-internal/no-production-logging\n      console.createTask\n    : () => null;\n\nfunction getTaskName(type) {\n  if (type === REACT_FRAGMENT_TYPE) {\n    return '<>';\n  }\n  if (\n    typeof type === 'object' &&\n    type !== null &&\n    type.$$typeof === REACT_LAZY_TYPE\n  ) {\n    // We don't want to eagerly initialize the initializer in DEV mode so we can't\n    // call it to extract the type so we don't know the type of this component.\n    return '<...>';\n  }\n  try {\n    const name = getComponentNameFromType(type);\n    return name ? '<' + name + '>' : '<...>';\n  } catch (x) {\n    return '<...>';\n  }\n}\n\nfunction getOwner() {\n  if (__DEV__) {\n    const dispatcher = ReactSharedInternals.A;\n    if (dispatcher === null) {\n      return null;\n    }\n    return dispatcher.getOwner();\n  }\n  return null;\n}\n\n/** @noinline */\nfunction UnknownOwner() {\n  /** @noinline */\n  return (() => Error('react-stack-top-frame'))();\n}\nconst createFakeCallStack = {\n  react_stack_bottom_frame: function (callStackForError) {\n    return callStackForError();\n  },\n};\n\nlet specialPropKeyWarningShown;\nlet didWarnAboutElementRef;\nlet didWarnAboutOldJSXRuntime;\nlet unknownOwnerDebugStack;\nlet unknownOwnerDebugTask;\n\nif (__DEV__) {\n  didWarnAboutElementRef = {};\n\n  // We use this technique to trick minifiers to preserve the function name.\n  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(\n    createFakeCallStack,\n    UnknownOwner,\n  )();\n  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://react.dev/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction elementRefGetterWithDeprecationWarning() {\n  if (__DEV__) {\n    const componentName = getComponentNameFromType(this.type);\n    if (!didWarnAboutElementRef[componentName]) {\n      didWarnAboutElementRef[componentName] = true;\n      console.error(\n        'Accessing element.ref was removed in React 19. ref is now a ' +\n          'regular prop. It will be removed from the JSX Element ' +\n          'type in a future release.',\n      );\n    }\n\n    // An undefined `element.ref` is coerced to `null` for\n    // backwards compatibility.\n    const refProp = this.props.ref;\n    return refProp !== undefined ? refProp : null;\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nfunction ReactElement(\n  type,\n  key,\n  self,\n  source,\n  owner,\n  props,\n  debugStack,\n  debugTask,\n) {\n  // Ignore whatever was passed as the ref argument and treat `props.ref` as\n  // the source of truth. The only thing we use this for is `element.ref`,\n  // which will log a deprecation warning on access. In the next release, we\n  // can remove `element.ref` as well as the `ref` argument.\n  const refProp = props.ref;\n\n  // An undefined `element.ref` is coerced to `null` for\n  // backwards compatibility.\n  const ref = refProp !== undefined ? refProp : null;\n\n  let element;\n  if (__DEV__) {\n    // In dev, make `ref` a non-enumerable property with a warning. It's non-\n    // enumerable so that test matchers and serializers don't access it and\n    // trigger the warning.\n    //\n    // `ref` will be removed from the element completely in a future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n\n      props,\n\n      // Record the component responsible for creating this element.\n      _owner: owner,\n    };\n    if (ref !== null) {\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        get: elementRefGetterWithDeprecationWarning,\n      });\n    } else {\n      // Don't warn on access if a ref is not given. This reduces false\n      // positives in cases where a test serializer uses\n      // getOwnPropertyDescriptors to compare objects, like Jest does, which is\n      // a problem because it bypasses non-enumerability.\n      //\n      // So unfortunately this will trigger a false positive warning in Jest\n      // when the diff is printed:\n      //\n      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);\n      //\n      // A bit sketchy, but this is what we've done for the `props.key` and\n      // `props.ref` accessors for years, which implies it will be good enough\n      // for `element.ref`, too. Let's see if anyone complains.\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        value: null,\n      });\n    }\n  } else {\n    // In prod, `ref` is a regular property and _owner doesn't exist.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n      ref,\n\n      props,\n    };\n  }\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: 0,\n    });\n    // debugInfo contains Server Component debug information.\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null,\n    });\n    Object.defineProperty(element, '_debugStack', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugStack,\n    });\n    Object.defineProperty(element, '_debugTask', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugTask,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxProd(type, config, maybeKey) {\n  let key = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  let props;\n  if (!('key' in config)) {\n    // If key was not spread in, we can reuse the original props object. This\n    // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n    // target and the compiler always passes a new object. For `createElement`,\n    // we can't assume a new object is passed every time because it can be\n    // called manually.\n    //\n    // Spreading key is a warning in dev. In a future release, we will not\n    // remove a spread key from the props object. (But we'll still warn.) We'll\n    // always pass the object straight through.\n    props = config;\n  } else {\n    // We need to remove reserved props (key, prop, ref). Create a fresh props\n    // object and copy over all the non-reserved props. We don't use `delete`\n    // because in V8 it will deopt the object to dictionary mode.\n    props = {};\n    for (const propName in config) {\n      // Skip over reserved prop names\n      if (propName !== 'key') {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    undefined,\n    undefined,\n  );\n}\n\n// While `jsxDEV` should never be called when running in production, we do\n// support `jsx` and `jsxs` when running in development. This supports the case\n// where a third-party dependency ships code that was compiled for production;\n// we want to still provide warnings in development.\n//\n// So these functions are the _dev_ implementations of the _production_\n// API signatures.\n//\n// Since these functions are dev-only, it's ok to add an indirection here. They\n// only exist to provide different versions of `isStaticChildren`. (We shouldn't\n// use this pattern for the prod versions, though, because it will add an call\n// frame.)\nexport function jsxProdSignatureRunningInDevWithDynamicChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = false;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nexport function jsxProdSignatureRunningInDevWithStaticChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = true;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nconst didWarnAboutKeySpread = {};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return jsxDEVImpl(\n    type,\n    config,\n    maybeKey,\n    isStaticChildren,\n    source,\n    self,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nfunction jsxDEVImpl(\n  type,\n  config,\n  maybeKey,\n  isStaticChildren,\n  source,\n  self,\n  debugStack,\n  debugTask,\n) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    // With owner stacks, we no longer need the type here so this comment is\n    // no longer true. Which is why we can run this even for invalid types.\n    const children = config.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          console.error(\n            'React.jsx: Static children should always be an array. ' +\n              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n              'Use the Babel transform instead.',\n          );\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n\n    // Warn about key spread regardless of whether the type is valid.\n    if (hasOwnProperty.call(config, 'key')) {\n      const componentName = getComponentNameFromType(type);\n      const keys = Object.keys(config).filter(k => k !== 'key');\n      const beforeExample =\n        keys.length > 0\n          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'\n          : '{key: someKey}';\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        const afterExample =\n          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n        console.error(\n          'A props object containing a \"key\" prop is being spread into JSX:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s {...props} />\\n' +\n            'React keys must be passed directly to JSX without using spread:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s key={someKey} {...props} />',\n          beforeExample,\n          componentName,\n          afterExample,\n          componentName,\n        );\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    let key = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    let props;\n    if (!('key' in config)) {\n      // If key was not spread in, we can reuse the original props object. This\n      // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n      // target and the compiler always passes a new object. For `createElement`,\n      // we can't assume a new object is passed every time because it can be\n      // called manually.\n      //\n      // Spreading key is a warning in dev. In a future release, we will not\n      // remove a spread key from the props object. (But we'll still warn.) We'll\n      // always pass the object straight through.\n      props = config;\n    } else {\n      // We need to remove reserved props (key, prop, ref). Create a fresh props\n      // object and copy over all the non-reserved props. We don't use `delete`\n      // because in V8 it will deopt the object to dictionary mode.\n      props = {};\n      for (const propName in config) {\n        // Skip over reserved prop names\n        if (propName !== 'key') {\n          props[propName] = config[propName];\n        }\n      }\n    }\n\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    return ReactElement(\n      type,\n      key,\n      self,\n      source,\n      getOwner(),\n      props,\n      debugStack,\n      debugTask,\n    );\n  }\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n  }\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const clonedElement = ReactElement(\n    oldElement.type,\n    newKey,\n    undefined,\n    undefined,\n    !__DEV__ ? undefined : oldElement._owner,\n    oldElement.props,\n    __DEV__ && oldElement._debugStack,\n    __DEV__ && oldElement._debugTask,\n  );\n  if (__DEV__) {\n    // The cloned element should inherit the original element's key validation.\n    if (oldElement._store) {\n      clonedElement._store.validated = oldElement._store.validated;\n    }\n  }\n  return clonedElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = !__DEV__ ? undefined : element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      owner = __DEV__ ? getOwner() : undefined;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // ...and maybe these, too, though we currently rely on them for\n        // warnings and debug information in dev. Need to decide if we're OK\n        // with dropping them. In the jsx() runtime it's not an issue because\n        // the data gets passed as separate arguments instead of props, but\n        // it would be nice to stop relying on them entirely so we can drop\n        // them from the internal Fiber field.\n        propName !== '__self' &&\n        propName !== '__source' &&\n        // Undefined `ref` is ignored by cloneElement. We treat it the same as\n        // if the property were missing. This is mostly for\n        // backwards compatibility.\n        !(propName === 'ref' && config.ref === undefined)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  const clonedElement = ReactElement(\n    element.type,\n    key,\n    undefined,\n    undefined,\n    owner,\n    props,\n    __DEV__ && element._debugStack,\n    __DEV__ && element._debugTask,\n  );\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], clonedElement.type);\n  }\n\n  return clonedElement;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    // With owner stacks is, no warnings happens. All we do is\n    // mark elements as being in a valid static child position so they\n    // don't need keys.\n    if (isValidElement(node)) {\n      if (node._store) {\n        node._store.validated = 1;\n      }\n    }\n  }\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport {REACT_FRAGMENT_TYPE} from 'shared/ReactSymbols';\nimport {\n  jsxProd,\n  jsxProdSignatureRunningInDevWithDynamicChildren,\n  jsxProdSignatureRunningInDevWithStaticChildren,\n  jsxDEV as _jsxDEV,\n} from './ReactJSXElement';\n\nconst jsx: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithDynamicChildren\n  : jsxProd;\n// we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\nconst jsxs: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithStaticChildren\n  : jsxProd;\n\nconst jsxDEV: any = __DEV__ ? _jsxDEV : undefined;\n\nexport {REACT_FRAGMENT_TYPE as Fragment, jsx, jsxs, jsxDEV};\n"],"names":["REACT_ELEMENT_TYPE","Symbol","for","REACT_FRAGMENT_TYPE","ReactSharedInternalsServer","React","__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","Error","getOwner","hasValidKey","config","key","undefined","ReactElement","type","self","source","owner","props","debugStack","debugTask","refProp","ref","element","$$typeof","jsxProd","maybeKey","propName","jsx","jsxs","jsxDEV"],"mappings":";;;;AAiBO,MAAMA,kBAAkB,GAC3BC,MAAM,CAACC,GAAG,CAAC,4BAA4B,CAAC,CACf,CAAA;AAEtB,MAAMC,mBAAmB,GAAWF,MAAM,CAACC,GAAG,CAAC,gBAAgB;;ACRtE,MAAME,0BAA0B;AAC9B;AACAC,KAAK,CAACC,+DAA+D,CAAA;AAEvE,IAAI,CAACF,0BAA0B,EAAE;EAC/B,MAAM,IAAIG,KAAK,CACb,uEAAuE,GACrE,uEAAuE,GACvE,+BACJ,CAAC,CAAA;AACH;;ACyBA,SAASC,QAAQA,GAAG;AAQlB,EAAA,OAAO,IAAI,CAAA;AACb,CAAA;AA0CA,SAASC,WAAWA,CAACC,MAAM,EAAE;AAS3B,EAAA,OAAOA,MAAM,CAACC,GAAG,KAAKC,SAAS,CAAA;AACjC,CAAA;;AA2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CACnBC,IAAI,EACJH,GAAG,EACHI,IAAI,EACJC,MAAM,EACNC,KAAK,EACLC,KAAK,EACLC,UAAU,EACVC,SAAS,EACT;AACA;AACA;AACA;AACA;AACA,EAAA,MAAMC,OAAO,GAAGH,KAAK,CAACI,GAAG,CAAA;;AAEzB;AACA;EACA,MAAMA,GAAG,GAAGD,OAAO,KAAKT,SAAS,GAAGS,OAAO,GAAG,IAAI,CAAA;AAElD,EAAA,IAAIE,OAAO,CAAA;AACX,EA2CO;AACL;AACAA,IAAAA,OAAO,GAAG;AACR;AACAC,MAAAA,QAAQ,EAAExB,kBAAkB;AAE5B;MACAc,IAAI;MACJH,GAAG;MACHW,GAAG;AAEHJ,MAAAA,KAAAA;KACD,CAAA;AACH,GAAA;AA4CA,EAAA,OAAOK,OAAO,CAAA;AAChB,CAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASE,OAAOA,CAACX,IAAI,EAAEJ,MAAM,EAAEgB,QAAQ,EAAE;EAC9C,IAAIf,GAAG,GAAG,IAAI,CAAA;;AAEd;AACA;AACA;AACA;AACA;AACA;EACA,IAAIe,QAAQ,KAAKd,SAAS,EAAE;IAI1BD,GAAG,GAAG,EAAE,GAAGe,QAAQ,CAAA;AACrB,GAAA;AAEA,EAAA,IAAIjB,WAAW,CAACC,MAAM,CAAC,EAAE;AAIvBC,IAAAA,GAAG,GAAG,EAAE,GAAGD,MAAM,CAACC,GAAG,CAAA;AACvB,GAAA;AAEA,EAAA,IAAIO,KAAK,CAAA;AACT,EAAA,IAAI,EAAE,KAAK,IAAIR,MAAM,CAAC,EAAE;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAQ,IAAAA,KAAK,GAAGR,MAAM,CAAA;AAChB,GAAC,MAAM;AACL;AACA;AACA;IACAQ,KAAK,GAAG,EAAE,CAAA;AACV,IAAA,KAAK,MAAMS,QAAQ,IAAIjB,MAAM,EAAE;AAC7B;MACA,IAAIiB,QAAQ,KAAK,KAAK,EAAE;AACtBT,QAAAA,KAAK,CAACS,QAAQ,CAAC,GAAGjB,MAAM,CAACiB,QAAQ,CAAC,CAAA;AACpC,OAAA;AACF,KAAA;AACF,GAAA;AAEA,EAAA,OAAOd,YAAY,CACjBC,IAAI,EACJH,GAAG,EACHC,SAAS,EACTA,SAAS,EACTJ,QAAQ,EAAE,EACVU,KAGF,CAAC,CAAA;AACH;;ACxVA,MAAMU,GAAG,GAELH,QAAO;AACX;AACA;AACA,MAAMI,IAAI,GAENJ,QAAO;AAEX,MAAMK,MAAM,GAA4BlB;;;;;;;"}
\ No newline at end of file
diff --git a/cjs/react-jsx-runtime.development.js b/cjs/react-jsx-runtime.development.js
index 2a821e168fbd14bdb5b2c446337a8a383d4c2f63..54ef52530c022eb3065207bcdd407303eec23b8f 100644
--- a/cjs/react-jsx-runtime.development.js
+++ b/cjs/react-jsx-runtime.development.js
@@ -1,358 +1,573 @@
-/**
- * @license React
- * react-jsx-runtime.development.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
+'use strict';
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
-  (function () {
-    function getComponentNameFromType(type) {
-      if (null == type) return null;
-      if ("function" === typeof type)
-        return type.$$typeof === REACT_CLIENT_REFERENCE
-          ? null
-          : type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
-      switch (type) {
-        case REACT_FRAGMENT_TYPE:
-          return "Fragment";
-        case REACT_PROFILER_TYPE:
-          return "Profiler";
-        case REACT_STRICT_MODE_TYPE:
-          return "StrictMode";
-        case REACT_SUSPENSE_TYPE:
-          return "Suspense";
-        case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
-        case REACT_ACTIVITY_TYPE:
-          return "Activity";
-      }
-      if ("object" === typeof type)
-        switch (
-          ("number" === typeof type.tag &&
-            console.error(
-              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
-            ),
-          type.$$typeof)
-        ) {
-          case REACT_PORTAL_TYPE:
-            return "Portal";
-          case REACT_CONTEXT_TYPE:
-            return (type.displayName || "Context") + ".Provider";
-          case REACT_CONSUMER_TYPE:
-            return (type._context.displayName || "Context") + ".Consumer";
-          case REACT_FORWARD_REF_TYPE:
-            var innerType = type.render;
-            type = type.displayName;
-            type ||
-              ((type = innerType.displayName || innerType.name || ""),
-              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
-            return type;
-          case REACT_MEMO_TYPE:
-            return (
-              (innerType = type.displayName || null),
-              null !== innerType
-                ? innerType
-                : getComponentNameFromType(type.type) || "Memo"
-            );
-          case REACT_LAZY_TYPE:
-            innerType = type._payload;
-            type = type._init;
-            try {
-              return getComponentNameFromType(type(innerType));
-            } catch (x) {}
-        }
+var React = require('react');
+
+// -----------------------------------------------------------------------------
+// Land or remove (zero effort)
+//
+// Flags that can likely be deleted or landed without consequences
+// -----------------------------------------------------------------------------
+
+var ownerStackLimit = 1e4;
+
+var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+var REACT_PORTAL_TYPE = Symbol.for('react.portal');
+var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
+var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
+var REACT_CONSUMER_TYPE = Symbol.for('react.consumer');
+var REACT_CONTEXT_TYPE = Symbol.for('react.context');
+var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
+var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
+var REACT_MEMO_TYPE = Symbol.for('react.memo');
+var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+var REACT_ACTIVITY_TYPE = Symbol.for('react.activity');
+var REACT_VIEW_TRANSITION_TYPE = Symbol.for('react.view_transition');
+
+// Keep in sync with react-reconciler/getComponentNameFromFiber
+function getWrappedName(outerType, innerType, wrapperName) {
+  var displayName = outerType.displayName;
+  if (displayName) {
+    return displayName;
+  }
+  var functionName = innerType.displayName || innerType.name || '';
+  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
+}
+
+// Keep in sync with react-reconciler/getComponentNameFromFiber
+function getContextName(type) {
+  return type.displayName || 'Context';
+}
+var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
+
+// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
+function getComponentNameFromType(type) {
+  if (type == null) {
+    // Host root, text node or just invalid type.
+    return null;
+  }
+  if (typeof type === 'function') {
+    if (type.$$typeof === REACT_CLIENT_REFERENCE) {
+      // TODO: Create a convention for naming client references with debug info.
       return null;
     }
-    function testStringCoercion(value) {
-      return "" + value;
-    }
-    function checkKeyStringCoercion(value) {
-      try {
-        testStringCoercion(value);
-        var JSCompiler_inline_result = !1;
-      } catch (e) {
-        JSCompiler_inline_result = !0;
+    return type.displayName || type.name || null;
+  }
+  if (typeof type === 'string') {
+    return type;
+  }
+  switch (type) {
+    case REACT_FRAGMENT_TYPE:
+      return 'Fragment';
+    case REACT_PROFILER_TYPE:
+      return 'Profiler';
+    case REACT_STRICT_MODE_TYPE:
+      return 'StrictMode';
+    case REACT_SUSPENSE_TYPE:
+      return 'Suspense';
+    case REACT_SUSPENSE_LIST_TYPE:
+      return 'SuspenseList';
+    case REACT_ACTIVITY_TYPE:
+      return 'Activity';
+    case REACT_VIEW_TRANSITION_TYPE:
+      {
+        return 'ViewTransition';
       }
-      if (JSCompiler_inline_result) {
-        JSCompiler_inline_result = console;
-        var JSCompiler_temp_const = JSCompiler_inline_result.error;
-        var JSCompiler_inline_result$jscomp$0 =
-          ("function" === typeof Symbol &&
-            Symbol.toStringTag &&
-            value[Symbol.toStringTag]) ||
-          value.constructor.name ||
-          "Object";
-        JSCompiler_temp_const.call(
-          JSCompiler_inline_result,
-          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
-          JSCompiler_inline_result$jscomp$0
-        );
-        return testStringCoercion(value);
+  }
+  if (typeof type === 'object') {
+    {
+      if (typeof type.tag === 'number') {
+        console.error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
       }
     }
-    function getTaskName(type) {
-      if (type === REACT_FRAGMENT_TYPE) return "<>";
-      if (
-        "object" === typeof type &&
-        null !== type &&
-        type.$$typeof === REACT_LAZY_TYPE
-      )
-        return "<...>";
-      try {
-        var name = getComponentNameFromType(type);
-        return name ? "<" + name + ">" : "<...>";
-      } catch (x) {
-        return "<...>";
-      }
+    switch (type.$$typeof) {
+      case REACT_PORTAL_TYPE:
+        return 'Portal';
+      case REACT_CONTEXT_TYPE:
+        var context = type;
+        return getContextName(context);
+      case REACT_CONSUMER_TYPE:
+        var consumer = type;
+        return getContextName(consumer._context) + '.Consumer';
+      case REACT_FORWARD_REF_TYPE:
+        return getWrappedName(type, type.render, 'ForwardRef');
+      case REACT_MEMO_TYPE:
+        var outerName = type.displayName || null;
+        if (outerName !== null) {
+          return outerName;
+        }
+        return getComponentNameFromType(type.type) || 'Memo';
+      case REACT_LAZY_TYPE:
+        {
+          var lazyComponent = type;
+          var payload = lazyComponent._payload;
+          var init = lazyComponent._init;
+          try {
+            return getComponentNameFromType(init(payload));
+          } catch (x) {
+            return null;
+          }
+        }
+    }
+  }
+  return null;
+}
+
+var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+
+// $FlowFixMe[method-unbinding]
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+
+/*
+ * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol
+ * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
+ *
+ * The functions in this module will throw an easier-to-understand,
+ * easier-to-debug exception with a clear errors message message explaining the
+ * problem. (Instead of a confusing exception thrown inside the implementation
+ * of the `value` object).
+ */
+
+// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
+function typeName(value) {
+  {
+    // toStringTag is needed for namespaced types like Temporal.Instant
+    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
+    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
+    // $FlowFixMe[incompatible-return]
+    return type;
+  }
+}
+
+// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
+function willCoercionThrow(value) {
+  {
+    try {
+      testStringCoercion(value);
+      return false;
+    } catch (e) {
+      return true;
     }
-    function getOwner() {
-      var dispatcher = ReactSharedInternals.A;
-      return null === dispatcher ? null : dispatcher.getOwner();
+  }
+}
+
+/** @noinline */
+function testStringCoercion(value) {
+  // If you ended up here by following an exception call stack, here's what's
+  // happened: you supplied an object or symbol value to React (as a prop, key,
+  // DOM attribute, CSS property, string ref, etc.) and when React tried to
+  // coerce it to a string using `'' + value`, an exception was thrown.
+  //
+  // The most common types that will cause this exception are `Symbol` instances
+  // and Temporal objects like `Temporal.Instant`. But any object that has a
+  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
+  // exception. (Library authors do this to prevent users from using built-in
+  // numeric operators like `+` or comparison operators like `>=` because custom
+  // methods are needed to perform accurate arithmetic or comparison.)
+  //
+  // To fix the problem, coerce this object or symbol value to a string before
+  // passing it to React. The most reliable way is usually `String(value)`.
+  //
+  // To find which value is throwing, check the browser or debugger console.
+  // Before this exception was thrown, there should be `console.error` output
+  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
+  // problem and how that type was used: key, atrribute, input value prop, etc.
+  // In most cases, this console output also shows the component and its
+  // ancestor components where the exception happened.
+  //
+  // eslint-disable-next-line react-internal/safe-string-coercion
+  return '' + value;
+}
+function checkKeyStringCoercion(value) {
+  {
+    if (willCoercionThrow(value)) {
+      console.error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));
+      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
     }
-    function UnknownOwner() {
-      return Error("react-stack-top-frame");
+  }
+}
+
+var isArrayImpl = Array.isArray;
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+var createTask =
+// eslint-disable-next-line react-internal/no-production-logging
+console.createTask ?
+// eslint-disable-next-line react-internal/no-production-logging
+console.createTask : function () {
+  return null;
+};
+function getTaskName(type) {
+  if (type === REACT_FRAGMENT_TYPE) {
+    return '<>';
+  }
+  if (typeof type === 'object' && type !== null && type.$$typeof === REACT_LAZY_TYPE) {
+    // We don't want to eagerly initialize the initializer in DEV mode so we can't
+    // call it to extract the type so we don't know the type of this component.
+    return '<...>';
+  }
+  try {
+    var name = getComponentNameFromType(type);
+    return name ? '<' + name + '>' : '<...>';
+  } catch (x) {
+    return '<...>';
+  }
+}
+function getOwner() {
+  {
+    var dispatcher = ReactSharedInternals.A;
+    if (dispatcher === null) {
+      return null;
     }
-    function hasValidKey(config) {
-      if (hasOwnProperty.call(config, "key")) {
-        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
-        if (getter && getter.isReactWarning) return !1;
+    return dispatcher.getOwner();
+  }
+}
+
+/** @noinline */
+function UnknownOwner() {
+  /** @noinline */
+  return function () {
+    return Error('react-stack-top-frame');
+  }();
+}
+var createFakeCallStack = {
+  react_stack_bottom_frame: function (callStackForError) {
+    return callStackForError();
+  }
+};
+var specialPropKeyWarningShown;
+var didWarnAboutElementRef;
+var unknownOwnerDebugStack;
+var unknownOwnerDebugTask;
+{
+  didWarnAboutElementRef = {};
+
+  // We use this technique to trick minifiers to preserve the function name.
+  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(createFakeCallStack, UnknownOwner)();
+  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
+}
+function hasValidKey(config) {
+  {
+    if (hasOwnProperty.call(config, 'key')) {
+      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
+      if (getter && getter.isReactWarning) {
+        return false;
       }
-      return void 0 !== config.key;
     }
-    function defineKeyPropWarningGetter(props, displayName) {
-      function warnAboutAccessingKey() {
-        specialPropKeyWarningShown ||
-          ((specialPropKeyWarningShown = !0),
-          console.error(
-            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
-            displayName
-          ));
+  }
+  return config.key !== undefined;
+}
+function defineKeyPropWarningGetter(props, displayName) {
+  {
+    var warnAboutAccessingKey = function () {
+      if (!specialPropKeyWarningShown) {
+        specialPropKeyWarningShown = true;
+        console.error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://react.dev/link/special-props)', displayName);
       }
-      warnAboutAccessingKey.isReactWarning = !0;
-      Object.defineProperty(props, "key", {
-        get: warnAboutAccessingKey,
-        configurable: !0
-      });
-    }
-    function elementRefGetterWithDeprecationWarning() {
-      var componentName = getComponentNameFromType(this.type);
-      didWarnAboutElementRef[componentName] ||
-        ((didWarnAboutElementRef[componentName] = !0),
-        console.error(
-          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
-        ));
-      componentName = this.props.ref;
-      return void 0 !== componentName ? componentName : null;
+    };
+    warnAboutAccessingKey.isReactWarning = true;
+    Object.defineProperty(props, 'key', {
+      get: warnAboutAccessingKey,
+      configurable: true
+    });
+  }
+}
+function elementRefGetterWithDeprecationWarning() {
+  {
+    var componentName = getComponentNameFromType(this.type);
+    if (!didWarnAboutElementRef[componentName]) {
+      didWarnAboutElementRef[componentName] = true;
+      console.error('Accessing element.ref was removed in React 19. ref is now a ' + 'regular prop. It will be removed from the JSX Element ' + 'type in a future release.');
     }
-    function ReactElement(
-      type,
-      key,
-      self,
-      source,
-      owner,
-      props,
-      debugStack,
-      debugTask
-    ) {
-      self = props.ref;
-      type = {
-        $$typeof: REACT_ELEMENT_TYPE,
-        type: type,
-        key: key,
-        props: props,
-        _owner: owner
-      };
-      null !== (void 0 !== self ? self : null)
-        ? Object.defineProperty(type, "ref", {
-            enumerable: !1,
-            get: elementRefGetterWithDeprecationWarning
-          })
-        : Object.defineProperty(type, "ref", { enumerable: !1, value: null });
-      type._store = {};
-      Object.defineProperty(type._store, "validated", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: 0
+
+    // An undefined `element.ref` is coerced to `null` for
+    // backwards compatibility.
+    var refProp = this.props.ref;
+    return refProp !== undefined ? refProp : null;
+  }
+}
+
+/**
+ * Factory method to create a new React element. This no longer adheres to
+ * the class pattern, so do not use new to call it. Also, instanceof check
+ * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check
+ * if something is a React Element.
+ *
+ * @param {*} type
+ * @param {*} props
+ * @param {*} key
+ * @param {string|object} ref
+ * @param {*} owner
+ * @param {*} self A *temporary* helper to detect places where `this` is
+ * different from the `owner` when React.createElement is called, so that we
+ * can warn. We want to get rid of owner and replace string `ref`s with arrow
+ * functions, and as long as `this` and owner are the same, there will be no
+ * change in behavior.
+ * @param {*} source An annotation object (added by a transpiler or otherwise)
+ * indicating filename, line number, and/or other information.
+ * @internal
+ */
+function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
+  // Ignore whatever was passed as the ref argument and treat `props.ref` as
+  // the source of truth. The only thing we use this for is `element.ref`,
+  // which will log a deprecation warning on access. In the next release, we
+  // can remove `element.ref` as well as the `ref` argument.
+  var refProp = props.ref;
+
+  // An undefined `element.ref` is coerced to `null` for
+  // backwards compatibility.
+  var ref = refProp !== undefined ? refProp : null;
+  var element;
+  {
+    // In dev, make `ref` a non-enumerable property with a warning. It's non-
+    // enumerable so that test matchers and serializers don't access it and
+    // trigger the warning.
+    //
+    // `ref` will be removed from the element completely in a future release.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      // Built-in properties that belong on the element
+      type: type,
+      key: key,
+      props: props,
+      // Record the component responsible for creating this element.
+      _owner: owner
+    };
+    if (ref !== null) {
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
+        get: elementRefGetterWithDeprecationWarning
       });
-      Object.defineProperty(type, "_debugInfo", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
+    } else {
+      // Don't warn on access if a ref is not given. This reduces false
+      // positives in cases where a test serializer uses
+      // getOwnPropertyDescriptors to compare objects, like Jest does, which is
+      // a problem because it bypasses non-enumerability.
+      //
+      // So unfortunately this will trigger a false positive warning in Jest
+      // when the diff is printed:
+      //
+      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);
+      //
+      // A bit sketchy, but this is what we've done for the `props.key` and
+      // `props.ref` accessors for years, which implies it will be good enough
+      // for `element.ref`, too. Let's see if anyone complains.
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
         value: null
       });
-      Object.defineProperty(type, "_debugStack", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: debugStack
-      });
-      Object.defineProperty(type, "_debugTask", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: debugTask
+    }
+  }
+  {
+    // The validation flag is currently mutative. We put it on
+    // an external backing store so that we can freeze the whole object.
+    // This can be replaced with a WeakMap once they are implemented in
+    // commonly used development environments.
+    element._store = {};
+
+    // To make comparing ReactElements easier for testing purposes, we make
+    // the validation flag non-enumerable (where possible, which should
+    // include every environment we run tests in), so the test framework
+    // ignores it.
+    Object.defineProperty(element._store, 'validated', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: 0
+    });
+    // debugInfo contains Server Component debug information.
+    Object.defineProperty(element, '_debugInfo', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: null
+    });
+    Object.defineProperty(element, '_debugStack', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugStack
+    });
+    Object.defineProperty(element, '_debugTask', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugTask
+    });
+    if (Object.freeze) {
+      Object.freeze(element.props);
+      Object.freeze(element);
+    }
+  }
+  return element;
+}
+
+// While `jsxDEV` should never be called when running in production, we do
+// support `jsx` and `jsxs` when running in development. This supports the case
+// where a third-party dependency ships code that was compiled for production;
+// we want to still provide warnings in development.
+//
+// So these functions are the _dev_ implementations of the _production_
+// API signatures.
+//
+// Since these functions are dev-only, it's ok to add an indirection here. They
+// only exist to provide different versions of `isStaticChildren`. (We shouldn't
+// use this pattern for the prod versions, though, because it will add an call
+// frame.)
+function jsxProdSignatureRunningInDevWithDynamicChildren(type, config, maybeKey, source, self) {
+  {
+    var isStaticChildren = false;
+    var trackActualOwner = ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;
+    return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, (trackActualOwner ? Error('react-stack-top-frame') : unknownOwnerDebugStack), (trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask));
+  }
+}
+function jsxProdSignatureRunningInDevWithStaticChildren(type, config, maybeKey, source, self) {
+  {
+    var isStaticChildren = true;
+    var trackActualOwner = ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;
+    return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, (trackActualOwner ? Error('react-stack-top-frame') : unknownOwnerDebugStack), (trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask));
+  }
+}
+var didWarnAboutKeySpread = {};
+function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
+  {
+    // We don't warn for invalid element type here because with owner stacks,
+    // we error in the renderer. The renderer is the only one that knows what
+    // types are valid for this particular renderer so we let it error there.
+
+    // Skip key warning if the type isn't valid since our key validation logic
+    // doesn't expect a non-string/function type and can throw confusing
+    // errors. We don't want exception behavior to differ between dev and
+    // prod. (Rendering will throw with a helpful message and as soon as the
+    // type is fixed, the key warnings will appear.)
+    // With owner stacks, we no longer need the type here so this comment is
+    // no longer true. Which is why we can run this even for invalid types.
+    var children = config.children;
+    if (children !== undefined) {
+      if (isStaticChildren) {
+        if (isArray(children)) {
+          for (var i = 0; i < children.length; i++) {
+            validateChildKeys(children[i]);
+          }
+          if (Object.freeze) {
+            Object.freeze(children);
+          }
+        } else {
+          console.error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
+        }
+      } else {
+        validateChildKeys(children);
+      }
+    }
+
+    // Warn about key spread regardless of whether the type is valid.
+    if (hasOwnProperty.call(config, 'key')) {
+      var componentName = getComponentNameFromType(type);
+      var keys = Object.keys(config).filter(function (k) {
+        return k !== 'key';
       });
-      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
-      return type;
+      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';
+      if (!didWarnAboutKeySpread[componentName + beforeExample]) {
+        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';
+        console.error('A props object containing a "key" prop is being spread into JSX:\n' + '  let props = %s;\n' + '  <%s {...props} />\n' + 'React keys must be passed directly to JSX without using spread:\n' + '  let props = %s;\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
+        didWarnAboutKeySpread[componentName + beforeExample] = true;
+      }
+    }
+    var key = null;
+
+    // Currently, key can be spread in as a prop. This causes a potential
+    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
+    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
+    // but as an intermediary step, we will use jsxDEV for everything except
+    // <div {...props} key="Hi" />, because we aren't currently able to tell if
+    // key is explicitly declared to be undefined or not.
+    if (maybeKey !== undefined) {
+      {
+        checkKeyStringCoercion(maybeKey);
+      }
+      key = '' + maybeKey;
     }
-    function jsxDEVImpl(
-      type,
-      config,
-      maybeKey,
-      isStaticChildren,
-      source,
-      self,
-      debugStack,
-      debugTask
-    ) {
-      var children = config.children;
-      if (void 0 !== children)
-        if (isStaticChildren)
-          if (isArrayImpl(children)) {
-            for (
-              isStaticChildren = 0;
-              isStaticChildren < children.length;
-              isStaticChildren++
-            )
-              validateChildKeys(children[isStaticChildren]);
-            Object.freeze && Object.freeze(children);
-          } else
-            console.error(
-              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
-            );
-        else validateChildKeys(children);
-      if (hasOwnProperty.call(config, "key")) {
-        children = getComponentNameFromType(type);
-        var keys = Object.keys(config).filter(function (k) {
-          return "key" !== k;
-        });
-        isStaticChildren =
-          0 < keys.length
-            ? "{key: someKey, " + keys.join(": ..., ") + ": ...}"
-            : "{key: someKey}";
-        didWarnAboutKeySpread[children + isStaticChildren] ||
-          ((keys =
-            0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}"),
-          console.error(
-            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
-            isStaticChildren,
-            children,
-            keys,
-            children
-          ),
-          (didWarnAboutKeySpread[children + isStaticChildren] = !0));
+    if (hasValidKey(config)) {
+      {
+        checkKeyStringCoercion(config.key);
       }
-      children = null;
-      void 0 !== maybeKey &&
-        (checkKeyStringCoercion(maybeKey), (children = "" + maybeKey));
-      hasValidKey(config) &&
-        (checkKeyStringCoercion(config.key), (children = "" + config.key));
-      if ("key" in config) {
-        maybeKey = {};
-        for (var propName in config)
-          "key" !== propName && (maybeKey[propName] = config[propName]);
-      } else maybeKey = config;
-      children &&
-        defineKeyPropWarningGetter(
-          maybeKey,
-          "function" === typeof type
-            ? type.displayName || type.name || "Unknown"
-            : type
-        );
-      return ReactElement(
-        type,
-        children,
-        self,
-        source,
-        getOwner(),
-        maybeKey,
-        debugStack,
-        debugTask
-      );
+      key = '' + config.key;
     }
-    function validateChildKeys(node) {
-      "object" === typeof node &&
-        null !== node &&
-        node.$$typeof === REACT_ELEMENT_TYPE &&
-        node._store &&
-        (node._store.validated = 1);
+    var props;
+    if (!('key' in config)) {
+      // If key was not spread in, we can reuse the original props object. This
+      // only works for `jsx`, not `createElement`, because `jsx` is a compiler
+      // target and the compiler always passes a new object. For `createElement`,
+      // we can't assume a new object is passed every time because it can be
+      // called manually.
+      //
+      // Spreading key is a warning in dev. In a future release, we will not
+      // remove a spread key from the props object. (But we'll still warn.) We'll
+      // always pass the object straight through.
+      props = config;
+    } else {
+      // We need to remove reserved props (key, prop, ref). Create a fresh props
+      // object and copy over all the non-reserved props. We don't use `delete`
+      // because in V8 it will deopt the object to dictionary mode.
+      props = {};
+      for (var propName in config) {
+        // Skip over reserved prop names
+        if (propName !== 'key') {
+          props[propName] = config[propName];
+        }
+      }
     }
-    var React = require("react"),
-      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
-      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
-    Symbol.for("react.provider");
-    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
-      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
-      ReactSharedInternals =
-        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
-      hasOwnProperty = Object.prototype.hasOwnProperty,
-      isArrayImpl = Array.isArray,
-      createTask = console.createTask
-        ? console.createTask
-        : function () {
-            return null;
-          };
-    React = {
-      "react-stack-bottom-frame": function (callStackForError) {
-        return callStackForError();
+    if (key) {
+      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
+      defineKeyPropWarningGetter(props, displayName);
+    }
+    return ReactElement(type, key, self, source, getOwner(), props, debugStack, debugTask);
+  }
+}
+
+/**
+ * Ensure that every element either is passed in a static location, in an
+ * array with an explicit keys property defined, or in an object literal
+ * with valid key property.
+ *
+ * @internal
+ * @param {ReactNode} node Statically passed child of any type.
+ * @param {*} parentType node's parent's type.
+ */
+function validateChildKeys(node, parentType) {
+  {
+    // With owner stacks is, no warnings happens. All we do is
+    // mark elements as being in a valid static child position so they
+    // don't need keys.
+    if (isValidElement(node)) {
+      if (node._store) {
+        node._store.validated = 1;
       }
-    };
-    var specialPropKeyWarningShown;
-    var didWarnAboutElementRef = {};
-    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(
-      React,
-      UnknownOwner
-    )();
-    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
-    var didWarnAboutKeySpread = {};
-    exports.Fragment = REACT_FRAGMENT_TYPE;
-    exports.jsx = function (type, config, maybeKey, source, self) {
-      var trackActualOwner =
-        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
-      return jsxDEVImpl(
-        type,
-        config,
-        maybeKey,
-        !1,
-        source,
-        self,
-        trackActualOwner
-          ? Error("react-stack-top-frame")
-          : unknownOwnerDebugStack,
-        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
-      );
-    };
-    exports.jsxs = function (type, config, maybeKey, source, self) {
-      var trackActualOwner =
-        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
-      return jsxDEVImpl(
-        type,
-        config,
-        maybeKey,
-        !0,
-        source,
-        self,
-        trackActualOwner
-          ? Error("react-stack-top-frame")
-          : unknownOwnerDebugStack,
-        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
-      );
-    };
-  })();
+    }
+  }
+}
+
+/**
+ * Verifies the object is a ReactElement.
+ * See https://reactjs.org/docs/react-api.html#isvalidelement
+ * @param {?object} object
+ * @return {boolean} True if `object` is a ReactElement.
+ * @final
+ */
+function isValidElement(object) {
+  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
+}
+
+var jsx = jsxProdSignatureRunningInDevWithDynamicChildren ;
+// we may want to special case jsxs internally to take advantage of static children.
+// for now we can ship identical prod functions
+var jsxs = jsxProdSignatureRunningInDevWithStaticChildren ;
+
+exports.Fragment = REACT_FRAGMENT_TYPE;
+exports.jsx = jsx;
+exports.jsxs = jsxs;
+//# sourceMappingURL=react-jsx-runtime.development.js.map
diff --git a/cjs/react-jsx-runtime.development.js.map b/cjs/react-jsx-runtime.development.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..654e05604c6fa671a2b11fc2c27c1203251c8101
--- /dev/null
+++ b/cjs/react-jsx-runtime.development.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react-jsx-runtime.development.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactFeatureFlags.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/getComponentNameFromType.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSharedInternals.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/hasOwnProperty.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/CheckStringCoercion.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/isArray.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXElement.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSX.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n */\n\n// -----------------------------------------------------------------------------\n// Land or remove (zero effort)\n//\n// Flags that can likely be deleted or landed without consequences\n// -----------------------------------------------------------------------------\n\n// None\n\n// -----------------------------------------------------------------------------\n// Killswitch\n//\n// Flags that exist solely to turn off a change in case it causes a regression\n// when it rolls out to prod. We should remove these as soon as possible.\n// -----------------------------------------------------------------------------\n\nexport const enableHydrationLaneScheduling = true;\n\n// -----------------------------------------------------------------------------\n// Land or remove (moderate effort)\n//\n// Flags that can be probably deleted or landed, but might require extra effort\n// like migrating internal callers or performance testing.\n// -----------------------------------------------------------------------------\n\n// TODO: Finish rolling out in www\nexport const favorSafetyOverHydrationPerf = true;\n\n// Need to remove didTimeout argument from Scheduler before landing\nexport const disableSchedulerTimeoutInWorkLoop = false;\n\n// -----------------------------------------------------------------------------\n// Slated for removal in the future (significant effort)\n//\n// These are experiments that didn't work out, and never shipped, but we can't\n// delete from the codebase until we migrate internal callers.\n// -----------------------------------------------------------------------------\n\n// Add a callback property to suspense to notify which promises are currently\n// in the update queue. This allows reporting and tracing of what is causing\n// the user to see a loading state.\n//\n// Also allows hydration callbacks to fire when a dehydrated boundary gets\n// hydrated or deleted.\n//\n// This will eventually be replaced by the Transition Tracing proposal.\nexport const enableSuspenseCallback = false;\n\n// Experimental Scope support.\nexport const enableScopeAPI = false;\n\n// Experimental Create Event Handle API.\nexport const enableCreateEventHandleAPI = false;\n\n// Support legacy Primer support on internal FB www\nexport const enableLegacyFBSupport = false;\n\n// -----------------------------------------------------------------------------\n// Ongoing experiments\n//\n// These are features that we're either actively exploring or are reasonably\n// likely to include in an upcoming release.\n// -----------------------------------------------------------------------------\n\n// Yield to the browser event loop and not just the scheduler event loop before passive effects.\n// Fix gated tests that fail with this flag enabled before turning it back on.\nexport const enableYieldingBeforePassive = false;\n\n// Experiment to intentionally yield less to block high framerate animations.\nexport const enableThrottledScheduling = false;\n\nexport const enableLegacyCache = __EXPERIMENTAL__;\n\nexport const enableAsyncIterableChildren = __EXPERIMENTAL__;\n\nexport const enableTaint = __EXPERIMENTAL__;\n\nexport const enablePostpone = __EXPERIMENTAL__;\n\nexport const enableHalt = __EXPERIMENTAL__;\n\nexport const enableViewTransition = __EXPERIMENTAL__;\n\nexport const enableGestureTransition = __EXPERIMENTAL__;\n\nexport const enableScrollEndPolyfill = __EXPERIMENTAL__;\n\nexport const enableSuspenseyImages = false;\n\nexport const enableFizzBlockingRender = __EXPERIMENTAL__; // rel=\"expect\"\n\nexport const enableSrcObject = __EXPERIMENTAL__;\n\nexport const enableHydrationChangeEvent = __EXPERIMENTAL__;\n\nexport const enableDefaultTransitionIndicator = __EXPERIMENTAL__;\n\n/**\n * Switches Fiber creation to a simple object instead of a constructor.\n */\nexport const enableObjectFiber = false;\n\nexport const enableTransitionTracing = false;\n\n// FB-only usage. The new API has different semantics.\nexport const enableLegacyHidden = false;\n\n// Enables unstable_avoidThisFallback feature in Fiber\nexport const enableSuspenseAvoidThisFallback = false;\n\nexport const enableCPUSuspense = __EXPERIMENTAL__;\n\n// Test this at Meta before enabling.\nexport const enableNoCloningMemoCache = false;\n\nexport const enableUseEffectEventHook = __EXPERIMENTAL__;\n\n// Test in www before enabling in open source.\n// Enables DOM-server to stream its instruction set as data-attributes\n// (handled with an MutationObserver) instead of inline-scripts\nexport const enableFizzExternalRuntime = __EXPERIMENTAL__;\n\nexport const alwaysThrottleRetries = true;\n\nexport const passChildrenWhenCloningPersistedNodes = false;\n\n/**\n * Enables a new Fiber flag used in persisted mode to reduce the number\n * of cloned host components.\n */\nexport const enablePersistedModeClonedFlag = false;\n\nexport const enableEagerAlternateStateNodeCleanup = true;\n\n/**\n * Enables an expiration time for retry lanes to avoid starvation.\n */\nexport const enableRetryLaneExpiration = false;\nexport const retryLaneExpirationMs = 5000;\nexport const syncLaneExpirationMs = 250;\nexport const transitionLaneExpirationMs = 5000;\n\n/**\n * Enables a new error detection for infinite render loops from updates caused\n * by setState or similar outside of the component owning the state.\n */\nexport const enableInfiniteRenderLoopDetection = false;\n\nexport const enableLazyPublicInstanceInFabric = false;\n\nexport const enableFragmentRefs = __EXPERIMENTAL__;\n\n// -----------------------------------------------------------------------------\n// Ready for next major.\n//\n// Alias __NEXT_MAJOR__ to __EXPERIMENTAL__ for easier skimming.\n// -----------------------------------------------------------------------------\n\n// TODO: Anything that's set to `true` in this section should either be cleaned\n// up (if it's on everywhere, including Meta and RN builds) or moved to a\n// different section of this file.\n\n// const __NEXT_MAJOR__ = __EXPERIMENTAL__;\n\n// Renames the internal symbol for elements since they have changed signature/constructor\nexport const renameElementSymbol = true;\n\n/**\n * Enables a fix to run insertion effect cleanup on hidden subtrees.\n */\nexport const enableHiddenSubtreeInsertionEffectCleanup = false;\n\n/**\n * Removes legacy style context defined using static `contextTypes` and consumed with static `childContextTypes`.\n */\nexport const disableLegacyContext = true;\n/**\n * Removes legacy style context just from function components.\n */\nexport const disableLegacyContextForFunctionComponents = true;\n\n// Enable the moveBefore() alternative to insertBefore(). This preserves states of moves.\nexport const enableMoveBefore = false;\n\n// Disabled caching behavior of `react/cache` in client runtimes.\nexport const disableClientCache = true;\n\n// Warn on any usage of ReactTestRenderer\nexport const enableReactTestRendererWarning = true;\n\n// Disables legacy mode\n// This allows us to land breaking changes to remove legacy mode APIs in experimental builds\n// before removing them in stable in the next Major\nexport const disableLegacyMode = true;\n\n// -----------------------------------------------------------------------------\n// Chopping Block\n//\n// Planned feature deprecations and breaking changes. Sorted roughly in order of\n// when we plan to enable them.\n// -----------------------------------------------------------------------------\n\n// -----------------------------------------------------------------------------\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nexport const disableCommentsAsDOMContainers = true;\n\nexport const enableTrustedTypesIntegration = false;\n\n// Prevent the value and checked attributes from syncing with their related\n// DOM properties\nexport const disableInputAttributeSyncing = false;\n\n// Disables children for <textarea> elements\nexport const disableTextareaChildren = false;\n\n// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n\n// Gather advanced timing metrics for Profiler subtrees.\nexport const enableProfilerTimer = __PROFILE__;\n\n// Adds performance.measure() marks using Chrome extensions to allow formatted\n// Component rendering tracks to show up in the Performance tab.\n// This flag will be used for both Server Component and Client Component tracks.\n// All calls should also be gated on enableProfilerTimer.\nexport const enableComponentPerformanceTrack = __EXPERIMENTAL__;\n\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nexport const enableSchedulingProfiler: boolean =\n  !enableComponentPerformanceTrack && __PROFILE__;\n\n// Record durations for commit and passive effects phases.\nexport const enableProfilerCommitHooks = __PROFILE__;\n\n// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nexport const enableProfilerNestedUpdatePhase = __PROFILE__;\n\nexport const enableAsyncDebugInfo = __EXPERIMENTAL__;\n\n// Track which Fiber(s) schedule render work.\nexport const enableUpdaterTracking = __PROFILE__;\n\nexport const ownerStackLimit = 1e4;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {LazyComponent} from 'react/src/ReactLazy';\nimport type {ReactContext, ReactConsumerType} from 'shared/ReactTypes';\n\nimport {\n  REACT_CONTEXT_TYPE,\n  REACT_CONSUMER_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_TRACING_MARKER_TYPE,\n  REACT_VIEW_TRANSITION_TYPE,\n  REACT_ACTIVITY_TYPE,\n} from 'shared/ReactSymbols';\n\nimport {\n  enableTransitionTracing,\n  enableViewTransition,\n} from './ReactFeatureFlags';\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getWrappedName(\n  outerType: mixed,\n  innerType: any,\n  wrapperName: string,\n): string {\n  const displayName = (outerType: any).displayName;\n  if (displayName) {\n    return displayName;\n  }\n  const functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? `${wrapperName}(${functionName})` : wrapperName;\n}\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type: ReactContext<any>) {\n  return type.displayName || 'Context';\n}\n\nconst REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\n// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nexport default function getComponentNameFromType(type: mixed): string | null {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n  if (typeof type === 'function') {\n    if ((type: any).$$typeof === REACT_CLIENT_REFERENCE) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n    return (type: any).displayName || type.name || null;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n    case REACT_ACTIVITY_TYPE:\n      return 'Activity';\n    case REACT_VIEW_TRANSITION_TYPE:\n      if (enableViewTransition) {\n        return 'ViewTransition';\n      }\n    // Fall through\n    case REACT_TRACING_MARKER_TYPE:\n      if (enableTransitionTracing) {\n        return 'TracingMarker';\n      }\n  }\n  if (typeof type === 'object') {\n    if (__DEV__) {\n      if (typeof (type: any).tag === 'number') {\n        console.error(\n          'Received an unexpected object in getComponentNameFromType(). ' +\n            'This is likely a bug in React. Please file an issue.',\n        );\n      }\n    }\n    switch (type.$$typeof) {\n      case REACT_PORTAL_TYPE:\n        return 'Portal';\n      case REACT_CONTEXT_TYPE:\n        const context: ReactContext<any> = (type: any);\n        return getContextName(context);\n      case REACT_CONSUMER_TYPE:\n        const consumer: ReactConsumerType<any> = (type: any);\n        return getContextName(consumer._context) + '.Consumer';\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n      case REACT_MEMO_TYPE:\n        const outerName = (type: any).displayName || null;\n        if (outerName !== null) {\n          return outerName;\n        }\n        return getComponentNameFromType(type.type) || 'Memo';\n      case REACT_LAZY_TYPE: {\n        const lazyComponent: LazyComponent<any, any> = (type: any);\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n        try {\n          return getComponentNameFromType(init(payload));\n        } catch (x) {\n          return null;\n        }\n      }\n    }\n  }\n  return null;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport * as React from 'react';\n\nconst ReactSharedInternals =\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n\nexport default ReactSharedInternals;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// $FlowFixMe[method-unbinding]\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport default hasOwnProperty;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value: mixed): string {\n  if (__DEV__) {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    const hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    const type =\n      (hasToStringTag && (value: any)[Symbol.toStringTag]) ||\n      (value: any).constructor.name ||\n      'Object';\n    // $FlowFixMe[incompatible-return]\n    return type;\n  }\n}\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value: mixed): boolean {\n  if (__DEV__) {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\n/** @noinline */\nfunction testStringCoercion(value: mixed) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + (value: any);\n}\n\nexport function checkAttributeStringCoercion(\n  value: mixed,\n  attributeName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` attribute is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        attributeName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkKeyStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided key is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkPropStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` prop is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkOptionStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` option is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkCSSPropertyStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` CSS property is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkHtmlStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided HTML markup uses a value of unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkFormFieldValueStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'Form field values (value, checked, defaultValue, or defaultChecked props)' +\n          ' must be strings, not %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\ndeclare function isArray(a: mixed): boolean %checks(Array.isArray(a));\n\nconst isArrayImpl = Array.isArray;\n\nfunction isArray(a: mixed): boolean {\n  return isArrayImpl(a);\n}\n\nexport default isArray;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport assign from 'shared/assign';\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\nimport isArray from 'shared/isArray';\nimport {ownerStackLimit} from 'shared/ReactFeatureFlags';\n\nconst createTask =\n  // eslint-disable-next-line react-internal/no-production-logging\n  __DEV__ && console.createTask\n    ? // eslint-disable-next-line react-internal/no-production-logging\n      console.createTask\n    : () => null;\n\nfunction getTaskName(type) {\n  if (type === REACT_FRAGMENT_TYPE) {\n    return '<>';\n  }\n  if (\n    typeof type === 'object' &&\n    type !== null &&\n    type.$$typeof === REACT_LAZY_TYPE\n  ) {\n    // We don't want to eagerly initialize the initializer in DEV mode so we can't\n    // call it to extract the type so we don't know the type of this component.\n    return '<...>';\n  }\n  try {\n    const name = getComponentNameFromType(type);\n    return name ? '<' + name + '>' : '<...>';\n  } catch (x) {\n    return '<...>';\n  }\n}\n\nfunction getOwner() {\n  if (__DEV__) {\n    const dispatcher = ReactSharedInternals.A;\n    if (dispatcher === null) {\n      return null;\n    }\n    return dispatcher.getOwner();\n  }\n  return null;\n}\n\n/** @noinline */\nfunction UnknownOwner() {\n  /** @noinline */\n  return (() => Error('react-stack-top-frame'))();\n}\nconst createFakeCallStack = {\n  react_stack_bottom_frame: function (callStackForError) {\n    return callStackForError();\n  },\n};\n\nlet specialPropKeyWarningShown;\nlet didWarnAboutElementRef;\nlet didWarnAboutOldJSXRuntime;\nlet unknownOwnerDebugStack;\nlet unknownOwnerDebugTask;\n\nif (__DEV__) {\n  didWarnAboutElementRef = {};\n\n  // We use this technique to trick minifiers to preserve the function name.\n  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(\n    createFakeCallStack,\n    UnknownOwner,\n  )();\n  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://react.dev/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction elementRefGetterWithDeprecationWarning() {\n  if (__DEV__) {\n    const componentName = getComponentNameFromType(this.type);\n    if (!didWarnAboutElementRef[componentName]) {\n      didWarnAboutElementRef[componentName] = true;\n      console.error(\n        'Accessing element.ref was removed in React 19. ref is now a ' +\n          'regular prop. It will be removed from the JSX Element ' +\n          'type in a future release.',\n      );\n    }\n\n    // An undefined `element.ref` is coerced to `null` for\n    // backwards compatibility.\n    const refProp = this.props.ref;\n    return refProp !== undefined ? refProp : null;\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nfunction ReactElement(\n  type,\n  key,\n  self,\n  source,\n  owner,\n  props,\n  debugStack,\n  debugTask,\n) {\n  // Ignore whatever was passed as the ref argument and treat `props.ref` as\n  // the source of truth. The only thing we use this for is `element.ref`,\n  // which will log a deprecation warning on access. In the next release, we\n  // can remove `element.ref` as well as the `ref` argument.\n  const refProp = props.ref;\n\n  // An undefined `element.ref` is coerced to `null` for\n  // backwards compatibility.\n  const ref = refProp !== undefined ? refProp : null;\n\n  let element;\n  if (__DEV__) {\n    // In dev, make `ref` a non-enumerable property with a warning. It's non-\n    // enumerable so that test matchers and serializers don't access it and\n    // trigger the warning.\n    //\n    // `ref` will be removed from the element completely in a future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n\n      props,\n\n      // Record the component responsible for creating this element.\n      _owner: owner,\n    };\n    if (ref !== null) {\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        get: elementRefGetterWithDeprecationWarning,\n      });\n    } else {\n      // Don't warn on access if a ref is not given. This reduces false\n      // positives in cases where a test serializer uses\n      // getOwnPropertyDescriptors to compare objects, like Jest does, which is\n      // a problem because it bypasses non-enumerability.\n      //\n      // So unfortunately this will trigger a false positive warning in Jest\n      // when the diff is printed:\n      //\n      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);\n      //\n      // A bit sketchy, but this is what we've done for the `props.key` and\n      // `props.ref` accessors for years, which implies it will be good enough\n      // for `element.ref`, too. Let's see if anyone complains.\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        value: null,\n      });\n    }\n  } else {\n    // In prod, `ref` is a regular property and _owner doesn't exist.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n      ref,\n\n      props,\n    };\n  }\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: 0,\n    });\n    // debugInfo contains Server Component debug information.\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null,\n    });\n    Object.defineProperty(element, '_debugStack', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugStack,\n    });\n    Object.defineProperty(element, '_debugTask', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugTask,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxProd(type, config, maybeKey) {\n  let key = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  let props;\n  if (!('key' in config)) {\n    // If key was not spread in, we can reuse the original props object. This\n    // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n    // target and the compiler always passes a new object. For `createElement`,\n    // we can't assume a new object is passed every time because it can be\n    // called manually.\n    //\n    // Spreading key is a warning in dev. In a future release, we will not\n    // remove a spread key from the props object. (But we'll still warn.) We'll\n    // always pass the object straight through.\n    props = config;\n  } else {\n    // We need to remove reserved props (key, prop, ref). Create a fresh props\n    // object and copy over all the non-reserved props. We don't use `delete`\n    // because in V8 it will deopt the object to dictionary mode.\n    props = {};\n    for (const propName in config) {\n      // Skip over reserved prop names\n      if (propName !== 'key') {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    undefined,\n    undefined,\n  );\n}\n\n// While `jsxDEV` should never be called when running in production, we do\n// support `jsx` and `jsxs` when running in development. This supports the case\n// where a third-party dependency ships code that was compiled for production;\n// we want to still provide warnings in development.\n//\n// So these functions are the _dev_ implementations of the _production_\n// API signatures.\n//\n// Since these functions are dev-only, it's ok to add an indirection here. They\n// only exist to provide different versions of `isStaticChildren`. (We shouldn't\n// use this pattern for the prod versions, though, because it will add an call\n// frame.)\nexport function jsxProdSignatureRunningInDevWithDynamicChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = false;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nexport function jsxProdSignatureRunningInDevWithStaticChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = true;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nconst didWarnAboutKeySpread = {};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return jsxDEVImpl(\n    type,\n    config,\n    maybeKey,\n    isStaticChildren,\n    source,\n    self,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nfunction jsxDEVImpl(\n  type,\n  config,\n  maybeKey,\n  isStaticChildren,\n  source,\n  self,\n  debugStack,\n  debugTask,\n) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    // With owner stacks, we no longer need the type here so this comment is\n    // no longer true. Which is why we can run this even for invalid types.\n    const children = config.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          console.error(\n            'React.jsx: Static children should always be an array. ' +\n              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n              'Use the Babel transform instead.',\n          );\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n\n    // Warn about key spread regardless of whether the type is valid.\n    if (hasOwnProperty.call(config, 'key')) {\n      const componentName = getComponentNameFromType(type);\n      const keys = Object.keys(config).filter(k => k !== 'key');\n      const beforeExample =\n        keys.length > 0\n          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'\n          : '{key: someKey}';\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        const afterExample =\n          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n        console.error(\n          'A props object containing a \"key\" prop is being spread into JSX:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s {...props} />\\n' +\n            'React keys must be passed directly to JSX without using spread:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s key={someKey} {...props} />',\n          beforeExample,\n          componentName,\n          afterExample,\n          componentName,\n        );\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    let key = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    let props;\n    if (!('key' in config)) {\n      // If key was not spread in, we can reuse the original props object. This\n      // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n      // target and the compiler always passes a new object. For `createElement`,\n      // we can't assume a new object is passed every time because it can be\n      // called manually.\n      //\n      // Spreading key is a warning in dev. In a future release, we will not\n      // remove a spread key from the props object. (But we'll still warn.) We'll\n      // always pass the object straight through.\n      props = config;\n    } else {\n      // We need to remove reserved props (key, prop, ref). Create a fresh props\n      // object and copy over all the non-reserved props. We don't use `delete`\n      // because in V8 it will deopt the object to dictionary mode.\n      props = {};\n      for (const propName in config) {\n        // Skip over reserved prop names\n        if (propName !== 'key') {\n          props[propName] = config[propName];\n        }\n      }\n    }\n\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    return ReactElement(\n      type,\n      key,\n      self,\n      source,\n      getOwner(),\n      props,\n      debugStack,\n      debugTask,\n    );\n  }\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n  }\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const clonedElement = ReactElement(\n    oldElement.type,\n    newKey,\n    undefined,\n    undefined,\n    !__DEV__ ? undefined : oldElement._owner,\n    oldElement.props,\n    __DEV__ && oldElement._debugStack,\n    __DEV__ && oldElement._debugTask,\n  );\n  if (__DEV__) {\n    // The cloned element should inherit the original element's key validation.\n    if (oldElement._store) {\n      clonedElement._store.validated = oldElement._store.validated;\n    }\n  }\n  return clonedElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = !__DEV__ ? undefined : element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      owner = __DEV__ ? getOwner() : undefined;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // ...and maybe these, too, though we currently rely on them for\n        // warnings and debug information in dev. Need to decide if we're OK\n        // with dropping them. In the jsx() runtime it's not an issue because\n        // the data gets passed as separate arguments instead of props, but\n        // it would be nice to stop relying on them entirely so we can drop\n        // them from the internal Fiber field.\n        propName !== '__self' &&\n        propName !== '__source' &&\n        // Undefined `ref` is ignored by cloneElement. We treat it the same as\n        // if the property were missing. This is mostly for\n        // backwards compatibility.\n        !(propName === 'ref' && config.ref === undefined)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  const clonedElement = ReactElement(\n    element.type,\n    key,\n    undefined,\n    undefined,\n    owner,\n    props,\n    __DEV__ && element._debugStack,\n    __DEV__ && element._debugTask,\n  );\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], clonedElement.type);\n  }\n\n  return clonedElement;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    // With owner stacks is, no warnings happens. All we do is\n    // mark elements as being in a valid static child position so they\n    // don't need keys.\n    if (isValidElement(node)) {\n      if (node._store) {\n        node._store.validated = 1;\n      }\n    }\n  }\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport {REACT_FRAGMENT_TYPE} from 'shared/ReactSymbols';\nimport {\n  jsxProd,\n  jsxProdSignatureRunningInDevWithDynamicChildren,\n  jsxProdSignatureRunningInDevWithStaticChildren,\n  jsxDEV as _jsxDEV,\n} from './ReactJSXElement';\n\nconst jsx: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithDynamicChildren\n  : jsxProd;\n// we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\nconst jsxs: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithStaticChildren\n  : jsxProd;\n\nconst jsxDEV: any = __DEV__ ? _jsxDEV : undefined;\n\nexport {REACT_FRAGMENT_TYPE as Fragment, jsx, jsxs, jsxDEV};\n"],"names":["ownerStackLimit","REACT_ELEMENT_TYPE","Symbol","for","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_CONSUMER_TYPE","REACT_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_ACTIVITY_TYPE","REACT_VIEW_TRANSITION_TYPE","getWrappedName","outerType","innerType","wrapperName","displayName","functionName","name","getContextName","type","REACT_CLIENT_REFERENCE","getComponentNameFromType","$$typeof","tag","console","error","context","consumer","_context","render","outerName","lazyComponent","payload","_payload","init","_init","x","ReactSharedInternals","React","__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","hasOwnProperty","Object","prototype","typeName","value","hasToStringTag","toStringTag","constructor","willCoercionThrow","testStringCoercion","e","checkKeyStringCoercion","isArrayImpl","Array","isArray","a","createTask","getTaskName","getOwner","dispatcher","A","UnknownOwner","Error","createFakeCallStack","react_stack_bottom_frame","callStackForError","specialPropKeyWarningShown","didWarnAboutElementRef","unknownOwnerDebugStack","unknownOwnerDebugTask","bind","hasValidKey","config","call","getter","getOwnPropertyDescriptor","get","isReactWarning","key","undefined","defineKeyPropWarningGetter","props","warnAboutAccessingKey","defineProperty","configurable","elementRefGetterWithDeprecationWarning","componentName","refProp","ref","ReactElement","self","source","owner","debugStack","debugTask","element","_owner","enumerable","_store","writable","freeze","jsxProdSignatureRunningInDevWithDynamicChildren","maybeKey","isStaticChildren","trackActualOwner","recentlyCreatedOwnerStacks","jsxDEVImpl","jsxProdSignatureRunningInDevWithStaticChildren","didWarnAboutKeySpread","children","i","length","validateChildKeys","keys","filter","k","beforeExample","join","afterExample","propName","node","parentType","isValidElement","validated","object","jsx","jsxs"],"mappings":"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"}
\ No newline at end of file
diff --git a/cjs/react-jsx-runtime.production.js b/cjs/react-jsx-runtime.production.js
index 12d60887f08e64712ec20a40154d521fe7740a7a..f2ee3893f0da16cb977062224e104cf805632c3e 100644
--- a/cjs/react-jsx-runtime.production.js
+++ b/cjs/react-jsx-runtime.production.js
@@ -1,34 +1,115 @@
+'use strict';
+
+const REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+
+function getOwner() {
+  return null;
+}
+function hasValidKey(config) {
+  return config.key !== undefined;
+}
+
 /**
- * @license React
- * react-jsx-runtime.production.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * Factory method to create a new React element. This no longer adheres to
+ * the class pattern, so do not use new to call it. Also, instanceof check
+ * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check
+ * if something is a React Element.
  *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
+ * @param {*} type
+ * @param {*} props
+ * @param {*} key
+ * @param {string|object} ref
+ * @param {*} owner
+ * @param {*} self A *temporary* helper to detect places where `this` is
+ * different from the `owner` when React.createElement is called, so that we
+ * can warn. We want to get rid of owner and replace string `ref`s with arrow
+ * functions, and as long as `this` and owner are the same, there will be no
+ * change in behavior.
+ * @param {*} source An annotation object (added by a transpiler or otherwise)
+ * indicating filename, line number, and/or other information.
+ * @internal
  */
+function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
+  // Ignore whatever was passed as the ref argument and treat `props.ref` as
+  // the source of truth. The only thing we use this for is `element.ref`,
+  // which will log a deprecation warning on access. In the next release, we
+  // can remove `element.ref` as well as the `ref` argument.
+  const refProp = props.ref;
 
-"use strict";
-var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
+  // An undefined `element.ref` is coerced to `null` for
+  // backwards compatibility.
+  const ref = refProp !== undefined ? refProp : null;
+  let element;
+  {
+    // In prod, `ref` is a regular property and _owner doesn't exist.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      // Built-in properties that belong on the element
+      type,
+      key,
+      ref,
+      props
+    };
+  }
+  return element;
+}
+
+/**
+ * https://github.com/reactjs/rfcs/pull/107
+ * @param {*} type
+ * @param {object} props
+ * @param {string} key
+ */
 function jsxProd(type, config, maybeKey) {
-  var key = null;
-  void 0 !== maybeKey && (key = "" + maybeKey);
-  void 0 !== config.key && (key = "" + config.key);
-  if ("key" in config) {
-    maybeKey = {};
-    for (var propName in config)
-      "key" !== propName && (maybeKey[propName] = config[propName]);
-  } else maybeKey = config;
-  config = maybeKey.ref;
-  return {
-    $$typeof: REACT_ELEMENT_TYPE,
-    type: type,
-    key: key,
-    ref: void 0 !== config ? config : null,
-    props: maybeKey
-  };
+  let key = null;
+
+  // Currently, key can be spread in as a prop. This causes a potential
+  // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
+  // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
+  // but as an intermediary step, we will use jsxDEV for everything except
+  // <div {...props} key="Hi" />, because we aren't currently able to tell if
+  // key is explicitly declared to be undefined or not.
+  if (maybeKey !== undefined) {
+    key = '' + maybeKey;
+  }
+  if (hasValidKey(config)) {
+    key = '' + config.key;
+  }
+  let props;
+  if (!('key' in config)) {
+    // If key was not spread in, we can reuse the original props object. This
+    // only works for `jsx`, not `createElement`, because `jsx` is a compiler
+    // target and the compiler always passes a new object. For `createElement`,
+    // we can't assume a new object is passed every time because it can be
+    // called manually.
+    //
+    // Spreading key is a warning in dev. In a future release, we will not
+    // remove a spread key from the props object. (But we'll still warn.) We'll
+    // always pass the object straight through.
+    props = config;
+  } else {
+    // We need to remove reserved props (key, prop, ref). Create a fresh props
+    // object and copy over all the non-reserved props. We don't use `delete`
+    // because in V8 it will deopt the object to dictionary mode.
+    props = {};
+    for (const propName in config) {
+      // Skip over reserved prop names
+      if (propName !== 'key') {
+        props[propName] = config[propName];
+      }
+    }
+  }
+  return ReactElement(type, key, undefined, undefined, getOwner(), props);
 }
+
+const jsx = jsxProd;
+// we may want to special case jsxs internally to take advantage of static children.
+// for now we can ship identical prod functions
+const jsxs = jsxProd;
+
 exports.Fragment = REACT_FRAGMENT_TYPE;
-exports.jsx = jsxProd;
-exports.jsxs = jsxProd;
+exports.jsx = jsx;
+exports.jsxs = jsxs;
+//# sourceMappingURL=react-jsx-runtime.production.js.map
diff --git a/cjs/react-jsx-runtime.production.js.map b/cjs/react-jsx-runtime.production.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..5fdc4fa11aee0e60fe951e7354dfae2e32a0f2dc
--- /dev/null
+++ b/cjs/react-jsx-runtime.production.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react-jsx-runtime.production.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXElement.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSX.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport assign from 'shared/assign';\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\nimport isArray from 'shared/isArray';\nimport {ownerStackLimit} from 'shared/ReactFeatureFlags';\n\nconst createTask =\n  // eslint-disable-next-line react-internal/no-production-logging\n  __DEV__ && console.createTask\n    ? // eslint-disable-next-line react-internal/no-production-logging\n      console.createTask\n    : () => null;\n\nfunction getTaskName(type) {\n  if (type === REACT_FRAGMENT_TYPE) {\n    return '<>';\n  }\n  if (\n    typeof type === 'object' &&\n    type !== null &&\n    type.$$typeof === REACT_LAZY_TYPE\n  ) {\n    // We don't want to eagerly initialize the initializer in DEV mode so we can't\n    // call it to extract the type so we don't know the type of this component.\n    return '<...>';\n  }\n  try {\n    const name = getComponentNameFromType(type);\n    return name ? '<' + name + '>' : '<...>';\n  } catch (x) {\n    return '<...>';\n  }\n}\n\nfunction getOwner() {\n  if (__DEV__) {\n    const dispatcher = ReactSharedInternals.A;\n    if (dispatcher === null) {\n      return null;\n    }\n    return dispatcher.getOwner();\n  }\n  return null;\n}\n\n/** @noinline */\nfunction UnknownOwner() {\n  /** @noinline */\n  return (() => Error('react-stack-top-frame'))();\n}\nconst createFakeCallStack = {\n  react_stack_bottom_frame: function (callStackForError) {\n    return callStackForError();\n  },\n};\n\nlet specialPropKeyWarningShown;\nlet didWarnAboutElementRef;\nlet didWarnAboutOldJSXRuntime;\nlet unknownOwnerDebugStack;\nlet unknownOwnerDebugTask;\n\nif (__DEV__) {\n  didWarnAboutElementRef = {};\n\n  // We use this technique to trick minifiers to preserve the function name.\n  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(\n    createFakeCallStack,\n    UnknownOwner,\n  )();\n  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://react.dev/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction elementRefGetterWithDeprecationWarning() {\n  if (__DEV__) {\n    const componentName = getComponentNameFromType(this.type);\n    if (!didWarnAboutElementRef[componentName]) {\n      didWarnAboutElementRef[componentName] = true;\n      console.error(\n        'Accessing element.ref was removed in React 19. ref is now a ' +\n          'regular prop. It will be removed from the JSX Element ' +\n          'type in a future release.',\n      );\n    }\n\n    // An undefined `element.ref` is coerced to `null` for\n    // backwards compatibility.\n    const refProp = this.props.ref;\n    return refProp !== undefined ? refProp : null;\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nfunction ReactElement(\n  type,\n  key,\n  self,\n  source,\n  owner,\n  props,\n  debugStack,\n  debugTask,\n) {\n  // Ignore whatever was passed as the ref argument and treat `props.ref` as\n  // the source of truth. The only thing we use this for is `element.ref`,\n  // which will log a deprecation warning on access. In the next release, we\n  // can remove `element.ref` as well as the `ref` argument.\n  const refProp = props.ref;\n\n  // An undefined `element.ref` is coerced to `null` for\n  // backwards compatibility.\n  const ref = refProp !== undefined ? refProp : null;\n\n  let element;\n  if (__DEV__) {\n    // In dev, make `ref` a non-enumerable property with a warning. It's non-\n    // enumerable so that test matchers and serializers don't access it and\n    // trigger the warning.\n    //\n    // `ref` will be removed from the element completely in a future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n\n      props,\n\n      // Record the component responsible for creating this element.\n      _owner: owner,\n    };\n    if (ref !== null) {\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        get: elementRefGetterWithDeprecationWarning,\n      });\n    } else {\n      // Don't warn on access if a ref is not given. This reduces false\n      // positives in cases where a test serializer uses\n      // getOwnPropertyDescriptors to compare objects, like Jest does, which is\n      // a problem because it bypasses non-enumerability.\n      //\n      // So unfortunately this will trigger a false positive warning in Jest\n      // when the diff is printed:\n      //\n      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);\n      //\n      // A bit sketchy, but this is what we've done for the `props.key` and\n      // `props.ref` accessors for years, which implies it will be good enough\n      // for `element.ref`, too. Let's see if anyone complains.\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        value: null,\n      });\n    }\n  } else {\n    // In prod, `ref` is a regular property and _owner doesn't exist.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n      ref,\n\n      props,\n    };\n  }\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: 0,\n    });\n    // debugInfo contains Server Component debug information.\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null,\n    });\n    Object.defineProperty(element, '_debugStack', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugStack,\n    });\n    Object.defineProperty(element, '_debugTask', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugTask,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxProd(type, config, maybeKey) {\n  let key = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  let props;\n  if (!('key' in config)) {\n    // If key was not spread in, we can reuse the original props object. This\n    // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n    // target and the compiler always passes a new object. For `createElement`,\n    // we can't assume a new object is passed every time because it can be\n    // called manually.\n    //\n    // Spreading key is a warning in dev. In a future release, we will not\n    // remove a spread key from the props object. (But we'll still warn.) We'll\n    // always pass the object straight through.\n    props = config;\n  } else {\n    // We need to remove reserved props (key, prop, ref). Create a fresh props\n    // object and copy over all the non-reserved props. We don't use `delete`\n    // because in V8 it will deopt the object to dictionary mode.\n    props = {};\n    for (const propName in config) {\n      // Skip over reserved prop names\n      if (propName !== 'key') {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    undefined,\n    undefined,\n  );\n}\n\n// While `jsxDEV` should never be called when running in production, we do\n// support `jsx` and `jsxs` when running in development. This supports the case\n// where a third-party dependency ships code that was compiled for production;\n// we want to still provide warnings in development.\n//\n// So these functions are the _dev_ implementations of the _production_\n// API signatures.\n//\n// Since these functions are dev-only, it's ok to add an indirection here. They\n// only exist to provide different versions of `isStaticChildren`. (We shouldn't\n// use this pattern for the prod versions, though, because it will add an call\n// frame.)\nexport function jsxProdSignatureRunningInDevWithDynamicChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = false;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nexport function jsxProdSignatureRunningInDevWithStaticChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = true;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nconst didWarnAboutKeySpread = {};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return jsxDEVImpl(\n    type,\n    config,\n    maybeKey,\n    isStaticChildren,\n    source,\n    self,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nfunction jsxDEVImpl(\n  type,\n  config,\n  maybeKey,\n  isStaticChildren,\n  source,\n  self,\n  debugStack,\n  debugTask,\n) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    // With owner stacks, we no longer need the type here so this comment is\n    // no longer true. Which is why we can run this even for invalid types.\n    const children = config.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          console.error(\n            'React.jsx: Static children should always be an array. ' +\n              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n              'Use the Babel transform instead.',\n          );\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n\n    // Warn about key spread regardless of whether the type is valid.\n    if (hasOwnProperty.call(config, 'key')) {\n      const componentName = getComponentNameFromType(type);\n      const keys = Object.keys(config).filter(k => k !== 'key');\n      const beforeExample =\n        keys.length > 0\n          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'\n          : '{key: someKey}';\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        const afterExample =\n          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n        console.error(\n          'A props object containing a \"key\" prop is being spread into JSX:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s {...props} />\\n' +\n            'React keys must be passed directly to JSX without using spread:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s key={someKey} {...props} />',\n          beforeExample,\n          componentName,\n          afterExample,\n          componentName,\n        );\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    let key = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    let props;\n    if (!('key' in config)) {\n      // If key was not spread in, we can reuse the original props object. This\n      // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n      // target and the compiler always passes a new object. For `createElement`,\n      // we can't assume a new object is passed every time because it can be\n      // called manually.\n      //\n      // Spreading key is a warning in dev. In a future release, we will not\n      // remove a spread key from the props object. (But we'll still warn.) We'll\n      // always pass the object straight through.\n      props = config;\n    } else {\n      // We need to remove reserved props (key, prop, ref). Create a fresh props\n      // object and copy over all the non-reserved props. We don't use `delete`\n      // because in V8 it will deopt the object to dictionary mode.\n      props = {};\n      for (const propName in config) {\n        // Skip over reserved prop names\n        if (propName !== 'key') {\n          props[propName] = config[propName];\n        }\n      }\n    }\n\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    return ReactElement(\n      type,\n      key,\n      self,\n      source,\n      getOwner(),\n      props,\n      debugStack,\n      debugTask,\n    );\n  }\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n  }\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const clonedElement = ReactElement(\n    oldElement.type,\n    newKey,\n    undefined,\n    undefined,\n    !__DEV__ ? undefined : oldElement._owner,\n    oldElement.props,\n    __DEV__ && oldElement._debugStack,\n    __DEV__ && oldElement._debugTask,\n  );\n  if (__DEV__) {\n    // The cloned element should inherit the original element's key validation.\n    if (oldElement._store) {\n      clonedElement._store.validated = oldElement._store.validated;\n    }\n  }\n  return clonedElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = !__DEV__ ? undefined : element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      owner = __DEV__ ? getOwner() : undefined;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // ...and maybe these, too, though we currently rely on them for\n        // warnings and debug information in dev. Need to decide if we're OK\n        // with dropping them. In the jsx() runtime it's not an issue because\n        // the data gets passed as separate arguments instead of props, but\n        // it would be nice to stop relying on them entirely so we can drop\n        // them from the internal Fiber field.\n        propName !== '__self' &&\n        propName !== '__source' &&\n        // Undefined `ref` is ignored by cloneElement. We treat it the same as\n        // if the property were missing. This is mostly for\n        // backwards compatibility.\n        !(propName === 'ref' && config.ref === undefined)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  const clonedElement = ReactElement(\n    element.type,\n    key,\n    undefined,\n    undefined,\n    owner,\n    props,\n    __DEV__ && element._debugStack,\n    __DEV__ && element._debugTask,\n  );\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], clonedElement.type);\n  }\n\n  return clonedElement;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    // With owner stacks is, no warnings happens. All we do is\n    // mark elements as being in a valid static child position so they\n    // don't need keys.\n    if (isValidElement(node)) {\n      if (node._store) {\n        node._store.validated = 1;\n      }\n    }\n  }\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport {REACT_FRAGMENT_TYPE} from 'shared/ReactSymbols';\nimport {\n  jsxProd,\n  jsxProdSignatureRunningInDevWithDynamicChildren,\n  jsxProdSignatureRunningInDevWithStaticChildren,\n  jsxDEV as _jsxDEV,\n} from './ReactJSXElement';\n\nconst jsx: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithDynamicChildren\n  : jsxProd;\n// we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\nconst jsxs: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithStaticChildren\n  : jsxProd;\n\nconst jsxDEV: any = __DEV__ ? _jsxDEV : undefined;\n\nexport {REACT_FRAGMENT_TYPE as Fragment, jsx, jsxs, jsxDEV};\n"],"names":["REACT_ELEMENT_TYPE","Symbol","for","REACT_FRAGMENT_TYPE","getOwner","hasValidKey","config","key","undefined","ReactElement","type","self","source","owner","props","debugStack","debugTask","refProp","ref","element","$$typeof","jsxProd","maybeKey","propName","jsx","jsxs"],"mappings":";;AAiBO,MAAMA,kBAAkB,GAC3BC,MAAM,CAACC,GAAG,CAAC,4BAA4B,CAAC,CACf,CAAA;AAEtB,MAAMC,mBAAmB,GAAWF,MAAM,CAACC,GAAG,CAAC,gBAAgB;;AC2BtE,SAASE,QAAQA,GAAG;AAQlB,EAAA,OAAO,IAAI,CAAA;AACb,CAAA;AA0CA,SAASC,WAAWA,CAACC,MAAM,EAAE;AAS3B,EAAA,OAAOA,MAAM,CAACC,GAAG,KAAKC,SAAS,CAAA;AACjC,CAAA;;AA2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CACnBC,IAAI,EACJH,GAAG,EACHI,IAAI,EACJC,MAAM,EACNC,KAAK,EACLC,KAAK,EACLC,UAAU,EACVC,SAAS,EACT;AACA;AACA;AACA;AACA;AACA,EAAA,MAAMC,OAAO,GAAGH,KAAK,CAACI,GAAG,CAAA;;AAEzB;AACA;EACA,MAAMA,GAAG,GAAGD,OAAO,KAAKT,SAAS,GAAGS,OAAO,GAAG,IAAI,CAAA;AAElD,EAAA,IAAIE,OAAO,CAAA;AACX,EA2CO;AACL;AACAA,IAAAA,OAAO,GAAG;AACR;AACAC,MAAAA,QAAQ,EAAEpB,kBAAkB;AAE5B;MACAU,IAAI;MACJH,GAAG;MACHW,GAAG;AAEHJ,MAAAA,KAAAA;KACD,CAAA;AACH,GAAA;AA4CA,EAAA,OAAOK,OAAO,CAAA;AAChB,CAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASE,OAAOA,CAACX,IAAI,EAAEJ,MAAM,EAAEgB,QAAQ,EAAE;EAC9C,IAAIf,GAAG,GAAG,IAAI,CAAA;;AAEd;AACA;AACA;AACA;AACA;AACA;EACA,IAAIe,QAAQ,KAAKd,SAAS,EAAE;IAI1BD,GAAG,GAAG,EAAE,GAAGe,QAAQ,CAAA;AACrB,GAAA;AAEA,EAAA,IAAIjB,WAAW,CAACC,MAAM,CAAC,EAAE;AAIvBC,IAAAA,GAAG,GAAG,EAAE,GAAGD,MAAM,CAACC,GAAG,CAAA;AACvB,GAAA;AAEA,EAAA,IAAIO,KAAK,CAAA;AACT,EAAA,IAAI,EAAE,KAAK,IAAIR,MAAM,CAAC,EAAE;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAQ,IAAAA,KAAK,GAAGR,MAAM,CAAA;AAChB,GAAC,MAAM;AACL;AACA;AACA;IACAQ,KAAK,GAAG,EAAE,CAAA;AACV,IAAA,KAAK,MAAMS,QAAQ,IAAIjB,MAAM,EAAE;AAC7B;MACA,IAAIiB,QAAQ,KAAK,KAAK,EAAE;AACtBT,QAAAA,KAAK,CAACS,QAAQ,CAAC,GAAGjB,MAAM,CAACiB,QAAQ,CAAC,CAAA;AACpC,OAAA;AACF,KAAA;AACF,GAAA;AAEA,EAAA,OAAOd,YAAY,CACjBC,IAAI,EACJH,GAAG,EACHC,SAAS,EACTA,SAAS,EACTJ,QAAQ,EAAE,EACVU,KAGF,CAAC,CAAA;AACH;;ACxVA,MAAMU,GAAG,GAELH,QAAO;AACX;AACA;AACA,MAAMI,IAAI,GAENJ;;;;;;"}
\ No newline at end of file
diff --git a/cjs/react-jsx-runtime.profiling.js b/cjs/react-jsx-runtime.profiling.js
index 68a28d6ad6b10a967ff8ca51f41f503a7cab80bd..b460e7b18e7ef75d1ca792ce87f4bb0286e4825e 100644
--- a/cjs/react-jsx-runtime.profiling.js
+++ b/cjs/react-jsx-runtime.profiling.js
@@ -1,34 +1,115 @@
+'use strict';
+
+const REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+
+function getOwner() {
+  return null;
+}
+function hasValidKey(config) {
+  return config.key !== undefined;
+}
+
 /**
- * @license React
- * react-jsx-runtime.profiling.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * Factory method to create a new React element. This no longer adheres to
+ * the class pattern, so do not use new to call it. Also, instanceof check
+ * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check
+ * if something is a React Element.
  *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
+ * @param {*} type
+ * @param {*} props
+ * @param {*} key
+ * @param {string|object} ref
+ * @param {*} owner
+ * @param {*} self A *temporary* helper to detect places where `this` is
+ * different from the `owner` when React.createElement is called, so that we
+ * can warn. We want to get rid of owner and replace string `ref`s with arrow
+ * functions, and as long as `this` and owner are the same, there will be no
+ * change in behavior.
+ * @param {*} source An annotation object (added by a transpiler or otherwise)
+ * indicating filename, line number, and/or other information.
+ * @internal
  */
+function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
+  // Ignore whatever was passed as the ref argument and treat `props.ref` as
+  // the source of truth. The only thing we use this for is `element.ref`,
+  // which will log a deprecation warning on access. In the next release, we
+  // can remove `element.ref` as well as the `ref` argument.
+  const refProp = props.ref;
 
-"use strict";
-var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
+  // An undefined `element.ref` is coerced to `null` for
+  // backwards compatibility.
+  const ref = refProp !== undefined ? refProp : null;
+  let element;
+  {
+    // In prod, `ref` is a regular property and _owner doesn't exist.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      // Built-in properties that belong on the element
+      type,
+      key,
+      ref,
+      props
+    };
+  }
+  return element;
+}
+
+/**
+ * https://github.com/reactjs/rfcs/pull/107
+ * @param {*} type
+ * @param {object} props
+ * @param {string} key
+ */
 function jsxProd(type, config, maybeKey) {
-  var key = null;
-  void 0 !== maybeKey && (key = "" + maybeKey);
-  void 0 !== config.key && (key = "" + config.key);
-  if ("key" in config) {
-    maybeKey = {};
-    for (var propName in config)
-      "key" !== propName && (maybeKey[propName] = config[propName]);
-  } else maybeKey = config;
-  config = maybeKey.ref;
-  return {
-    $$typeof: REACT_ELEMENT_TYPE,
-    type: type,
-    key: key,
-    ref: void 0 !== config ? config : null,
-    props: maybeKey
-  };
+  let key = null;
+
+  // Currently, key can be spread in as a prop. This causes a potential
+  // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
+  // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
+  // but as an intermediary step, we will use jsxDEV for everything except
+  // <div {...props} key="Hi" />, because we aren't currently able to tell if
+  // key is explicitly declared to be undefined or not.
+  if (maybeKey !== undefined) {
+    key = '' + maybeKey;
+  }
+  if (hasValidKey(config)) {
+    key = '' + config.key;
+  }
+  let props;
+  if (!('key' in config)) {
+    // If key was not spread in, we can reuse the original props object. This
+    // only works for `jsx`, not `createElement`, because `jsx` is a compiler
+    // target and the compiler always passes a new object. For `createElement`,
+    // we can't assume a new object is passed every time because it can be
+    // called manually.
+    //
+    // Spreading key is a warning in dev. In a future release, we will not
+    // remove a spread key from the props object. (But we'll still warn.) We'll
+    // always pass the object straight through.
+    props = config;
+  } else {
+    // We need to remove reserved props (key, prop, ref). Create a fresh props
+    // object and copy over all the non-reserved props. We don't use `delete`
+    // because in V8 it will deopt the object to dictionary mode.
+    props = {};
+    for (const propName in config) {
+      // Skip over reserved prop names
+      if (propName !== 'key') {
+        props[propName] = config[propName];
+      }
+    }
+  }
+  return ReactElement(type, key, undefined, undefined, getOwner(), props);
 }
+
+const jsx = jsxProd;
+// we may want to special case jsxs internally to take advantage of static children.
+// for now we can ship identical prod functions
+const jsxs = jsxProd;
+
 exports.Fragment = REACT_FRAGMENT_TYPE;
-exports.jsx = jsxProd;
-exports.jsxs = jsxProd;
+exports.jsx = jsx;
+exports.jsxs = jsxs;
+//# sourceMappingURL=react-jsx-runtime.profiling.js.map
diff --git a/cjs/react-jsx-runtime.profiling.js.map b/cjs/react-jsx-runtime.profiling.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..c26849e5464e51ca028d03e4ad29578dd15ac457
--- /dev/null
+++ b/cjs/react-jsx-runtime.profiling.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react-jsx-runtime.profiling.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXElement.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSX.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport assign from 'shared/assign';\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\nimport isArray from 'shared/isArray';\nimport {ownerStackLimit} from 'shared/ReactFeatureFlags';\n\nconst createTask =\n  // eslint-disable-next-line react-internal/no-production-logging\n  __DEV__ && console.createTask\n    ? // eslint-disable-next-line react-internal/no-production-logging\n      console.createTask\n    : () => null;\n\nfunction getTaskName(type) {\n  if (type === REACT_FRAGMENT_TYPE) {\n    return '<>';\n  }\n  if (\n    typeof type === 'object' &&\n    type !== null &&\n    type.$$typeof === REACT_LAZY_TYPE\n  ) {\n    // We don't want to eagerly initialize the initializer in DEV mode so we can't\n    // call it to extract the type so we don't know the type of this component.\n    return '<...>';\n  }\n  try {\n    const name = getComponentNameFromType(type);\n    return name ? '<' + name + '>' : '<...>';\n  } catch (x) {\n    return '<...>';\n  }\n}\n\nfunction getOwner() {\n  if (__DEV__) {\n    const dispatcher = ReactSharedInternals.A;\n    if (dispatcher === null) {\n      return null;\n    }\n    return dispatcher.getOwner();\n  }\n  return null;\n}\n\n/** @noinline */\nfunction UnknownOwner() {\n  /** @noinline */\n  return (() => Error('react-stack-top-frame'))();\n}\nconst createFakeCallStack = {\n  react_stack_bottom_frame: function (callStackForError) {\n    return callStackForError();\n  },\n};\n\nlet specialPropKeyWarningShown;\nlet didWarnAboutElementRef;\nlet didWarnAboutOldJSXRuntime;\nlet unknownOwnerDebugStack;\nlet unknownOwnerDebugTask;\n\nif (__DEV__) {\n  didWarnAboutElementRef = {};\n\n  // We use this technique to trick minifiers to preserve the function name.\n  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(\n    createFakeCallStack,\n    UnknownOwner,\n  )();\n  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://react.dev/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction elementRefGetterWithDeprecationWarning() {\n  if (__DEV__) {\n    const componentName = getComponentNameFromType(this.type);\n    if (!didWarnAboutElementRef[componentName]) {\n      didWarnAboutElementRef[componentName] = true;\n      console.error(\n        'Accessing element.ref was removed in React 19. ref is now a ' +\n          'regular prop. It will be removed from the JSX Element ' +\n          'type in a future release.',\n      );\n    }\n\n    // An undefined `element.ref` is coerced to `null` for\n    // backwards compatibility.\n    const refProp = this.props.ref;\n    return refProp !== undefined ? refProp : null;\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nfunction ReactElement(\n  type,\n  key,\n  self,\n  source,\n  owner,\n  props,\n  debugStack,\n  debugTask,\n) {\n  // Ignore whatever was passed as the ref argument and treat `props.ref` as\n  // the source of truth. The only thing we use this for is `element.ref`,\n  // which will log a deprecation warning on access. In the next release, we\n  // can remove `element.ref` as well as the `ref` argument.\n  const refProp = props.ref;\n\n  // An undefined `element.ref` is coerced to `null` for\n  // backwards compatibility.\n  const ref = refProp !== undefined ? refProp : null;\n\n  let element;\n  if (__DEV__) {\n    // In dev, make `ref` a non-enumerable property with a warning. It's non-\n    // enumerable so that test matchers and serializers don't access it and\n    // trigger the warning.\n    //\n    // `ref` will be removed from the element completely in a future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n\n      props,\n\n      // Record the component responsible for creating this element.\n      _owner: owner,\n    };\n    if (ref !== null) {\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        get: elementRefGetterWithDeprecationWarning,\n      });\n    } else {\n      // Don't warn on access if a ref is not given. This reduces false\n      // positives in cases where a test serializer uses\n      // getOwnPropertyDescriptors to compare objects, like Jest does, which is\n      // a problem because it bypasses non-enumerability.\n      //\n      // So unfortunately this will trigger a false positive warning in Jest\n      // when the diff is printed:\n      //\n      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);\n      //\n      // A bit sketchy, but this is what we've done for the `props.key` and\n      // `props.ref` accessors for years, which implies it will be good enough\n      // for `element.ref`, too. Let's see if anyone complains.\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        value: null,\n      });\n    }\n  } else {\n    // In prod, `ref` is a regular property and _owner doesn't exist.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n      ref,\n\n      props,\n    };\n  }\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: 0,\n    });\n    // debugInfo contains Server Component debug information.\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null,\n    });\n    Object.defineProperty(element, '_debugStack', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugStack,\n    });\n    Object.defineProperty(element, '_debugTask', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugTask,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxProd(type, config, maybeKey) {\n  let key = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  let props;\n  if (!('key' in config)) {\n    // If key was not spread in, we can reuse the original props object. This\n    // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n    // target and the compiler always passes a new object. For `createElement`,\n    // we can't assume a new object is passed every time because it can be\n    // called manually.\n    //\n    // Spreading key is a warning in dev. In a future release, we will not\n    // remove a spread key from the props object. (But we'll still warn.) We'll\n    // always pass the object straight through.\n    props = config;\n  } else {\n    // We need to remove reserved props (key, prop, ref). Create a fresh props\n    // object and copy over all the non-reserved props. We don't use `delete`\n    // because in V8 it will deopt the object to dictionary mode.\n    props = {};\n    for (const propName in config) {\n      // Skip over reserved prop names\n      if (propName !== 'key') {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    undefined,\n    undefined,\n  );\n}\n\n// While `jsxDEV` should never be called when running in production, we do\n// support `jsx` and `jsxs` when running in development. This supports the case\n// where a third-party dependency ships code that was compiled for production;\n// we want to still provide warnings in development.\n//\n// So these functions are the _dev_ implementations of the _production_\n// API signatures.\n//\n// Since these functions are dev-only, it's ok to add an indirection here. They\n// only exist to provide different versions of `isStaticChildren`. (We shouldn't\n// use this pattern for the prod versions, though, because it will add an call\n// frame.)\nexport function jsxProdSignatureRunningInDevWithDynamicChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = false;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nexport function jsxProdSignatureRunningInDevWithStaticChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = true;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nconst didWarnAboutKeySpread = {};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return jsxDEVImpl(\n    type,\n    config,\n    maybeKey,\n    isStaticChildren,\n    source,\n    self,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nfunction jsxDEVImpl(\n  type,\n  config,\n  maybeKey,\n  isStaticChildren,\n  source,\n  self,\n  debugStack,\n  debugTask,\n) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    // With owner stacks, we no longer need the type here so this comment is\n    // no longer true. Which is why we can run this even for invalid types.\n    const children = config.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          console.error(\n            'React.jsx: Static children should always be an array. ' +\n              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n              'Use the Babel transform instead.',\n          );\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n\n    // Warn about key spread regardless of whether the type is valid.\n    if (hasOwnProperty.call(config, 'key')) {\n      const componentName = getComponentNameFromType(type);\n      const keys = Object.keys(config).filter(k => k !== 'key');\n      const beforeExample =\n        keys.length > 0\n          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'\n          : '{key: someKey}';\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        const afterExample =\n          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n        console.error(\n          'A props object containing a \"key\" prop is being spread into JSX:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s {...props} />\\n' +\n            'React keys must be passed directly to JSX without using spread:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s key={someKey} {...props} />',\n          beforeExample,\n          componentName,\n          afterExample,\n          componentName,\n        );\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    let key = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    let props;\n    if (!('key' in config)) {\n      // If key was not spread in, we can reuse the original props object. This\n      // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n      // target and the compiler always passes a new object. For `createElement`,\n      // we can't assume a new object is passed every time because it can be\n      // called manually.\n      //\n      // Spreading key is a warning in dev. In a future release, we will not\n      // remove a spread key from the props object. (But we'll still warn.) We'll\n      // always pass the object straight through.\n      props = config;\n    } else {\n      // We need to remove reserved props (key, prop, ref). Create a fresh props\n      // object and copy over all the non-reserved props. We don't use `delete`\n      // because in V8 it will deopt the object to dictionary mode.\n      props = {};\n      for (const propName in config) {\n        // Skip over reserved prop names\n        if (propName !== 'key') {\n          props[propName] = config[propName];\n        }\n      }\n    }\n\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    return ReactElement(\n      type,\n      key,\n      self,\n      source,\n      getOwner(),\n      props,\n      debugStack,\n      debugTask,\n    );\n  }\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n  }\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const clonedElement = ReactElement(\n    oldElement.type,\n    newKey,\n    undefined,\n    undefined,\n    !__DEV__ ? undefined : oldElement._owner,\n    oldElement.props,\n    __DEV__ && oldElement._debugStack,\n    __DEV__ && oldElement._debugTask,\n  );\n  if (__DEV__) {\n    // The cloned element should inherit the original element's key validation.\n    if (oldElement._store) {\n      clonedElement._store.validated = oldElement._store.validated;\n    }\n  }\n  return clonedElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = !__DEV__ ? undefined : element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      owner = __DEV__ ? getOwner() : undefined;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // ...and maybe these, too, though we currently rely on them for\n        // warnings and debug information in dev. Need to decide if we're OK\n        // with dropping them. In the jsx() runtime it's not an issue because\n        // the data gets passed as separate arguments instead of props, but\n        // it would be nice to stop relying on them entirely so we can drop\n        // them from the internal Fiber field.\n        propName !== '__self' &&\n        propName !== '__source' &&\n        // Undefined `ref` is ignored by cloneElement. We treat it the same as\n        // if the property were missing. This is mostly for\n        // backwards compatibility.\n        !(propName === 'ref' && config.ref === undefined)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  const clonedElement = ReactElement(\n    element.type,\n    key,\n    undefined,\n    undefined,\n    owner,\n    props,\n    __DEV__ && element._debugStack,\n    __DEV__ && element._debugTask,\n  );\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], clonedElement.type);\n  }\n\n  return clonedElement;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    // With owner stacks is, no warnings happens. All we do is\n    // mark elements as being in a valid static child position so they\n    // don't need keys.\n    if (isValidElement(node)) {\n      if (node._store) {\n        node._store.validated = 1;\n      }\n    }\n  }\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport {REACT_FRAGMENT_TYPE} from 'shared/ReactSymbols';\nimport {\n  jsxProd,\n  jsxProdSignatureRunningInDevWithDynamicChildren,\n  jsxProdSignatureRunningInDevWithStaticChildren,\n  jsxDEV as _jsxDEV,\n} from './ReactJSXElement';\n\nconst jsx: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithDynamicChildren\n  : jsxProd;\n// we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\nconst jsxs: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithStaticChildren\n  : jsxProd;\n\nconst jsxDEV: any = __DEV__ ? _jsxDEV : undefined;\n\nexport {REACT_FRAGMENT_TYPE as Fragment, jsx, jsxs, jsxDEV};\n"],"names":["REACT_ELEMENT_TYPE","Symbol","for","REACT_FRAGMENT_TYPE","getOwner","hasValidKey","config","key","undefined","ReactElement","type","self","source","owner","props","debugStack","debugTask","refProp","ref","element","$$typeof","jsxProd","maybeKey","propName","jsx","jsxs"],"mappings":";;AAiBO,MAAMA,kBAAkB,GAC3BC,MAAM,CAACC,GAAG,CAAC,4BAA4B,CAAC,CACf,CAAA;AAEtB,MAAMC,mBAAmB,GAAWF,MAAM,CAACC,GAAG,CAAC,gBAAgB;;AC2BtE,SAASE,QAAQA,GAAG;AAQlB,EAAA,OAAO,IAAI,CAAA;AACb,CAAA;AA0CA,SAASC,WAAWA,CAACC,MAAM,EAAE;AAS3B,EAAA,OAAOA,MAAM,CAACC,GAAG,KAAKC,SAAS,CAAA;AACjC,CAAA;;AA2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CACnBC,IAAI,EACJH,GAAG,EACHI,IAAI,EACJC,MAAM,EACNC,KAAK,EACLC,KAAK,EACLC,UAAU,EACVC,SAAS,EACT;AACA;AACA;AACA;AACA;AACA,EAAA,MAAMC,OAAO,GAAGH,KAAK,CAACI,GAAG,CAAA;;AAEzB;AACA;EACA,MAAMA,GAAG,GAAGD,OAAO,KAAKT,SAAS,GAAGS,OAAO,GAAG,IAAI,CAAA;AAElD,EAAA,IAAIE,OAAO,CAAA;AACX,EA2CO;AACL;AACAA,IAAAA,OAAO,GAAG;AACR;AACAC,MAAAA,QAAQ,EAAEpB,kBAAkB;AAE5B;MACAU,IAAI;MACJH,GAAG;MACHW,GAAG;AAEHJ,MAAAA,KAAAA;KACD,CAAA;AACH,GAAA;AA4CA,EAAA,OAAOK,OAAO,CAAA;AAChB,CAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASE,OAAOA,CAACX,IAAI,EAAEJ,MAAM,EAAEgB,QAAQ,EAAE;EAC9C,IAAIf,GAAG,GAAG,IAAI,CAAA;;AAEd;AACA;AACA;AACA;AACA;AACA;EACA,IAAIe,QAAQ,KAAKd,SAAS,EAAE;IAI1BD,GAAG,GAAG,EAAE,GAAGe,QAAQ,CAAA;AACrB,GAAA;AAEA,EAAA,IAAIjB,WAAW,CAACC,MAAM,CAAC,EAAE;AAIvBC,IAAAA,GAAG,GAAG,EAAE,GAAGD,MAAM,CAACC,GAAG,CAAA;AACvB,GAAA;AAEA,EAAA,IAAIO,KAAK,CAAA;AACT,EAAA,IAAI,EAAE,KAAK,IAAIR,MAAM,CAAC,EAAE;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAQ,IAAAA,KAAK,GAAGR,MAAM,CAAA;AAChB,GAAC,MAAM;AACL;AACA;AACA;IACAQ,KAAK,GAAG,EAAE,CAAA;AACV,IAAA,KAAK,MAAMS,QAAQ,IAAIjB,MAAM,EAAE;AAC7B;MACA,IAAIiB,QAAQ,KAAK,KAAK,EAAE;AACtBT,QAAAA,KAAK,CAACS,QAAQ,CAAC,GAAGjB,MAAM,CAACiB,QAAQ,CAAC,CAAA;AACpC,OAAA;AACF,KAAA;AACF,GAAA;AAEA,EAAA,OAAOd,YAAY,CACjBC,IAAI,EACJH,GAAG,EACHC,SAAS,EACTA,SAAS,EACTJ,QAAQ,EAAE,EACVU,KAGF,CAAC,CAAA;AACH;;ACxVA,MAAMU,GAAG,GAELH,QAAO;AACX;AACA;AACA,MAAMI,IAAI,GAENJ;;;;;;"}
\ No newline at end of file
diff --git a/cjs/react-jsx-runtime.react-server.development.js b/cjs/react-jsx-runtime.react-server.development.js
index 8d8c4f37ad3088b6e061a48adac7cd85c25da8e9..81c9402987833e6856e78d4b970dbc4e8b868473 100644
--- a/cjs/react-jsx-runtime.react-server.development.js
+++ b/cjs/react-jsx-runtime.react-server.development.js
@@ -1,385 +1,591 @@
-/**
- * @license React
- * react-jsx-runtime.react-server.development.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
+'use strict';
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
-  (function () {
-    function getComponentNameFromType(type) {
-      if (null == type) return null;
-      if ("function" === typeof type)
-        return type.$$typeof === REACT_CLIENT_REFERENCE
-          ? null
-          : type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
-      switch (type) {
-        case REACT_FRAGMENT_TYPE:
-          return "Fragment";
-        case REACT_PROFILER_TYPE:
-          return "Profiler";
-        case REACT_STRICT_MODE_TYPE:
-          return "StrictMode";
-        case REACT_SUSPENSE_TYPE:
-          return "Suspense";
-        case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
-        case REACT_ACTIVITY_TYPE:
-          return "Activity";
-      }
-      if ("object" === typeof type)
-        switch (
-          ("number" === typeof type.tag &&
-            console.error(
-              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
-            ),
-          type.$$typeof)
-        ) {
-          case REACT_PORTAL_TYPE:
-            return "Portal";
-          case REACT_CONTEXT_TYPE:
-            return (type.displayName || "Context") + ".Provider";
-          case REACT_CONSUMER_TYPE:
-            return (type._context.displayName || "Context") + ".Consumer";
-          case REACT_FORWARD_REF_TYPE:
-            var innerType = type.render;
-            type = type.displayName;
-            type ||
-              ((type = innerType.displayName || innerType.name || ""),
-              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
-            return type;
-          case REACT_MEMO_TYPE:
-            return (
-              (innerType = type.displayName || null),
-              null !== innerType
-                ? innerType
-                : getComponentNameFromType(type.type) || "Memo"
-            );
-          case REACT_LAZY_TYPE:
-            innerType = type._payload;
-            type = type._init;
-            try {
-              return getComponentNameFromType(type(innerType));
-            } catch (x) {}
-        }
+var React = require('react');
+
+// -----------------------------------------------------------------------------
+// Land or remove (zero effort)
+//
+// Flags that can likely be deleted or landed without consequences
+// -----------------------------------------------------------------------------
+
+var ownerStackLimit = 1e4;
+
+var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+var REACT_PORTAL_TYPE = Symbol.for('react.portal');
+var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
+var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
+var REACT_CONSUMER_TYPE = Symbol.for('react.consumer');
+var REACT_CONTEXT_TYPE = Symbol.for('react.context');
+var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
+var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
+var REACT_MEMO_TYPE = Symbol.for('react.memo');
+var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+var REACT_ACTIVITY_TYPE = Symbol.for('react.activity');
+var REACT_VIEW_TRANSITION_TYPE = Symbol.for('react.view_transition');
+
+// Keep in sync with react-reconciler/getComponentNameFromFiber
+function getWrappedName(outerType, innerType, wrapperName) {
+  var displayName = outerType.displayName;
+  if (displayName) {
+    return displayName;
+  }
+  var functionName = innerType.displayName || innerType.name || '';
+  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
+}
+
+// Keep in sync with react-reconciler/getComponentNameFromFiber
+function getContextName(type) {
+  return type.displayName || 'Context';
+}
+var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
+
+// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
+function getComponentNameFromType(type) {
+  if (type == null) {
+    // Host root, text node or just invalid type.
+    return null;
+  }
+  if (typeof type === 'function') {
+    if (type.$$typeof === REACT_CLIENT_REFERENCE) {
+      // TODO: Create a convention for naming client references with debug info.
       return null;
     }
-    function testStringCoercion(value) {
-      return "" + value;
-    }
-    function checkKeyStringCoercion(value) {
-      try {
-        testStringCoercion(value);
-        var JSCompiler_inline_result = !1;
-      } catch (e) {
-        JSCompiler_inline_result = !0;
+    return type.displayName || type.name || null;
+  }
+  if (typeof type === 'string') {
+    return type;
+  }
+  switch (type) {
+    case REACT_FRAGMENT_TYPE:
+      return 'Fragment';
+    case REACT_PROFILER_TYPE:
+      return 'Profiler';
+    case REACT_STRICT_MODE_TYPE:
+      return 'StrictMode';
+    case REACT_SUSPENSE_TYPE:
+      return 'Suspense';
+    case REACT_SUSPENSE_LIST_TYPE:
+      return 'SuspenseList';
+    case REACT_ACTIVITY_TYPE:
+      return 'Activity';
+    case REACT_VIEW_TRANSITION_TYPE:
+      {
+        return 'ViewTransition';
       }
-      if (JSCompiler_inline_result) {
-        JSCompiler_inline_result = console;
-        var JSCompiler_temp_const = JSCompiler_inline_result.error;
-        var JSCompiler_inline_result$jscomp$0 =
-          ("function" === typeof Symbol &&
-            Symbol.toStringTag &&
-            value[Symbol.toStringTag]) ||
-          value.constructor.name ||
-          "Object";
-        JSCompiler_temp_const.call(
-          JSCompiler_inline_result,
-          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
-          JSCompiler_inline_result$jscomp$0
-        );
-        return testStringCoercion(value);
+  }
+  if (typeof type === 'object') {
+    {
+      if (typeof type.tag === 'number') {
+        console.error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
       }
     }
-    function getTaskName(type) {
-      if (type === REACT_FRAGMENT_TYPE) return "<>";
-      if (
-        "object" === typeof type &&
-        null !== type &&
-        type.$$typeof === REACT_LAZY_TYPE
-      )
-        return "<...>";
-      try {
-        var name = getComponentNameFromType(type);
-        return name ? "<" + name + ">" : "<...>";
-      } catch (x) {
-        return "<...>";
-      }
+    switch (type.$$typeof) {
+      case REACT_PORTAL_TYPE:
+        return 'Portal';
+      case REACT_CONTEXT_TYPE:
+        var context = type;
+        return getContextName(context);
+      case REACT_CONSUMER_TYPE:
+        var consumer = type;
+        return getContextName(consumer._context) + '.Consumer';
+      case REACT_FORWARD_REF_TYPE:
+        return getWrappedName(type, type.render, 'ForwardRef');
+      case REACT_MEMO_TYPE:
+        var outerName = type.displayName || null;
+        if (outerName !== null) {
+          return outerName;
+        }
+        return getComponentNameFromType(type.type) || 'Memo';
+      case REACT_LAZY_TYPE:
+        {
+          var lazyComponent = type;
+          var payload = lazyComponent._payload;
+          var init = lazyComponent._init;
+          try {
+            return getComponentNameFromType(init(payload));
+          } catch (x) {
+            return null;
+          }
+        }
+    }
+  }
+  return null;
+}
+
+var ReactSharedInternalsServer =
+// $FlowFixMe: It's defined in the one we resolve to.
+React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+if (!ReactSharedInternalsServer) {
+  throw new Error('The "react" package in this environment is not configured correctly. ' + 'The "react-server" condition must be enabled in any environment that ' + 'runs React Server Components.');
+}
+
+// $FlowFixMe[method-unbinding]
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+
+/*
+ * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol
+ * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
+ *
+ * The functions in this module will throw an easier-to-understand,
+ * easier-to-debug exception with a clear errors message message explaining the
+ * problem. (Instead of a confusing exception thrown inside the implementation
+ * of the `value` object).
+ */
+
+// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
+function typeName(value) {
+  {
+    // toStringTag is needed for namespaced types like Temporal.Instant
+    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
+    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
+    // $FlowFixMe[incompatible-return]
+    return type;
+  }
+}
+
+// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
+function willCoercionThrow(value) {
+  {
+    try {
+      testStringCoercion(value);
+      return false;
+    } catch (e) {
+      return true;
     }
-    function getOwner() {
-      var dispatcher = ReactSharedInternalsServer.A;
-      return null === dispatcher ? null : dispatcher.getOwner();
+  }
+}
+
+/** @noinline */
+function testStringCoercion(value) {
+  // If you ended up here by following an exception call stack, here's what's
+  // happened: you supplied an object or symbol value to React (as a prop, key,
+  // DOM attribute, CSS property, string ref, etc.) and when React tried to
+  // coerce it to a string using `'' + value`, an exception was thrown.
+  //
+  // The most common types that will cause this exception are `Symbol` instances
+  // and Temporal objects like `Temporal.Instant`. But any object that has a
+  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
+  // exception. (Library authors do this to prevent users from using built-in
+  // numeric operators like `+` or comparison operators like `>=` because custom
+  // methods are needed to perform accurate arithmetic or comparison.)
+  //
+  // To fix the problem, coerce this object or symbol value to a string before
+  // passing it to React. The most reliable way is usually `String(value)`.
+  //
+  // To find which value is throwing, check the browser or debugger console.
+  // Before this exception was thrown, there should be `console.error` output
+  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
+  // problem and how that type was used: key, atrribute, input value prop, etc.
+  // In most cases, this console output also shows the component and its
+  // ancestor components where the exception happened.
+  //
+  // eslint-disable-next-line react-internal/safe-string-coercion
+  return '' + value;
+}
+function checkKeyStringCoercion(value) {
+  {
+    if (willCoercionThrow(value)) {
+      console.error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));
+      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
     }
-    function UnknownOwner() {
-      return Error("react-stack-top-frame");
+  }
+}
+
+var isArrayImpl = Array.isArray;
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+var createTask =
+// eslint-disable-next-line react-internal/no-production-logging
+console.createTask ?
+// eslint-disable-next-line react-internal/no-production-logging
+console.createTask : function () {
+  return null;
+};
+function getTaskName(type) {
+  if (type === REACT_FRAGMENT_TYPE) {
+    return '<>';
+  }
+  if (typeof type === 'object' && type !== null && type.$$typeof === REACT_LAZY_TYPE) {
+    // We don't want to eagerly initialize the initializer in DEV mode so we can't
+    // call it to extract the type so we don't know the type of this component.
+    return '<...>';
+  }
+  try {
+    var name = getComponentNameFromType(type);
+    return name ? '<' + name + '>' : '<...>';
+  } catch (x) {
+    return '<...>';
+  }
+}
+function getOwner() {
+  {
+    var dispatcher = ReactSharedInternalsServer.A;
+    if (dispatcher === null) {
+      return null;
     }
-    function hasValidKey(config) {
-      if (hasOwnProperty.call(config, "key")) {
-        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
-        if (getter && getter.isReactWarning) return !1;
+    return dispatcher.getOwner();
+  }
+}
+
+/** @noinline */
+function UnknownOwner() {
+  /** @noinline */
+  return function () {
+    return Error('react-stack-top-frame');
+  }();
+}
+var createFakeCallStack = {
+  react_stack_bottom_frame: function (callStackForError) {
+    return callStackForError();
+  }
+};
+var specialPropKeyWarningShown;
+var didWarnAboutElementRef;
+var unknownOwnerDebugStack;
+var unknownOwnerDebugTask;
+{
+  didWarnAboutElementRef = {};
+
+  // We use this technique to trick minifiers to preserve the function name.
+  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(createFakeCallStack, UnknownOwner)();
+  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
+}
+function hasValidKey(config) {
+  {
+    if (hasOwnProperty.call(config, 'key')) {
+      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
+      if (getter && getter.isReactWarning) {
+        return false;
       }
-      return void 0 !== config.key;
     }
-    function defineKeyPropWarningGetter(props, displayName) {
-      function warnAboutAccessingKey() {
-        specialPropKeyWarningShown ||
-          ((specialPropKeyWarningShown = !0),
-          console.error(
-            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
-            displayName
-          ));
+  }
+  return config.key !== undefined;
+}
+function defineKeyPropWarningGetter(props, displayName) {
+  {
+    var warnAboutAccessingKey = function () {
+      if (!specialPropKeyWarningShown) {
+        specialPropKeyWarningShown = true;
+        console.error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://react.dev/link/special-props)', displayName);
       }
-      warnAboutAccessingKey.isReactWarning = !0;
-      Object.defineProperty(props, "key", {
-        get: warnAboutAccessingKey,
-        configurable: !0
-      });
-    }
-    function elementRefGetterWithDeprecationWarning() {
-      var componentName = getComponentNameFromType(this.type);
-      didWarnAboutElementRef[componentName] ||
-        ((didWarnAboutElementRef[componentName] = !0),
-        console.error(
-          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
-        ));
-      componentName = this.props.ref;
-      return void 0 !== componentName ? componentName : null;
+    };
+    warnAboutAccessingKey.isReactWarning = true;
+    Object.defineProperty(props, 'key', {
+      get: warnAboutAccessingKey,
+      configurable: true
+    });
+  }
+}
+function elementRefGetterWithDeprecationWarning() {
+  {
+    var componentName = getComponentNameFromType(this.type);
+    if (!didWarnAboutElementRef[componentName]) {
+      didWarnAboutElementRef[componentName] = true;
+      console.error('Accessing element.ref was removed in React 19. ref is now a ' + 'regular prop. It will be removed from the JSX Element ' + 'type in a future release.');
     }
-    function ReactElement(
-      type,
-      key,
-      self,
-      source,
-      owner,
-      props,
-      debugStack,
-      debugTask
-    ) {
-      self = props.ref;
-      type = {
-        $$typeof: REACT_ELEMENT_TYPE,
-        type: type,
-        key: key,
-        props: props,
-        _owner: owner
-      };
-      null !== (void 0 !== self ? self : null)
-        ? Object.defineProperty(type, "ref", {
-            enumerable: !1,
-            get: elementRefGetterWithDeprecationWarning
-          })
-        : Object.defineProperty(type, "ref", { enumerable: !1, value: null });
-      type._store = {};
-      Object.defineProperty(type._store, "validated", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: 0
+
+    // An undefined `element.ref` is coerced to `null` for
+    // backwards compatibility.
+    var refProp = this.props.ref;
+    return refProp !== undefined ? refProp : null;
+  }
+}
+
+/**
+ * Factory method to create a new React element. This no longer adheres to
+ * the class pattern, so do not use new to call it. Also, instanceof check
+ * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check
+ * if something is a React Element.
+ *
+ * @param {*} type
+ * @param {*} props
+ * @param {*} key
+ * @param {string|object} ref
+ * @param {*} owner
+ * @param {*} self A *temporary* helper to detect places where `this` is
+ * different from the `owner` when React.createElement is called, so that we
+ * can warn. We want to get rid of owner and replace string `ref`s with arrow
+ * functions, and as long as `this` and owner are the same, there will be no
+ * change in behavior.
+ * @param {*} source An annotation object (added by a transpiler or otherwise)
+ * indicating filename, line number, and/or other information.
+ * @internal
+ */
+function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
+  // Ignore whatever was passed as the ref argument and treat `props.ref` as
+  // the source of truth. The only thing we use this for is `element.ref`,
+  // which will log a deprecation warning on access. In the next release, we
+  // can remove `element.ref` as well as the `ref` argument.
+  var refProp = props.ref;
+
+  // An undefined `element.ref` is coerced to `null` for
+  // backwards compatibility.
+  var ref = refProp !== undefined ? refProp : null;
+  var element;
+  {
+    // In dev, make `ref` a non-enumerable property with a warning. It's non-
+    // enumerable so that test matchers and serializers don't access it and
+    // trigger the warning.
+    //
+    // `ref` will be removed from the element completely in a future release.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      // Built-in properties that belong on the element
+      type: type,
+      key: key,
+      props: props,
+      // Record the component responsible for creating this element.
+      _owner: owner
+    };
+    if (ref !== null) {
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
+        get: elementRefGetterWithDeprecationWarning
       });
-      Object.defineProperty(type, "_debugInfo", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
+    } else {
+      // Don't warn on access if a ref is not given. This reduces false
+      // positives in cases where a test serializer uses
+      // getOwnPropertyDescriptors to compare objects, like Jest does, which is
+      // a problem because it bypasses non-enumerability.
+      //
+      // So unfortunately this will trigger a false positive warning in Jest
+      // when the diff is printed:
+      //
+      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);
+      //
+      // A bit sketchy, but this is what we've done for the `props.key` and
+      // `props.ref` accessors for years, which implies it will be good enough
+      // for `element.ref`, too. Let's see if anyone complains.
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
         value: null
       });
-      Object.defineProperty(type, "_debugStack", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: debugStack
-      });
-      Object.defineProperty(type, "_debugTask", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: debugTask
+    }
+  }
+  {
+    // The validation flag is currently mutative. We put it on
+    // an external backing store so that we can freeze the whole object.
+    // This can be replaced with a WeakMap once they are implemented in
+    // commonly used development environments.
+    element._store = {};
+
+    // To make comparing ReactElements easier for testing purposes, we make
+    // the validation flag non-enumerable (where possible, which should
+    // include every environment we run tests in), so the test framework
+    // ignores it.
+    Object.defineProperty(element._store, 'validated', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: 0
+    });
+    // debugInfo contains Server Component debug information.
+    Object.defineProperty(element, '_debugInfo', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: null
+    });
+    Object.defineProperty(element, '_debugStack', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugStack
+    });
+    Object.defineProperty(element, '_debugTask', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugTask
+    });
+    if (Object.freeze) {
+      Object.freeze(element.props);
+      Object.freeze(element);
+    }
+  }
+  return element;
+}
+
+// While `jsxDEV` should never be called when running in production, we do
+// support `jsx` and `jsxs` when running in development. This supports the case
+// where a third-party dependency ships code that was compiled for production;
+// we want to still provide warnings in development.
+//
+// So these functions are the _dev_ implementations of the _production_
+// API signatures.
+//
+// Since these functions are dev-only, it's ok to add an indirection here. They
+// only exist to provide different versions of `isStaticChildren`. (We shouldn't
+// use this pattern for the prod versions, though, because it will add an call
+// frame.)
+function jsxProdSignatureRunningInDevWithDynamicChildren(type, config, maybeKey, source, self) {
+  {
+    var isStaticChildren = false;
+    var trackActualOwner = ReactSharedInternalsServer.recentlyCreatedOwnerStacks++ < ownerStackLimit;
+    return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, (trackActualOwner ? Error('react-stack-top-frame') : unknownOwnerDebugStack), (trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask));
+  }
+}
+function jsxProdSignatureRunningInDevWithStaticChildren(type, config, maybeKey, source, self) {
+  {
+    var isStaticChildren = true;
+    var trackActualOwner = ReactSharedInternalsServer.recentlyCreatedOwnerStacks++ < ownerStackLimit;
+    return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, (trackActualOwner ? Error('react-stack-top-frame') : unknownOwnerDebugStack), (trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask));
+  }
+}
+var didWarnAboutKeySpread = {};
+
+/**
+ * https://github.com/reactjs/rfcs/pull/107
+ * @param {*} type
+ * @param {object} props
+ * @param {string} key
+ */
+function jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {
+  var trackActualOwner = ReactSharedInternalsServer.recentlyCreatedOwnerStacks++ < ownerStackLimit;
+  return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, (trackActualOwner ? Error('react-stack-top-frame') : unknownOwnerDebugStack), (trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask));
+}
+function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
+  {
+    // We don't warn for invalid element type here because with owner stacks,
+    // we error in the renderer. The renderer is the only one that knows what
+    // types are valid for this particular renderer so we let it error there.
+
+    // Skip key warning if the type isn't valid since our key validation logic
+    // doesn't expect a non-string/function type and can throw confusing
+    // errors. We don't want exception behavior to differ between dev and
+    // prod. (Rendering will throw with a helpful message and as soon as the
+    // type is fixed, the key warnings will appear.)
+    // With owner stacks, we no longer need the type here so this comment is
+    // no longer true. Which is why we can run this even for invalid types.
+    var children = config.children;
+    if (children !== undefined) {
+      if (isStaticChildren) {
+        if (isArray(children)) {
+          for (var i = 0; i < children.length; i++) {
+            validateChildKeys(children[i]);
+          }
+          if (Object.freeze) {
+            Object.freeze(children);
+          }
+        } else {
+          console.error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
+        }
+      } else {
+        validateChildKeys(children);
+      }
+    }
+
+    // Warn about key spread regardless of whether the type is valid.
+    if (hasOwnProperty.call(config, 'key')) {
+      var componentName = getComponentNameFromType(type);
+      var keys = Object.keys(config).filter(function (k) {
+        return k !== 'key';
       });
-      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
-      return type;
+      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';
+      if (!didWarnAboutKeySpread[componentName + beforeExample]) {
+        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';
+        console.error('A props object containing a "key" prop is being spread into JSX:\n' + '  let props = %s;\n' + '  <%s {...props} />\n' + 'React keys must be passed directly to JSX without using spread:\n' + '  let props = %s;\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);
+        didWarnAboutKeySpread[componentName + beforeExample] = true;
+      }
+    }
+    var key = null;
+
+    // Currently, key can be spread in as a prop. This causes a potential
+    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
+    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
+    // but as an intermediary step, we will use jsxDEV for everything except
+    // <div {...props} key="Hi" />, because we aren't currently able to tell if
+    // key is explicitly declared to be undefined or not.
+    if (maybeKey !== undefined) {
+      {
+        checkKeyStringCoercion(maybeKey);
+      }
+      key = '' + maybeKey;
     }
-    function jsxDEVImpl(
-      type,
-      config,
-      maybeKey,
-      isStaticChildren,
-      source,
-      self,
-      debugStack,
-      debugTask
-    ) {
-      var children = config.children;
-      if (void 0 !== children)
-        if (isStaticChildren)
-          if (isArrayImpl(children)) {
-            for (
-              isStaticChildren = 0;
-              isStaticChildren < children.length;
-              isStaticChildren++
-            )
-              validateChildKeys(children[isStaticChildren]);
-            Object.freeze && Object.freeze(children);
-          } else
-            console.error(
-              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
-            );
-        else validateChildKeys(children);
-      if (hasOwnProperty.call(config, "key")) {
-        children = getComponentNameFromType(type);
-        var keys = Object.keys(config).filter(function (k) {
-          return "key" !== k;
-        });
-        isStaticChildren =
-          0 < keys.length
-            ? "{key: someKey, " + keys.join(": ..., ") + ": ...}"
-            : "{key: someKey}";
-        didWarnAboutKeySpread[children + isStaticChildren] ||
-          ((keys =
-            0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}"),
-          console.error(
-            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
-            isStaticChildren,
-            children,
-            keys,
-            children
-          ),
-          (didWarnAboutKeySpread[children + isStaticChildren] = !0));
+    if (hasValidKey(config)) {
+      {
+        checkKeyStringCoercion(config.key);
       }
-      children = null;
-      void 0 !== maybeKey &&
-        (checkKeyStringCoercion(maybeKey), (children = "" + maybeKey));
-      hasValidKey(config) &&
-        (checkKeyStringCoercion(config.key), (children = "" + config.key));
-      if ("key" in config) {
-        maybeKey = {};
-        for (var propName in config)
-          "key" !== propName && (maybeKey[propName] = config[propName]);
-      } else maybeKey = config;
-      children &&
-        defineKeyPropWarningGetter(
-          maybeKey,
-          "function" === typeof type
-            ? type.displayName || type.name || "Unknown"
-            : type
-        );
-      return ReactElement(
-        type,
-        children,
-        self,
-        source,
-        getOwner(),
-        maybeKey,
-        debugStack,
-        debugTask
-      );
+      key = '' + config.key;
     }
-    function validateChildKeys(node) {
-      "object" === typeof node &&
-        null !== node &&
-        node.$$typeof === REACT_ELEMENT_TYPE &&
-        node._store &&
-        (node._store.validated = 1);
+    var props;
+    if (!('key' in config)) {
+      // If key was not spread in, we can reuse the original props object. This
+      // only works for `jsx`, not `createElement`, because `jsx` is a compiler
+      // target and the compiler always passes a new object. For `createElement`,
+      // we can't assume a new object is passed every time because it can be
+      // called manually.
+      //
+      // Spreading key is a warning in dev. In a future release, we will not
+      // remove a spread key from the props object. (But we'll still warn.) We'll
+      // always pass the object straight through.
+      props = config;
+    } else {
+      // We need to remove reserved props (key, prop, ref). Create a fresh props
+      // object and copy over all the non-reserved props. We don't use `delete`
+      // because in V8 it will deopt the object to dictionary mode.
+      props = {};
+      for (var propName in config) {
+        // Skip over reserved prop names
+        if (propName !== 'key') {
+          props[propName] = config[propName];
+        }
+      }
     }
-    var React = require("react"),
-      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
-      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
-    Symbol.for("react.provider");
-    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
-      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
-      ReactSharedInternalsServer =
-        React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
-    if (!ReactSharedInternalsServer)
-      throw Error(
-        'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
-      );
-    var hasOwnProperty = Object.prototype.hasOwnProperty,
-      isArrayImpl = Array.isArray,
-      createTask = console.createTask
-        ? console.createTask
-        : function () {
-            return null;
-          };
-    React = {
-      "react-stack-bottom-frame": function (callStackForError) {
-        return callStackForError();
+    if (key) {
+      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
+      defineKeyPropWarningGetter(props, displayName);
+    }
+    return ReactElement(type, key, self, source, getOwner(), props, debugStack, debugTask);
+  }
+}
+
+/**
+ * Ensure that every element either is passed in a static location, in an
+ * array with an explicit keys property defined, or in an object literal
+ * with valid key property.
+ *
+ * @internal
+ * @param {ReactNode} node Statically passed child of any type.
+ * @param {*} parentType node's parent's type.
+ */
+function validateChildKeys(node, parentType) {
+  {
+    // With owner stacks is, no warnings happens. All we do is
+    // mark elements as being in a valid static child position so they
+    // don't need keys.
+    if (isValidElement(node)) {
+      if (node._store) {
+        node._store.validated = 1;
       }
-    };
-    var specialPropKeyWarningShown;
-    var didWarnAboutElementRef = {};
-    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(
-      React,
-      UnknownOwner
-    )();
-    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
-    var didWarnAboutKeySpread = {};
-    exports.Fragment = REACT_FRAGMENT_TYPE;
-    exports.jsx = function (type, config, maybeKey, source, self) {
-      var trackActualOwner =
-        1e4 > ReactSharedInternalsServer.recentlyCreatedOwnerStacks++;
-      return jsxDEVImpl(
-        type,
-        config,
-        maybeKey,
-        !1,
-        source,
-        self,
-        trackActualOwner
-          ? Error("react-stack-top-frame")
-          : unknownOwnerDebugStack,
-        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
-      );
-    };
-    exports.jsxDEV = function (
-      type,
-      config,
-      maybeKey,
-      isStaticChildren,
-      source,
-      self
-    ) {
-      var trackActualOwner =
-        1e4 > ReactSharedInternalsServer.recentlyCreatedOwnerStacks++;
-      return jsxDEVImpl(
-        type,
-        config,
-        maybeKey,
-        isStaticChildren,
-        source,
-        self,
-        trackActualOwner
-          ? Error("react-stack-top-frame")
-          : unknownOwnerDebugStack,
-        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
-      );
-    };
-    exports.jsxs = function (type, config, maybeKey, source, self) {
-      var trackActualOwner =
-        1e4 > ReactSharedInternalsServer.recentlyCreatedOwnerStacks++;
-      return jsxDEVImpl(
-        type,
-        config,
-        maybeKey,
-        !0,
-        source,
-        self,
-        trackActualOwner
-          ? Error("react-stack-top-frame")
-          : unknownOwnerDebugStack,
-        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
-      );
-    };
-  })();
+    }
+  }
+}
+
+/**
+ * Verifies the object is a ReactElement.
+ * See https://reactjs.org/docs/react-api.html#isvalidelement
+ * @param {?object} object
+ * @return {boolean} True if `object` is a ReactElement.
+ * @final
+ */
+function isValidElement(object) {
+  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
+}
+
+var jsx = jsxProdSignatureRunningInDevWithDynamicChildren ;
+// we may want to special case jsxs internally to take advantage of static children.
+// for now we can ship identical prod functions
+var jsxs = jsxProdSignatureRunningInDevWithStaticChildren ;
+var jsxDEV = jsxDEV$1 ;
+
+exports.Fragment = REACT_FRAGMENT_TYPE;
+exports.jsx = jsx;
+exports.jsxDEV = jsxDEV;
+exports.jsxs = jsxs;
+//# sourceMappingURL=react-jsx-runtime.react-server.development.js.map
diff --git a/cjs/react-jsx-runtime.react-server.development.js.map b/cjs/react-jsx-runtime.react-server.development.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..d3547d9759ced5862d8398ce88192704207460ea
--- /dev/null
+++ b/cjs/react-jsx-runtime.react-server.development.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react-jsx-runtime.react-server.development.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactFeatureFlags.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/getComponentNameFromType.js","/Users/liuhao/maodun/react-source-debug/react/packages/react-server/src/ReactSharedInternalsServer.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/hasOwnProperty.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/CheckStringCoercion.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/isArray.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXElement.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXServer.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n */\n\n// -----------------------------------------------------------------------------\n// Land or remove (zero effort)\n//\n// Flags that can likely be deleted or landed without consequences\n// -----------------------------------------------------------------------------\n\n// None\n\n// -----------------------------------------------------------------------------\n// Killswitch\n//\n// Flags that exist solely to turn off a change in case it causes a regression\n// when it rolls out to prod. We should remove these as soon as possible.\n// -----------------------------------------------------------------------------\n\nexport const enableHydrationLaneScheduling = true;\n\n// -----------------------------------------------------------------------------\n// Land or remove (moderate effort)\n//\n// Flags that can be probably deleted or landed, but might require extra effort\n// like migrating internal callers or performance testing.\n// -----------------------------------------------------------------------------\n\n// TODO: Finish rolling out in www\nexport const favorSafetyOverHydrationPerf = true;\n\n// Need to remove didTimeout argument from Scheduler before landing\nexport const disableSchedulerTimeoutInWorkLoop = false;\n\n// -----------------------------------------------------------------------------\n// Slated for removal in the future (significant effort)\n//\n// These are experiments that didn't work out, and never shipped, but we can't\n// delete from the codebase until we migrate internal callers.\n// -----------------------------------------------------------------------------\n\n// Add a callback property to suspense to notify which promises are currently\n// in the update queue. This allows reporting and tracing of what is causing\n// the user to see a loading state.\n//\n// Also allows hydration callbacks to fire when a dehydrated boundary gets\n// hydrated or deleted.\n//\n// This will eventually be replaced by the Transition Tracing proposal.\nexport const enableSuspenseCallback = false;\n\n// Experimental Scope support.\nexport const enableScopeAPI = false;\n\n// Experimental Create Event Handle API.\nexport const enableCreateEventHandleAPI = false;\n\n// Support legacy Primer support on internal FB www\nexport const enableLegacyFBSupport = false;\n\n// -----------------------------------------------------------------------------\n// Ongoing experiments\n//\n// These are features that we're either actively exploring or are reasonably\n// likely to include in an upcoming release.\n// -----------------------------------------------------------------------------\n\n// Yield to the browser event loop and not just the scheduler event loop before passive effects.\n// Fix gated tests that fail with this flag enabled before turning it back on.\nexport const enableYieldingBeforePassive = false;\n\n// Experiment to intentionally yield less to block high framerate animations.\nexport const enableThrottledScheduling = false;\n\nexport const enableLegacyCache = __EXPERIMENTAL__;\n\nexport const enableAsyncIterableChildren = __EXPERIMENTAL__;\n\nexport const enableTaint = __EXPERIMENTAL__;\n\nexport const enablePostpone = __EXPERIMENTAL__;\n\nexport const enableHalt = __EXPERIMENTAL__;\n\nexport const enableViewTransition = __EXPERIMENTAL__;\n\nexport const enableGestureTransition = __EXPERIMENTAL__;\n\nexport const enableScrollEndPolyfill = __EXPERIMENTAL__;\n\nexport const enableSuspenseyImages = false;\n\nexport const enableFizzBlockingRender = __EXPERIMENTAL__; // rel=\"expect\"\n\nexport const enableSrcObject = __EXPERIMENTAL__;\n\nexport const enableHydrationChangeEvent = __EXPERIMENTAL__;\n\nexport const enableDefaultTransitionIndicator = __EXPERIMENTAL__;\n\n/**\n * Switches Fiber creation to a simple object instead of a constructor.\n */\nexport const enableObjectFiber = false;\n\nexport const enableTransitionTracing = false;\n\n// FB-only usage. The new API has different semantics.\nexport const enableLegacyHidden = false;\n\n// Enables unstable_avoidThisFallback feature in Fiber\nexport const enableSuspenseAvoidThisFallback = false;\n\nexport const enableCPUSuspense = __EXPERIMENTAL__;\n\n// Test this at Meta before enabling.\nexport const enableNoCloningMemoCache = false;\n\nexport const enableUseEffectEventHook = __EXPERIMENTAL__;\n\n// Test in www before enabling in open source.\n// Enables DOM-server to stream its instruction set as data-attributes\n// (handled with an MutationObserver) instead of inline-scripts\nexport const enableFizzExternalRuntime = __EXPERIMENTAL__;\n\nexport const alwaysThrottleRetries = true;\n\nexport const passChildrenWhenCloningPersistedNodes = false;\n\n/**\n * Enables a new Fiber flag used in persisted mode to reduce the number\n * of cloned host components.\n */\nexport const enablePersistedModeClonedFlag = false;\n\nexport const enableEagerAlternateStateNodeCleanup = true;\n\n/**\n * Enables an expiration time for retry lanes to avoid starvation.\n */\nexport const enableRetryLaneExpiration = false;\nexport const retryLaneExpirationMs = 5000;\nexport const syncLaneExpirationMs = 250;\nexport const transitionLaneExpirationMs = 5000;\n\n/**\n * Enables a new error detection for infinite render loops from updates caused\n * by setState or similar outside of the component owning the state.\n */\nexport const enableInfiniteRenderLoopDetection = false;\n\nexport const enableLazyPublicInstanceInFabric = false;\n\nexport const enableFragmentRefs = __EXPERIMENTAL__;\n\n// -----------------------------------------------------------------------------\n// Ready for next major.\n//\n// Alias __NEXT_MAJOR__ to __EXPERIMENTAL__ for easier skimming.\n// -----------------------------------------------------------------------------\n\n// TODO: Anything that's set to `true` in this section should either be cleaned\n// up (if it's on everywhere, including Meta and RN builds) or moved to a\n// different section of this file.\n\n// const __NEXT_MAJOR__ = __EXPERIMENTAL__;\n\n// Renames the internal symbol for elements since they have changed signature/constructor\nexport const renameElementSymbol = true;\n\n/**\n * Enables a fix to run insertion effect cleanup on hidden subtrees.\n */\nexport const enableHiddenSubtreeInsertionEffectCleanup = false;\n\n/**\n * Removes legacy style context defined using static `contextTypes` and consumed with static `childContextTypes`.\n */\nexport const disableLegacyContext = true;\n/**\n * Removes legacy style context just from function components.\n */\nexport const disableLegacyContextForFunctionComponents = true;\n\n// Enable the moveBefore() alternative to insertBefore(). This preserves states of moves.\nexport const enableMoveBefore = false;\n\n// Disabled caching behavior of `react/cache` in client runtimes.\nexport const disableClientCache = true;\n\n// Warn on any usage of ReactTestRenderer\nexport const enableReactTestRendererWarning = true;\n\n// Disables legacy mode\n// This allows us to land breaking changes to remove legacy mode APIs in experimental builds\n// before removing them in stable in the next Major\nexport const disableLegacyMode = true;\n\n// -----------------------------------------------------------------------------\n// Chopping Block\n//\n// Planned feature deprecations and breaking changes. Sorted roughly in order of\n// when we plan to enable them.\n// -----------------------------------------------------------------------------\n\n// -----------------------------------------------------------------------------\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nexport const disableCommentsAsDOMContainers = true;\n\nexport const enableTrustedTypesIntegration = false;\n\n// Prevent the value and checked attributes from syncing with their related\n// DOM properties\nexport const disableInputAttributeSyncing = false;\n\n// Disables children for <textarea> elements\nexport const disableTextareaChildren = false;\n\n// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n\n// Gather advanced timing metrics for Profiler subtrees.\nexport const enableProfilerTimer = __PROFILE__;\n\n// Adds performance.measure() marks using Chrome extensions to allow formatted\n// Component rendering tracks to show up in the Performance tab.\n// This flag will be used for both Server Component and Client Component tracks.\n// All calls should also be gated on enableProfilerTimer.\nexport const enableComponentPerformanceTrack = __EXPERIMENTAL__;\n\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nexport const enableSchedulingProfiler: boolean =\n  !enableComponentPerformanceTrack && __PROFILE__;\n\n// Record durations for commit and passive effects phases.\nexport const enableProfilerCommitHooks = __PROFILE__;\n\n// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nexport const enableProfilerNestedUpdatePhase = __PROFILE__;\n\nexport const enableAsyncDebugInfo = __EXPERIMENTAL__;\n\n// Track which Fiber(s) schedule render work.\nexport const enableUpdaterTracking = __PROFILE__;\n\nexport const ownerStackLimit = 1e4;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {LazyComponent} from 'react/src/ReactLazy';\nimport type {ReactContext, ReactConsumerType} from 'shared/ReactTypes';\n\nimport {\n  REACT_CONTEXT_TYPE,\n  REACT_CONSUMER_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_TRACING_MARKER_TYPE,\n  REACT_VIEW_TRANSITION_TYPE,\n  REACT_ACTIVITY_TYPE,\n} from 'shared/ReactSymbols';\n\nimport {\n  enableTransitionTracing,\n  enableViewTransition,\n} from './ReactFeatureFlags';\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getWrappedName(\n  outerType: mixed,\n  innerType: any,\n  wrapperName: string,\n): string {\n  const displayName = (outerType: any).displayName;\n  if (displayName) {\n    return displayName;\n  }\n  const functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? `${wrapperName}(${functionName})` : wrapperName;\n}\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type: ReactContext<any>) {\n  return type.displayName || 'Context';\n}\n\nconst REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\n// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nexport default function getComponentNameFromType(type: mixed): string | null {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n  if (typeof type === 'function') {\n    if ((type: any).$$typeof === REACT_CLIENT_REFERENCE) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n    return (type: any).displayName || type.name || null;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n    case REACT_ACTIVITY_TYPE:\n      return 'Activity';\n    case REACT_VIEW_TRANSITION_TYPE:\n      if (enableViewTransition) {\n        return 'ViewTransition';\n      }\n    // Fall through\n    case REACT_TRACING_MARKER_TYPE:\n      if (enableTransitionTracing) {\n        return 'TracingMarker';\n      }\n  }\n  if (typeof type === 'object') {\n    if (__DEV__) {\n      if (typeof (type: any).tag === 'number') {\n        console.error(\n          'Received an unexpected object in getComponentNameFromType(). ' +\n            'This is likely a bug in React. Please file an issue.',\n        );\n      }\n    }\n    switch (type.$$typeof) {\n      case REACT_PORTAL_TYPE:\n        return 'Portal';\n      case REACT_CONTEXT_TYPE:\n        const context: ReactContext<any> = (type: any);\n        return getContextName(context);\n      case REACT_CONSUMER_TYPE:\n        const consumer: ReactConsumerType<any> = (type: any);\n        return getContextName(consumer._context) + '.Consumer';\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n      case REACT_MEMO_TYPE:\n        const outerName = (type: any).displayName || null;\n        if (outerName !== null) {\n          return outerName;\n        }\n        return getComponentNameFromType(type.type) || 'Memo';\n      case REACT_LAZY_TYPE: {\n        const lazyComponent: LazyComponent<any, any> = (type: any);\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n        try {\n          return getComponentNameFromType(init(payload));\n        } catch (x) {\n          return null;\n        }\n      }\n    }\n  }\n  return null;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {SharedStateServer} from 'react/src/ReactSharedInternalsServer';\n\nimport * as React from 'react';\n\nconst ReactSharedInternalsServer: SharedStateServer =\n  // $FlowFixMe: It's defined in the one we resolve to.\n  React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n\nif (!ReactSharedInternalsServer) {\n  throw new Error(\n    'The \"react\" package in this environment is not configured correctly. ' +\n      'The \"react-server\" condition must be enabled in any environment that ' +\n      'runs React Server Components.',\n  );\n}\n\nexport default ReactSharedInternalsServer;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// $FlowFixMe[method-unbinding]\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport default hasOwnProperty;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value: mixed): string {\n  if (__DEV__) {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    const hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    const type =\n      (hasToStringTag && (value: any)[Symbol.toStringTag]) ||\n      (value: any).constructor.name ||\n      'Object';\n    // $FlowFixMe[incompatible-return]\n    return type;\n  }\n}\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value: mixed): boolean {\n  if (__DEV__) {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\n/** @noinline */\nfunction testStringCoercion(value: mixed) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + (value: any);\n}\n\nexport function checkAttributeStringCoercion(\n  value: mixed,\n  attributeName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` attribute is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        attributeName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkKeyStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided key is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkPropStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` prop is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkOptionStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` option is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkCSSPropertyStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` CSS property is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkHtmlStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided HTML markup uses a value of unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkFormFieldValueStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'Form field values (value, checked, defaultValue, or defaultChecked props)' +\n          ' must be strings, not %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\ndeclare function isArray(a: mixed): boolean %checks(Array.isArray(a));\n\nconst isArrayImpl = Array.isArray;\n\nfunction isArray(a: mixed): boolean {\n  return isArrayImpl(a);\n}\n\nexport default isArray;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport assign from 'shared/assign';\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\nimport isArray from 'shared/isArray';\nimport {ownerStackLimit} from 'shared/ReactFeatureFlags';\n\nconst createTask =\n  // eslint-disable-next-line react-internal/no-production-logging\n  __DEV__ && console.createTask\n    ? // eslint-disable-next-line react-internal/no-production-logging\n      console.createTask\n    : () => null;\n\nfunction getTaskName(type) {\n  if (type === REACT_FRAGMENT_TYPE) {\n    return '<>';\n  }\n  if (\n    typeof type === 'object' &&\n    type !== null &&\n    type.$$typeof === REACT_LAZY_TYPE\n  ) {\n    // We don't want to eagerly initialize the initializer in DEV mode so we can't\n    // call it to extract the type so we don't know the type of this component.\n    return '<...>';\n  }\n  try {\n    const name = getComponentNameFromType(type);\n    return name ? '<' + name + '>' : '<...>';\n  } catch (x) {\n    return '<...>';\n  }\n}\n\nfunction getOwner() {\n  if (__DEV__) {\n    const dispatcher = ReactSharedInternals.A;\n    if (dispatcher === null) {\n      return null;\n    }\n    return dispatcher.getOwner();\n  }\n  return null;\n}\n\n/** @noinline */\nfunction UnknownOwner() {\n  /** @noinline */\n  return (() => Error('react-stack-top-frame'))();\n}\nconst createFakeCallStack = {\n  react_stack_bottom_frame: function (callStackForError) {\n    return callStackForError();\n  },\n};\n\nlet specialPropKeyWarningShown;\nlet didWarnAboutElementRef;\nlet didWarnAboutOldJSXRuntime;\nlet unknownOwnerDebugStack;\nlet unknownOwnerDebugTask;\n\nif (__DEV__) {\n  didWarnAboutElementRef = {};\n\n  // We use this technique to trick minifiers to preserve the function name.\n  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(\n    createFakeCallStack,\n    UnknownOwner,\n  )();\n  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://react.dev/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction elementRefGetterWithDeprecationWarning() {\n  if (__DEV__) {\n    const componentName = getComponentNameFromType(this.type);\n    if (!didWarnAboutElementRef[componentName]) {\n      didWarnAboutElementRef[componentName] = true;\n      console.error(\n        'Accessing element.ref was removed in React 19. ref is now a ' +\n          'regular prop. It will be removed from the JSX Element ' +\n          'type in a future release.',\n      );\n    }\n\n    // An undefined `element.ref` is coerced to `null` for\n    // backwards compatibility.\n    const refProp = this.props.ref;\n    return refProp !== undefined ? refProp : null;\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nfunction ReactElement(\n  type,\n  key,\n  self,\n  source,\n  owner,\n  props,\n  debugStack,\n  debugTask,\n) {\n  // Ignore whatever was passed as the ref argument and treat `props.ref` as\n  // the source of truth. The only thing we use this for is `element.ref`,\n  // which will log a deprecation warning on access. In the next release, we\n  // can remove `element.ref` as well as the `ref` argument.\n  const refProp = props.ref;\n\n  // An undefined `element.ref` is coerced to `null` for\n  // backwards compatibility.\n  const ref = refProp !== undefined ? refProp : null;\n\n  let element;\n  if (__DEV__) {\n    // In dev, make `ref` a non-enumerable property with a warning. It's non-\n    // enumerable so that test matchers and serializers don't access it and\n    // trigger the warning.\n    //\n    // `ref` will be removed from the element completely in a future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n\n      props,\n\n      // Record the component responsible for creating this element.\n      _owner: owner,\n    };\n    if (ref !== null) {\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        get: elementRefGetterWithDeprecationWarning,\n      });\n    } else {\n      // Don't warn on access if a ref is not given. This reduces false\n      // positives in cases where a test serializer uses\n      // getOwnPropertyDescriptors to compare objects, like Jest does, which is\n      // a problem because it bypasses non-enumerability.\n      //\n      // So unfortunately this will trigger a false positive warning in Jest\n      // when the diff is printed:\n      //\n      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);\n      //\n      // A bit sketchy, but this is what we've done for the `props.key` and\n      // `props.ref` accessors for years, which implies it will be good enough\n      // for `element.ref`, too. Let's see if anyone complains.\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        value: null,\n      });\n    }\n  } else {\n    // In prod, `ref` is a regular property and _owner doesn't exist.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n      ref,\n\n      props,\n    };\n  }\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: 0,\n    });\n    // debugInfo contains Server Component debug information.\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null,\n    });\n    Object.defineProperty(element, '_debugStack', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugStack,\n    });\n    Object.defineProperty(element, '_debugTask', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugTask,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxProd(type, config, maybeKey) {\n  let key = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  let props;\n  if (!('key' in config)) {\n    // If key was not spread in, we can reuse the original props object. This\n    // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n    // target and the compiler always passes a new object. For `createElement`,\n    // we can't assume a new object is passed every time because it can be\n    // called manually.\n    //\n    // Spreading key is a warning in dev. In a future release, we will not\n    // remove a spread key from the props object. (But we'll still warn.) We'll\n    // always pass the object straight through.\n    props = config;\n  } else {\n    // We need to remove reserved props (key, prop, ref). Create a fresh props\n    // object and copy over all the non-reserved props. We don't use `delete`\n    // because in V8 it will deopt the object to dictionary mode.\n    props = {};\n    for (const propName in config) {\n      // Skip over reserved prop names\n      if (propName !== 'key') {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    undefined,\n    undefined,\n  );\n}\n\n// While `jsxDEV` should never be called when running in production, we do\n// support `jsx` and `jsxs` when running in development. This supports the case\n// where a third-party dependency ships code that was compiled for production;\n// we want to still provide warnings in development.\n//\n// So these functions are the _dev_ implementations of the _production_\n// API signatures.\n//\n// Since these functions are dev-only, it's ok to add an indirection here. They\n// only exist to provide different versions of `isStaticChildren`. (We shouldn't\n// use this pattern for the prod versions, though, because it will add an call\n// frame.)\nexport function jsxProdSignatureRunningInDevWithDynamicChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = false;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nexport function jsxProdSignatureRunningInDevWithStaticChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = true;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nconst didWarnAboutKeySpread = {};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return jsxDEVImpl(\n    type,\n    config,\n    maybeKey,\n    isStaticChildren,\n    source,\n    self,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nfunction jsxDEVImpl(\n  type,\n  config,\n  maybeKey,\n  isStaticChildren,\n  source,\n  self,\n  debugStack,\n  debugTask,\n) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    // With owner stacks, we no longer need the type here so this comment is\n    // no longer true. Which is why we can run this even for invalid types.\n    const children = config.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          console.error(\n            'React.jsx: Static children should always be an array. ' +\n              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n              'Use the Babel transform instead.',\n          );\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n\n    // Warn about key spread regardless of whether the type is valid.\n    if (hasOwnProperty.call(config, 'key')) {\n      const componentName = getComponentNameFromType(type);\n      const keys = Object.keys(config).filter(k => k !== 'key');\n      const beforeExample =\n        keys.length > 0\n          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'\n          : '{key: someKey}';\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        const afterExample =\n          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n        console.error(\n          'A props object containing a \"key\" prop is being spread into JSX:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s {...props} />\\n' +\n            'React keys must be passed directly to JSX without using spread:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s key={someKey} {...props} />',\n          beforeExample,\n          componentName,\n          afterExample,\n          componentName,\n        );\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    let key = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    let props;\n    if (!('key' in config)) {\n      // If key was not spread in, we can reuse the original props object. This\n      // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n      // target and the compiler always passes a new object. For `createElement`,\n      // we can't assume a new object is passed every time because it can be\n      // called manually.\n      //\n      // Spreading key is a warning in dev. In a future release, we will not\n      // remove a spread key from the props object. (But we'll still warn.) We'll\n      // always pass the object straight through.\n      props = config;\n    } else {\n      // We need to remove reserved props (key, prop, ref). Create a fresh props\n      // object and copy over all the non-reserved props. We don't use `delete`\n      // because in V8 it will deopt the object to dictionary mode.\n      props = {};\n      for (const propName in config) {\n        // Skip over reserved prop names\n        if (propName !== 'key') {\n          props[propName] = config[propName];\n        }\n      }\n    }\n\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    return ReactElement(\n      type,\n      key,\n      self,\n      source,\n      getOwner(),\n      props,\n      debugStack,\n      debugTask,\n    );\n  }\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n  }\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const clonedElement = ReactElement(\n    oldElement.type,\n    newKey,\n    undefined,\n    undefined,\n    !__DEV__ ? undefined : oldElement._owner,\n    oldElement.props,\n    __DEV__ && oldElement._debugStack,\n    __DEV__ && oldElement._debugTask,\n  );\n  if (__DEV__) {\n    // The cloned element should inherit the original element's key validation.\n    if (oldElement._store) {\n      clonedElement._store.validated = oldElement._store.validated;\n    }\n  }\n  return clonedElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = !__DEV__ ? undefined : element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      owner = __DEV__ ? getOwner() : undefined;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // ...and maybe these, too, though we currently rely on them for\n        // warnings and debug information in dev. Need to decide if we're OK\n        // with dropping them. In the jsx() runtime it's not an issue because\n        // the data gets passed as separate arguments instead of props, but\n        // it would be nice to stop relying on them entirely so we can drop\n        // them from the internal Fiber field.\n        propName !== '__self' &&\n        propName !== '__source' &&\n        // Undefined `ref` is ignored by cloneElement. We treat it the same as\n        // if the property were missing. This is mostly for\n        // backwards compatibility.\n        !(propName === 'ref' && config.ref === undefined)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  const clonedElement = ReactElement(\n    element.type,\n    key,\n    undefined,\n    undefined,\n    owner,\n    props,\n    __DEV__ && element._debugStack,\n    __DEV__ && element._debugTask,\n  );\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], clonedElement.type);\n  }\n\n  return clonedElement;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    // With owner stacks is, no warnings happens. All we do is\n    // mark elements as being in a valid static child position so they\n    // don't need keys.\n    if (isValidElement(node)) {\n      if (node._store) {\n        node._store.validated = 1;\n      }\n    }\n  }\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport {REACT_FRAGMENT_TYPE} from 'shared/ReactSymbols';\nimport {\n  jsxProd,\n  jsxProdSignatureRunningInDevWithDynamicChildren,\n  jsxProdSignatureRunningInDevWithStaticChildren,\n  jsxDEV as _jsxDEV,\n} from './ReactJSXElement';\n\nconst jsx: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithDynamicChildren\n  : jsxProd;\n// we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\nconst jsxs: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithStaticChildren\n  : jsxProd;\n\nconst jsxDEV: any = __DEV__ ? _jsxDEV : undefined;\n\nexport {REACT_FRAGMENT_TYPE as Fragment, jsx, jsxs, jsxDEV};\n"],"names":["ownerStackLimit","REACT_ELEMENT_TYPE","Symbol","for","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_CONSUMER_TYPE","REACT_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_ACTIVITY_TYPE","REACT_VIEW_TRANSITION_TYPE","getWrappedName","outerType","innerType","wrapperName","displayName","functionName","name","getContextName","type","REACT_CLIENT_REFERENCE","getComponentNameFromType","$$typeof","tag","console","error","context","consumer","_context","render","outerName","lazyComponent","payload","_payload","init","_init","x","ReactSharedInternalsServer","React","__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","Error","hasOwnProperty","Object","prototype","typeName","value","hasToStringTag","toStringTag","constructor","willCoercionThrow","testStringCoercion","e","checkKeyStringCoercion","isArrayImpl","Array","isArray","a","createTask","getTaskName","getOwner","dispatcher","ReactSharedInternals","A","UnknownOwner","createFakeCallStack","react_stack_bottom_frame","callStackForError","specialPropKeyWarningShown","didWarnAboutElementRef","unknownOwnerDebugStack","unknownOwnerDebugTask","bind","hasValidKey","config","call","getter","getOwnPropertyDescriptor","get","isReactWarning","key","undefined","defineKeyPropWarningGetter","props","warnAboutAccessingKey","defineProperty","configurable","elementRefGetterWithDeprecationWarning","componentName","refProp","ref","ReactElement","self","source","owner","debugStack","debugTask","element","_owner","enumerable","_store","writable","freeze","jsxProdSignatureRunningInDevWithDynamicChildren","maybeKey","isStaticChildren","trackActualOwner","recentlyCreatedOwnerStacks","jsxDEVImpl","jsxProdSignatureRunningInDevWithStaticChildren","didWarnAboutKeySpread","jsxDEV","children","i","length","validateChildKeys","keys","filter","k","beforeExample","join","afterExample","propName","node","parentType","isValidElement","validated","object","jsx","jsxs","_jsxDEV"],"mappings":"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"}
\ No newline at end of file
diff --git a/cjs/react-jsx-runtime.react-server.production.js b/cjs/react-jsx-runtime.react-server.production.js
index 486facb52101f965fd3c74e03c4c4299006cdcd9..5a43ea4e51de93e301ff9107b73d7f7c1394b269 100644
--- a/cjs/react-jsx-runtime.react-server.production.js
+++ b/cjs/react-jsx-runtime.react-server.production.js
@@ -1,40 +1,126 @@
+'use strict';
+
+var React = require('react');
+
+const REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+
+const ReactSharedInternalsServer =
+// $FlowFixMe: It's defined in the one we resolve to.
+React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
+if (!ReactSharedInternalsServer) {
+  throw new Error('The "react" package in this environment is not configured correctly. ' + 'The "react-server" condition must be enabled in any environment that ' + 'runs React Server Components.');
+}
+
+function getOwner() {
+  return null;
+}
+function hasValidKey(config) {
+  return config.key !== undefined;
+}
+
 /**
- * @license React
- * react-jsx-runtime.react-server.production.js
+ * Factory method to create a new React element. This no longer adheres to
+ * the class pattern, so do not use new to call it. Also, instanceof check
+ * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check
+ * if something is a React Element.
  *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
+ * @param {*} type
+ * @param {*} props
+ * @param {*} key
+ * @param {string|object} ref
+ * @param {*} owner
+ * @param {*} self A *temporary* helper to detect places where `this` is
+ * different from the `owner` when React.createElement is called, so that we
+ * can warn. We want to get rid of owner and replace string `ref`s with arrow
+ * functions, and as long as `this` and owner are the same, there will be no
+ * change in behavior.
+ * @param {*} source An annotation object (added by a transpiler or otherwise)
+ * indicating filename, line number, and/or other information.
+ * @internal
  */
+function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
+  // Ignore whatever was passed as the ref argument and treat `props.ref` as
+  // the source of truth. The only thing we use this for is `element.ref`,
+  // which will log a deprecation warning on access. In the next release, we
+  // can remove `element.ref` as well as the `ref` argument.
+  const refProp = props.ref;
+
+  // An undefined `element.ref` is coerced to `null` for
+  // backwards compatibility.
+  const ref = refProp !== undefined ? refProp : null;
+  let element;
+  {
+    // In prod, `ref` is a regular property and _owner doesn't exist.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      // Built-in properties that belong on the element
+      type,
+      key,
+      ref,
+      props
+    };
+  }
+  return element;
+}
 
-"use strict";
-var React = require("react"),
-  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
-if (!React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE)
-  throw Error(
-    'The "react" package in this environment is not configured correctly. The "react-server" condition must be enabled in any environment that runs React Server Components.'
-  );
+/**
+ * https://github.com/reactjs/rfcs/pull/107
+ * @param {*} type
+ * @param {object} props
+ * @param {string} key
+ */
 function jsxProd(type, config, maybeKey) {
-  var key = null;
-  void 0 !== maybeKey && (key = "" + maybeKey);
-  void 0 !== config.key && (key = "" + config.key);
-  if ("key" in config) {
-    maybeKey = {};
-    for (var propName in config)
-      "key" !== propName && (maybeKey[propName] = config[propName]);
-  } else maybeKey = config;
-  config = maybeKey.ref;
-  return {
-    $$typeof: REACT_ELEMENT_TYPE,
-    type: type,
-    key: key,
-    ref: void 0 !== config ? config : null,
-    props: maybeKey
-  };
+  let key = null;
+
+  // Currently, key can be spread in as a prop. This causes a potential
+  // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
+  // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
+  // but as an intermediary step, we will use jsxDEV for everything except
+  // <div {...props} key="Hi" />, because we aren't currently able to tell if
+  // key is explicitly declared to be undefined or not.
+  if (maybeKey !== undefined) {
+    key = '' + maybeKey;
+  }
+  if (hasValidKey(config)) {
+    key = '' + config.key;
+  }
+  let props;
+  if (!('key' in config)) {
+    // If key was not spread in, we can reuse the original props object. This
+    // only works for `jsx`, not `createElement`, because `jsx` is a compiler
+    // target and the compiler always passes a new object. For `createElement`,
+    // we can't assume a new object is passed every time because it can be
+    // called manually.
+    //
+    // Spreading key is a warning in dev. In a future release, we will not
+    // remove a spread key from the props object. (But we'll still warn.) We'll
+    // always pass the object straight through.
+    props = config;
+  } else {
+    // We need to remove reserved props (key, prop, ref). Create a fresh props
+    // object and copy over all the non-reserved props. We don't use `delete`
+    // because in V8 it will deopt the object to dictionary mode.
+    props = {};
+    for (const propName in config) {
+      // Skip over reserved prop names
+      if (propName !== 'key') {
+        props[propName] = config[propName];
+      }
+    }
+  }
+  return ReactElement(type, key, undefined, undefined, getOwner(), props);
 }
+
+const jsx = jsxProd;
+// we may want to special case jsxs internally to take advantage of static children.
+// for now we can ship identical prod functions
+const jsxs = jsxProd;
+const jsxDEV = undefined;
+
 exports.Fragment = REACT_FRAGMENT_TYPE;
-exports.jsx = jsxProd;
-exports.jsxDEV = void 0;
-exports.jsxs = jsxProd;
+exports.jsx = jsx;
+exports.jsxDEV = jsxDEV;
+exports.jsxs = jsxs;
+//# sourceMappingURL=react-jsx-runtime.react-server.production.js.map
diff --git a/cjs/react-jsx-runtime.react-server.production.js.map b/cjs/react-jsx-runtime.react-server.production.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..4e386d83a52ac836f06c7a409506c52af16dbd94
--- /dev/null
+++ b/cjs/react-jsx-runtime.react-server.production.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react-jsx-runtime.react-server.production.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/react-server/src/ReactSharedInternalsServer.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXElement.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXServer.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {SharedStateServer} from 'react/src/ReactSharedInternalsServer';\n\nimport * as React from 'react';\n\nconst ReactSharedInternalsServer: SharedStateServer =\n  // $FlowFixMe: It's defined in the one we resolve to.\n  React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n\nif (!ReactSharedInternalsServer) {\n  throw new Error(\n    'The \"react\" package in this environment is not configured correctly. ' +\n      'The \"react-server\" condition must be enabled in any environment that ' +\n      'runs React Server Components.',\n  );\n}\n\nexport default ReactSharedInternalsServer;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport assign from 'shared/assign';\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\nimport isArray from 'shared/isArray';\nimport {ownerStackLimit} from 'shared/ReactFeatureFlags';\n\nconst createTask =\n  // eslint-disable-next-line react-internal/no-production-logging\n  __DEV__ && console.createTask\n    ? // eslint-disable-next-line react-internal/no-production-logging\n      console.createTask\n    : () => null;\n\nfunction getTaskName(type) {\n  if (type === REACT_FRAGMENT_TYPE) {\n    return '<>';\n  }\n  if (\n    typeof type === 'object' &&\n    type !== null &&\n    type.$$typeof === REACT_LAZY_TYPE\n  ) {\n    // We don't want to eagerly initialize the initializer in DEV mode so we can't\n    // call it to extract the type so we don't know the type of this component.\n    return '<...>';\n  }\n  try {\n    const name = getComponentNameFromType(type);\n    return name ? '<' + name + '>' : '<...>';\n  } catch (x) {\n    return '<...>';\n  }\n}\n\nfunction getOwner() {\n  if (__DEV__) {\n    const dispatcher = ReactSharedInternals.A;\n    if (dispatcher === null) {\n      return null;\n    }\n    return dispatcher.getOwner();\n  }\n  return null;\n}\n\n/** @noinline */\nfunction UnknownOwner() {\n  /** @noinline */\n  return (() => Error('react-stack-top-frame'))();\n}\nconst createFakeCallStack = {\n  react_stack_bottom_frame: function (callStackForError) {\n    return callStackForError();\n  },\n};\n\nlet specialPropKeyWarningShown;\nlet didWarnAboutElementRef;\nlet didWarnAboutOldJSXRuntime;\nlet unknownOwnerDebugStack;\nlet unknownOwnerDebugTask;\n\nif (__DEV__) {\n  didWarnAboutElementRef = {};\n\n  // We use this technique to trick minifiers to preserve the function name.\n  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(\n    createFakeCallStack,\n    UnknownOwner,\n  )();\n  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://react.dev/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction elementRefGetterWithDeprecationWarning() {\n  if (__DEV__) {\n    const componentName = getComponentNameFromType(this.type);\n    if (!didWarnAboutElementRef[componentName]) {\n      didWarnAboutElementRef[componentName] = true;\n      console.error(\n        'Accessing element.ref was removed in React 19. ref is now a ' +\n          'regular prop. It will be removed from the JSX Element ' +\n          'type in a future release.',\n      );\n    }\n\n    // An undefined `element.ref` is coerced to `null` for\n    // backwards compatibility.\n    const refProp = this.props.ref;\n    return refProp !== undefined ? refProp : null;\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nfunction ReactElement(\n  type,\n  key,\n  self,\n  source,\n  owner,\n  props,\n  debugStack,\n  debugTask,\n) {\n  // Ignore whatever was passed as the ref argument and treat `props.ref` as\n  // the source of truth. The only thing we use this for is `element.ref`,\n  // which will log a deprecation warning on access. In the next release, we\n  // can remove `element.ref` as well as the `ref` argument.\n  const refProp = props.ref;\n\n  // An undefined `element.ref` is coerced to `null` for\n  // backwards compatibility.\n  const ref = refProp !== undefined ? refProp : null;\n\n  let element;\n  if (__DEV__) {\n    // In dev, make `ref` a non-enumerable property with a warning. It's non-\n    // enumerable so that test matchers and serializers don't access it and\n    // trigger the warning.\n    //\n    // `ref` will be removed from the element completely in a future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n\n      props,\n\n      // Record the component responsible for creating this element.\n      _owner: owner,\n    };\n    if (ref !== null) {\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        get: elementRefGetterWithDeprecationWarning,\n      });\n    } else {\n      // Don't warn on access if a ref is not given. This reduces false\n      // positives in cases where a test serializer uses\n      // getOwnPropertyDescriptors to compare objects, like Jest does, which is\n      // a problem because it bypasses non-enumerability.\n      //\n      // So unfortunately this will trigger a false positive warning in Jest\n      // when the diff is printed:\n      //\n      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);\n      //\n      // A bit sketchy, but this is what we've done for the `props.key` and\n      // `props.ref` accessors for years, which implies it will be good enough\n      // for `element.ref`, too. Let's see if anyone complains.\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        value: null,\n      });\n    }\n  } else {\n    // In prod, `ref` is a regular property and _owner doesn't exist.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n      ref,\n\n      props,\n    };\n  }\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: 0,\n    });\n    // debugInfo contains Server Component debug information.\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null,\n    });\n    Object.defineProperty(element, '_debugStack', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugStack,\n    });\n    Object.defineProperty(element, '_debugTask', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugTask,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxProd(type, config, maybeKey) {\n  let key = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  let props;\n  if (!('key' in config)) {\n    // If key was not spread in, we can reuse the original props object. This\n    // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n    // target and the compiler always passes a new object. For `createElement`,\n    // we can't assume a new object is passed every time because it can be\n    // called manually.\n    //\n    // Spreading key is a warning in dev. In a future release, we will not\n    // remove a spread key from the props object. (But we'll still warn.) We'll\n    // always pass the object straight through.\n    props = config;\n  } else {\n    // We need to remove reserved props (key, prop, ref). Create a fresh props\n    // object and copy over all the non-reserved props. We don't use `delete`\n    // because in V8 it will deopt the object to dictionary mode.\n    props = {};\n    for (const propName in config) {\n      // Skip over reserved prop names\n      if (propName !== 'key') {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    undefined,\n    undefined,\n  );\n}\n\n// While `jsxDEV` should never be called when running in production, we do\n// support `jsx` and `jsxs` when running in development. This supports the case\n// where a third-party dependency ships code that was compiled for production;\n// we want to still provide warnings in development.\n//\n// So these functions are the _dev_ implementations of the _production_\n// API signatures.\n//\n// Since these functions are dev-only, it's ok to add an indirection here. They\n// only exist to provide different versions of `isStaticChildren`. (We shouldn't\n// use this pattern for the prod versions, though, because it will add an call\n// frame.)\nexport function jsxProdSignatureRunningInDevWithDynamicChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = false;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nexport function jsxProdSignatureRunningInDevWithStaticChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = true;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nconst didWarnAboutKeySpread = {};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return jsxDEVImpl(\n    type,\n    config,\n    maybeKey,\n    isStaticChildren,\n    source,\n    self,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nfunction jsxDEVImpl(\n  type,\n  config,\n  maybeKey,\n  isStaticChildren,\n  source,\n  self,\n  debugStack,\n  debugTask,\n) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    // With owner stacks, we no longer need the type here so this comment is\n    // no longer true. Which is why we can run this even for invalid types.\n    const children = config.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          console.error(\n            'React.jsx: Static children should always be an array. ' +\n              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n              'Use the Babel transform instead.',\n          );\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n\n    // Warn about key spread regardless of whether the type is valid.\n    if (hasOwnProperty.call(config, 'key')) {\n      const componentName = getComponentNameFromType(type);\n      const keys = Object.keys(config).filter(k => k !== 'key');\n      const beforeExample =\n        keys.length > 0\n          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'\n          : '{key: someKey}';\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        const afterExample =\n          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n        console.error(\n          'A props object containing a \"key\" prop is being spread into JSX:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s {...props} />\\n' +\n            'React keys must be passed directly to JSX without using spread:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s key={someKey} {...props} />',\n          beforeExample,\n          componentName,\n          afterExample,\n          componentName,\n        );\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    let key = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    let props;\n    if (!('key' in config)) {\n      // If key was not spread in, we can reuse the original props object. This\n      // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n      // target and the compiler always passes a new object. For `createElement`,\n      // we can't assume a new object is passed every time because it can be\n      // called manually.\n      //\n      // Spreading key is a warning in dev. In a future release, we will not\n      // remove a spread key from the props object. (But we'll still warn.) We'll\n      // always pass the object straight through.\n      props = config;\n    } else {\n      // We need to remove reserved props (key, prop, ref). Create a fresh props\n      // object and copy over all the non-reserved props. We don't use `delete`\n      // because in V8 it will deopt the object to dictionary mode.\n      props = {};\n      for (const propName in config) {\n        // Skip over reserved prop names\n        if (propName !== 'key') {\n          props[propName] = config[propName];\n        }\n      }\n    }\n\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    return ReactElement(\n      type,\n      key,\n      self,\n      source,\n      getOwner(),\n      props,\n      debugStack,\n      debugTask,\n    );\n  }\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n  }\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const clonedElement = ReactElement(\n    oldElement.type,\n    newKey,\n    undefined,\n    undefined,\n    !__DEV__ ? undefined : oldElement._owner,\n    oldElement.props,\n    __DEV__ && oldElement._debugStack,\n    __DEV__ && oldElement._debugTask,\n  );\n  if (__DEV__) {\n    // The cloned element should inherit the original element's key validation.\n    if (oldElement._store) {\n      clonedElement._store.validated = oldElement._store.validated;\n    }\n  }\n  return clonedElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = !__DEV__ ? undefined : element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      owner = __DEV__ ? getOwner() : undefined;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // ...and maybe these, too, though we currently rely on them for\n        // warnings and debug information in dev. Need to decide if we're OK\n        // with dropping them. In the jsx() runtime it's not an issue because\n        // the data gets passed as separate arguments instead of props, but\n        // it would be nice to stop relying on them entirely so we can drop\n        // them from the internal Fiber field.\n        propName !== '__self' &&\n        propName !== '__source' &&\n        // Undefined `ref` is ignored by cloneElement. We treat it the same as\n        // if the property were missing. This is mostly for\n        // backwards compatibility.\n        !(propName === 'ref' && config.ref === undefined)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  const clonedElement = ReactElement(\n    element.type,\n    key,\n    undefined,\n    undefined,\n    owner,\n    props,\n    __DEV__ && element._debugStack,\n    __DEV__ && element._debugTask,\n  );\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], clonedElement.type);\n  }\n\n  return clonedElement;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    // With owner stacks is, no warnings happens. All we do is\n    // mark elements as being in a valid static child position so they\n    // don't need keys.\n    if (isValidElement(node)) {\n      if (node._store) {\n        node._store.validated = 1;\n      }\n    }\n  }\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\nimport {REACT_FRAGMENT_TYPE} from 'shared/ReactSymbols';\nimport {\n  jsxProd,\n  jsxProdSignatureRunningInDevWithDynamicChildren,\n  jsxProdSignatureRunningInDevWithStaticChildren,\n  jsxDEV as _jsxDEV,\n} from './ReactJSXElement';\n\nconst jsx: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithDynamicChildren\n  : jsxProd;\n// we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\nconst jsxs: any = __DEV__\n  ? jsxProdSignatureRunningInDevWithStaticChildren\n  : jsxProd;\n\nconst jsxDEV: any = __DEV__ ? _jsxDEV : undefined;\n\nexport {REACT_FRAGMENT_TYPE as Fragment, jsx, jsxs, jsxDEV};\n"],"names":["REACT_ELEMENT_TYPE","Symbol","for","REACT_FRAGMENT_TYPE","ReactSharedInternalsServer","React","__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","Error","getOwner","hasValidKey","config","key","undefined","ReactElement","type","self","source","owner","props","debugStack","debugTask","refProp","ref","element","$$typeof","jsxProd","maybeKey","propName","jsx","jsxs","jsxDEV"],"mappings":";;;;AAiBO,MAAMA,kBAAkB,GAC3BC,MAAM,CAACC,GAAG,CAAC,4BAA4B,CAAC,CACf,CAAA;AAEtB,MAAMC,mBAAmB,GAAWF,MAAM,CAACC,GAAG,CAAC,gBAAgB;;ACRtE,MAAME,0BAA0B;AAC9B;AACAC,KAAK,CAACC,+DAA+D,CAAA;AAEvE,IAAI,CAACF,0BAA0B,EAAE;EAC/B,MAAM,IAAIG,KAAK,CACb,uEAAuE,GACrE,uEAAuE,GACvE,+BACJ,CAAC,CAAA;AACH;;ACyBA,SAASC,QAAQA,GAAG;AAQlB,EAAA,OAAO,IAAI,CAAA;AACb,CAAA;AA0CA,SAASC,WAAWA,CAACC,MAAM,EAAE;AAS3B,EAAA,OAAOA,MAAM,CAACC,GAAG,KAAKC,SAAS,CAAA;AACjC,CAAA;;AA2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CACnBC,IAAI,EACJH,GAAG,EACHI,IAAI,EACJC,MAAM,EACNC,KAAK,EACLC,KAAK,EACLC,UAAU,EACVC,SAAS,EACT;AACA;AACA;AACA;AACA;AACA,EAAA,MAAMC,OAAO,GAAGH,KAAK,CAACI,GAAG,CAAA;;AAEzB;AACA;EACA,MAAMA,GAAG,GAAGD,OAAO,KAAKT,SAAS,GAAGS,OAAO,GAAG,IAAI,CAAA;AAElD,EAAA,IAAIE,OAAO,CAAA;AACX,EA2CO;AACL;AACAA,IAAAA,OAAO,GAAG;AACR;AACAC,MAAAA,QAAQ,EAAExB,kBAAkB;AAE5B;MACAc,IAAI;MACJH,GAAG;MACHW,GAAG;AAEHJ,MAAAA,KAAAA;KACD,CAAA;AACH,GAAA;AA4CA,EAAA,OAAOK,OAAO,CAAA;AAChB,CAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACO,SAASE,OAAOA,CAACX,IAAI,EAAEJ,MAAM,EAAEgB,QAAQ,EAAE;EAC9C,IAAIf,GAAG,GAAG,IAAI,CAAA;;AAEd;AACA;AACA;AACA;AACA;AACA;EACA,IAAIe,QAAQ,KAAKd,SAAS,EAAE;IAI1BD,GAAG,GAAG,EAAE,GAAGe,QAAQ,CAAA;AACrB,GAAA;AAEA,EAAA,IAAIjB,WAAW,CAACC,MAAM,CAAC,EAAE;AAIvBC,IAAAA,GAAG,GAAG,EAAE,GAAGD,MAAM,CAACC,GAAG,CAAA;AACvB,GAAA;AAEA,EAAA,IAAIO,KAAK,CAAA;AACT,EAAA,IAAI,EAAE,KAAK,IAAIR,MAAM,CAAC,EAAE;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAQ,IAAAA,KAAK,GAAGR,MAAM,CAAA;AAChB,GAAC,MAAM;AACL;AACA;AACA;IACAQ,KAAK,GAAG,EAAE,CAAA;AACV,IAAA,KAAK,MAAMS,QAAQ,IAAIjB,MAAM,EAAE;AAC7B;MACA,IAAIiB,QAAQ,KAAK,KAAK,EAAE;AACtBT,QAAAA,KAAK,CAACS,QAAQ,CAAC,GAAGjB,MAAM,CAACiB,QAAQ,CAAC,CAAA;AACpC,OAAA;AACF,KAAA;AACF,GAAA;AAEA,EAAA,OAAOd,YAAY,CACjBC,IAAI,EACJH,GAAG,EACHC,SAAS,EACTA,SAAS,EACTJ,QAAQ,EAAE,EACVU,KAGF,CAAC,CAAA;AACH;;ACxVA,MAAMU,GAAG,GAELH,QAAO;AACX;AACA;AACA,MAAMI,IAAI,GAENJ,QAAO;AAEX,MAAMK,MAAM,GAA4BlB;;;;;;;"}
\ No newline at end of file
diff --git a/cjs/react.development.js b/cjs/react.development.js
index bd66364d500e83e2687301dbf9b4f593639c3aca..5d929c3395e8796fbd26bf6c98723d76f1620ac6 100644
--- a/cjs/react.development.js
+++ b/cjs/react.development.js
@@ -1,1242 +1,2140 @@
+'use strict';
+
+var ReactVersion = '19.2.0-experimental-602917c8-20250701';
+
+// -----------------------------------------------------------------------------
+// Land or remove (zero effort)
+//
+// Flags that can likely be deleted or landed without consequences
+// -----------------------------------------------------------------------------
+
+
+// Disables legacy mode
+// This allows us to land breaking changes to remove legacy mode APIs in experimental builds
+// before removing them in stable in the next Major
+var disableLegacyMode = true;
+var ownerStackLimit = 1e4;
+
+var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+var REACT_PORTAL_TYPE = Symbol.for('react.portal');
+var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
+var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
+var REACT_CONSUMER_TYPE = Symbol.for('react.consumer');
+var REACT_CONTEXT_TYPE = Symbol.for('react.context');
+var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
+var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
+var REACT_MEMO_TYPE = Symbol.for('react.memo');
+var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+var REACT_ACTIVITY_TYPE = Symbol.for('react.activity');
+var REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
+var REACT_VIEW_TRANSITION_TYPE = Symbol.for('react.view_transition');
+var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+var FAUX_ITERATOR_SYMBOL = '@@iterator';
+function getIteratorFn(maybeIterable) {
+  if (maybeIterable === null || typeof maybeIterable !== 'object') {
+    return null;
+  }
+  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
+  if (typeof maybeIterator === 'function') {
+    return maybeIterator;
+  }
+  return null;
+}
+
+var didWarnStateUpdateForUnmountedComponent = {};
+function warnNoop(publicInstance, callerName) {
+  {
+    var _constructor = publicInstance.constructor;
+    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
+    var warningKey = componentName + "." + callerName;
+    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
+      return;
+    }
+    console.error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
+    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
+  }
+}
+
 /**
- * @license React
- * react.development.js
+ * This is the abstract API for an update queue.
+ */
+var ReactNoopUpdateQueue = {
+  /**
+   * Checks whether or not this composite component is mounted.
+   * @param {ReactClass} publicInstance The instance we want to test.
+   * @return {boolean} True if mounted, false otherwise.
+   * @protected
+   * @final
+   */
+  isMounted: function (publicInstance) {
+    return false;
+  },
+  /**
+   * Forces an update. This should only be invoked when it is known with
+   * certainty that we are **not** in a DOM transaction.
+   *
+   * You may want to call this when you know that some deeper aspect of the
+   * component's state has changed but `setState` was not called.
+   *
+   * This will not invoke `shouldComponentUpdate`, but it will invoke
+   * `componentWillUpdate` and `componentDidUpdate`.
+   *
+   * @param {ReactClass} publicInstance The instance that should rerender.
+   * @param {?function} callback Called after component is updated.
+   * @param {?string} callerName name of the calling function in the public API.
+   * @internal
+   */
+  enqueueForceUpdate: function (publicInstance, callback, callerName) {
+    warnNoop(publicInstance, 'forceUpdate');
+  },
+  /**
+   * Replaces all of the state. Always use this or `setState` to mutate state.
+   * You should treat `this.state` as immutable.
+   *
+   * There is no guarantee that `this.state` will be immediately updated, so
+   * accessing `this.state` after calling this method may return the old value.
+   *
+   * @param {ReactClass} publicInstance The instance that should rerender.
+   * @param {object} completeState Next state.
+   * @param {?function} callback Called after component is updated.
+   * @param {?string} callerName name of the calling function in the public API.
+   * @internal
+   */
+  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
+    warnNoop(publicInstance, 'replaceState');
+  },
+  /**
+   * Sets a subset of the state. This only exists because _pendingState is
+   * internal. This provides a merging strategy that is not available to deep
+   * properties which is confusing. TODO: Expose pendingState or don't use it
+   * during the merge.
+   *
+   * @param {ReactClass} publicInstance The instance that should rerender.
+   * @param {object} partialState Next partial state to be merged with state.
+   * @param {?function} callback Called after component is updated.
+   * @param {?string} Name of the calling function in the public API.
+   * @internal
+   */
+  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
+    warnNoop(publicInstance, 'setState');
+  }
+};
+
+var assign = Object.assign;
+
+var emptyObject = {};
+{
+  Object.freeze(emptyObject);
+}
+
+/**
+ * Base class helpers for the updating state of a component.
+ */
+function Component(props, context, updater) {
+  this.props = props;
+  this.context = context;
+  // If a component has string refs, we will assign a different object later.
+  this.refs = emptyObject;
+  // We initialize the default updater but the real one gets injected by the
+  // renderer.
+  this.updater = updater || ReactNoopUpdateQueue;
+}
+Component.prototype.isReactComponent = {};
+
+/**
+ * Sets a subset of the state. Always use this to mutate
+ * state. You should treat `this.state` as immutable.
+ *
+ * There is no guarantee that `this.state` will be immediately updated, so
+ * accessing `this.state` after calling this method may return the old value.
+ *
+ * There is no guarantee that calls to `setState` will run synchronously,
+ * as they may eventually be batched together.  You can provide an optional
+ * callback that will be executed when the call to setState is actually
+ * completed.
  *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * When a function is provided to setState, it will be called at some point in
+ * the future (not synchronously). It will be called with the up to date
+ * component arguments (state, props, context). These values can be different
+ * from this.* because your function may be called after receiveProps but before
+ * shouldComponentUpdate, and this new state, props, and context will not yet be
+ * assigned to this.
  *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
+ * @param {object|function} partialState Next partial state or function to
+ *        produce next partial state to be merged with current state.
+ * @param {?function} callback Called after state is updated.
+ * @final
+ * @protected
  */
+Component.prototype.setState = function (partialState, callback) {
+  if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
+    throw new Error('takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
+  }
+  this.updater.enqueueSetState(this, partialState, callback, 'setState');
+};
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
-  (function () {
-    function defineDeprecationWarning(methodName, info) {
-      Object.defineProperty(Component.prototype, methodName, {
-        get: function () {
-          console.warn(
-            "%s(...) is deprecated in plain JavaScript React classes. %s",
-            info[0],
-            info[1]
-          );
-        }
-      });
-    }
-    function getIteratorFn(maybeIterable) {
-      if (null === maybeIterable || "object" !== typeof maybeIterable)
-        return null;
-      maybeIterable =
-        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-        maybeIterable["@@iterator"];
-      return "function" === typeof maybeIterable ? maybeIterable : null;
-    }
-    function warnNoop(publicInstance, callerName) {
-      publicInstance =
-        ((publicInstance = publicInstance.constructor) &&
-          (publicInstance.displayName || publicInstance.name)) ||
-        "ReactClass";
-      var warningKey = publicInstance + "." + callerName;
-      didWarnStateUpdateForUnmountedComponent[warningKey] ||
-        (console.error(
-          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
-          callerName,
-          publicInstance
-        ),
-        (didWarnStateUpdateForUnmountedComponent[warningKey] = !0));
+/**
+ * Forces an update. This should only be invoked when it is known with
+ * certainty that we are **not** in a DOM transaction.
+ *
+ * You may want to call this when you know that some deeper aspect of the
+ * component's state has changed but `setState` was not called.
+ *
+ * This will not invoke `shouldComponentUpdate`, but it will invoke
+ * `componentWillUpdate` and `componentDidUpdate`.
+ *
+ * @param {?function} callback Called after update is complete.
+ * @final
+ * @protected
+ */
+Component.prototype.forceUpdate = function (callback) {
+  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
+};
+
+/**
+ * Deprecated APIs. These APIs used to exist on classic React classes but since
+ * we would like to deprecate them, we're not going to move them over to this
+ * modern base class. Instead, we define a getter that warns if it's accessed.
+ */
+{
+  var deprecatedAPIs = {
+    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
+    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
+  };
+  var defineDeprecationWarning = function (methodName, info) {
+    Object.defineProperty(Component.prototype, methodName, {
+      get: function () {
+        console.warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
+        return undefined;
+      }
+    });
+  };
+  for (var fnName in deprecatedAPIs) {
+    if (deprecatedAPIs.hasOwnProperty(fnName)) {
+      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
     }
-    function Component(props, context, updater) {
-      this.props = props;
-      this.context = context;
-      this.refs = emptyObject;
-      this.updater = updater || ReactNoopUpdateQueue;
+  }
+}
+function ComponentDummy() {}
+ComponentDummy.prototype = Component.prototype;
+
+/**
+ * Convenience component with default shallow equality check for sCU.
+ */
+function PureComponent(props, context, updater) {
+  this.props = props;
+  this.context = context;
+  // If a component has string refs, we will assign a different object later.
+  this.refs = emptyObject;
+  this.updater = updater || ReactNoopUpdateQueue;
+}
+var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
+pureComponentPrototype.constructor = PureComponent;
+// Avoid an extra prototype jump for these methods.
+assign(pureComponentPrototype, Component.prototype);
+pureComponentPrototype.isPureReactComponent = true;
+
+// an immutable object with a single mutable value
+function createRef() {
+  var refObject = {
+    current: null
+  };
+  {
+    Object.seal(refObject);
+  }
+  return refObject;
+}
+
+var isArrayImpl = Array.isArray;
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+function noop() {}
+
+/*
+ * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol
+ * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
+ *
+ * The functions in this module will throw an easier-to-understand,
+ * easier-to-debug exception with a clear errors message message explaining the
+ * problem. (Instead of a confusing exception thrown inside the implementation
+ * of the `value` object).
+ */
+
+// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
+function typeName(value) {
+  {
+    // toStringTag is needed for namespaced types like Temporal.Instant
+    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
+    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
+    // $FlowFixMe[incompatible-return]
+    return type;
+  }
+}
+
+// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
+function willCoercionThrow(value) {
+  {
+    try {
+      testStringCoercion(value);
+      return false;
+    } catch (e) {
+      return true;
     }
-    function ComponentDummy() {}
-    function PureComponent(props, context, updater) {
-      this.props = props;
-      this.context = context;
-      this.refs = emptyObject;
-      this.updater = updater || ReactNoopUpdateQueue;
+  }
+}
+
+/** @noinline */
+function testStringCoercion(value) {
+  // If you ended up here by following an exception call stack, here's what's
+  // happened: you supplied an object or symbol value to React (as a prop, key,
+  // DOM attribute, CSS property, string ref, etc.) and when React tried to
+  // coerce it to a string using `'' + value`, an exception was thrown.
+  //
+  // The most common types that will cause this exception are `Symbol` instances
+  // and Temporal objects like `Temporal.Instant`. But any object that has a
+  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
+  // exception. (Library authors do this to prevent users from using built-in
+  // numeric operators like `+` or comparison operators like `>=` because custom
+  // methods are needed to perform accurate arithmetic or comparison.)
+  //
+  // To fix the problem, coerce this object or symbol value to a string before
+  // passing it to React. The most reliable way is usually `String(value)`.
+  //
+  // To find which value is throwing, check the browser or debugger console.
+  // Before this exception was thrown, there should be `console.error` output
+  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
+  // problem and how that type was used: key, atrribute, input value prop, etc.
+  // In most cases, this console output also shows the component and its
+  // ancestor components where the exception happened.
+  //
+  // eslint-disable-next-line react-internal/safe-string-coercion
+  return '' + value;
+}
+function checkKeyStringCoercion(value) {
+  {
+    if (willCoercionThrow(value)) {
+      console.error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));
+      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
     }
-    function testStringCoercion(value) {
-      return "" + value;
+  }
+}
+
+// Keep in sync with react-reconciler/getComponentNameFromFiber
+function getWrappedName(outerType, innerType, wrapperName) {
+  var displayName = outerType.displayName;
+  if (displayName) {
+    return displayName;
+  }
+  var functionName = innerType.displayName || innerType.name || '';
+  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
+}
+
+// Keep in sync with react-reconciler/getComponentNameFromFiber
+function getContextName(type) {
+  return type.displayName || 'Context';
+}
+var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
+
+// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
+function getComponentNameFromType(type) {
+  if (type == null) {
+    // Host root, text node or just invalid type.
+    return null;
+  }
+  if (typeof type === 'function') {
+    if (type.$$typeof === REACT_CLIENT_REFERENCE) {
+      // TODO: Create a convention for naming client references with debug info.
+      return null;
     }
-    function checkKeyStringCoercion(value) {
-      try {
-        testStringCoercion(value);
-        var JSCompiler_inline_result = !1;
-      } catch (e) {
-        JSCompiler_inline_result = !0;
+    return type.displayName || type.name || null;
+  }
+  if (typeof type === 'string') {
+    return type;
+  }
+  switch (type) {
+    case REACT_FRAGMENT_TYPE:
+      return 'Fragment';
+    case REACT_PROFILER_TYPE:
+      return 'Profiler';
+    case REACT_STRICT_MODE_TYPE:
+      return 'StrictMode';
+    case REACT_SUSPENSE_TYPE:
+      return 'Suspense';
+    case REACT_SUSPENSE_LIST_TYPE:
+      return 'SuspenseList';
+    case REACT_ACTIVITY_TYPE:
+      return 'Activity';
+    case REACT_VIEW_TRANSITION_TYPE:
+      {
+        return 'ViewTransition';
       }
-      if (JSCompiler_inline_result) {
-        JSCompiler_inline_result = console;
-        var JSCompiler_temp_const = JSCompiler_inline_result.error;
-        var JSCompiler_inline_result$jscomp$0 =
-          ("function" === typeof Symbol &&
-            Symbol.toStringTag &&
-            value[Symbol.toStringTag]) ||
-          value.constructor.name ||
-          "Object";
-        JSCompiler_temp_const.call(
-          JSCompiler_inline_result,
-          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
-          JSCompiler_inline_result$jscomp$0
-        );
-        return testStringCoercion(value);
+  }
+  if (typeof type === 'object') {
+    {
+      if (typeof type.tag === 'number') {
+        console.error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
       }
     }
-    function getComponentNameFromType(type) {
-      if (null == type) return null;
-      if ("function" === typeof type)
-        return type.$$typeof === REACT_CLIENT_REFERENCE
-          ? null
-          : type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
-      switch (type) {
-        case REACT_FRAGMENT_TYPE:
-          return "Fragment";
-        case REACT_PROFILER_TYPE:
-          return "Profiler";
-        case REACT_STRICT_MODE_TYPE:
-          return "StrictMode";
-        case REACT_SUSPENSE_TYPE:
-          return "Suspense";
-        case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
-        case REACT_ACTIVITY_TYPE:
-          return "Activity";
-      }
-      if ("object" === typeof type)
-        switch (
-          ("number" === typeof type.tag &&
-            console.error(
-              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
-            ),
-          type.$$typeof)
-        ) {
-          case REACT_PORTAL_TYPE:
-            return "Portal";
-          case REACT_CONTEXT_TYPE:
-            return (type.displayName || "Context") + ".Provider";
-          case REACT_CONSUMER_TYPE:
-            return (type._context.displayName || "Context") + ".Consumer";
-          case REACT_FORWARD_REF_TYPE:
-            var innerType = type.render;
-            type = type.displayName;
-            type ||
-              ((type = innerType.displayName || innerType.name || ""),
-              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
-            return type;
-          case REACT_MEMO_TYPE:
-            return (
-              (innerType = type.displayName || null),
-              null !== innerType
-                ? innerType
-                : getComponentNameFromType(type.type) || "Memo"
-            );
-          case REACT_LAZY_TYPE:
-            innerType = type._payload;
-            type = type._init;
-            try {
-              return getComponentNameFromType(type(innerType));
-            } catch (x) {}
+    switch (type.$$typeof) {
+      case REACT_PORTAL_TYPE:
+        return 'Portal';
+      case REACT_CONTEXT_TYPE:
+        var context = type;
+        return getContextName(context);
+      case REACT_CONSUMER_TYPE:
+        var consumer = type;
+        return getContextName(consumer._context) + '.Consumer';
+      case REACT_FORWARD_REF_TYPE:
+        return getWrappedName(type, type.render, 'ForwardRef');
+      case REACT_MEMO_TYPE:
+        var outerName = type.displayName || null;
+        if (outerName !== null) {
+          return outerName;
+        }
+        return getComponentNameFromType(type.type) || 'Memo';
+      case REACT_LAZY_TYPE:
+        {
+          var lazyComponent = type;
+          var payload = lazyComponent._payload;
+          var init = lazyComponent._init;
+          try {
+            return getComponentNameFromType(init(payload));
+          } catch (x) {
+            return null;
+          }
         }
+    }
+  }
+  return null;
+}
+
+var ReactSharedInternals = {
+  H: null,
+  A: null,
+  T: null,
+  S: null
+};
+{
+  ReactSharedInternals.G = null;
+}
+{
+  ReactSharedInternals.actQueue = null;
+  ReactSharedInternals.asyncTransitions = 0;
+  ReactSharedInternals.isBatchingLegacy = false;
+  ReactSharedInternals.didScheduleLegacyUpdate = false;
+  ReactSharedInternals.didUsePromise = false;
+  ReactSharedInternals.thrownErrors = [];
+  // Stack implementation injected by the current renderer.
+  ReactSharedInternals.getCurrentStack = null;
+  ReactSharedInternals.recentlyCreatedOwnerStacks = 0;
+}
+
+// $FlowFixMe[method-unbinding]
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+
+var createTask =
+// eslint-disable-next-line react-internal/no-production-logging
+console.createTask ?
+// eslint-disable-next-line react-internal/no-production-logging
+console.createTask : function () {
+  return null;
+};
+function getTaskName(type) {
+  if (type === REACT_FRAGMENT_TYPE) {
+    return '<>';
+  }
+  if (typeof type === 'object' && type !== null && type.$$typeof === REACT_LAZY_TYPE) {
+    // We don't want to eagerly initialize the initializer in DEV mode so we can't
+    // call it to extract the type so we don't know the type of this component.
+    return '<...>';
+  }
+  try {
+    var name = getComponentNameFromType(type);
+    return name ? '<' + name + '>' : '<...>';
+  } catch (x) {
+    return '<...>';
+  }
+}
+function getOwner() {
+  {
+    var dispatcher = ReactSharedInternals.A;
+    if (dispatcher === null) {
       return null;
     }
-    function getTaskName(type) {
-      if (type === REACT_FRAGMENT_TYPE) return "<>";
-      if (
-        "object" === typeof type &&
-        null !== type &&
-        type.$$typeof === REACT_LAZY_TYPE
-      )
-        return "<...>";
-      try {
-        var name = getComponentNameFromType(type);
-        return name ? "<" + name + ">" : "<...>";
-      } catch (x) {
-        return "<...>";
+    return dispatcher.getOwner();
+  }
+}
+
+/** @noinline */
+function UnknownOwner() {
+  /** @noinline */
+  return function () {
+    return Error('react-stack-top-frame');
+  }();
+}
+var createFakeCallStack = {
+  react_stack_bottom_frame: function (callStackForError) {
+    return callStackForError();
+  }
+};
+var specialPropKeyWarningShown;
+var didWarnAboutElementRef;
+var didWarnAboutOldJSXRuntime;
+var unknownOwnerDebugStack;
+var unknownOwnerDebugTask;
+{
+  didWarnAboutElementRef = {};
+
+  // We use this technique to trick minifiers to preserve the function name.
+  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(createFakeCallStack, UnknownOwner)();
+  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
+}
+function hasValidRef(config) {
+  {
+    if (hasOwnProperty.call(config, 'ref')) {
+      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
+      if (getter && getter.isReactWarning) {
+        return false;
       }
     }
-    function getOwner() {
-      var dispatcher = ReactSharedInternals.A;
-      return null === dispatcher ? null : dispatcher.getOwner();
-    }
-    function UnknownOwner() {
-      return Error("react-stack-top-frame");
-    }
-    function hasValidKey(config) {
-      if (hasOwnProperty.call(config, "key")) {
-        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
-        if (getter && getter.isReactWarning) return !1;
+  }
+  return config.ref !== undefined;
+}
+function hasValidKey(config) {
+  {
+    if (hasOwnProperty.call(config, 'key')) {
+      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
+      if (getter && getter.isReactWarning) {
+        return false;
       }
-      return void 0 !== config.key;
     }
-    function defineKeyPropWarningGetter(props, displayName) {
-      function warnAboutAccessingKey() {
-        specialPropKeyWarningShown ||
-          ((specialPropKeyWarningShown = !0),
-          console.error(
-            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
-            displayName
-          ));
+  }
+  return config.key !== undefined;
+}
+function defineKeyPropWarningGetter(props, displayName) {
+  {
+    var warnAboutAccessingKey = function () {
+      if (!specialPropKeyWarningShown) {
+        specialPropKeyWarningShown = true;
+        console.error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://react.dev/link/special-props)', displayName);
       }
-      warnAboutAccessingKey.isReactWarning = !0;
-      Object.defineProperty(props, "key", {
-        get: warnAboutAccessingKey,
-        configurable: !0
-      });
-    }
-    function elementRefGetterWithDeprecationWarning() {
-      var componentName = getComponentNameFromType(this.type);
-      didWarnAboutElementRef[componentName] ||
-        ((didWarnAboutElementRef[componentName] = !0),
-        console.error(
-          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
-        ));
-      componentName = this.props.ref;
-      return void 0 !== componentName ? componentName : null;
+    };
+    warnAboutAccessingKey.isReactWarning = true;
+    Object.defineProperty(props, 'key', {
+      get: warnAboutAccessingKey,
+      configurable: true
+    });
+  }
+}
+function elementRefGetterWithDeprecationWarning() {
+  {
+    var componentName = getComponentNameFromType(this.type);
+    if (!didWarnAboutElementRef[componentName]) {
+      didWarnAboutElementRef[componentName] = true;
+      console.error('Accessing element.ref was removed in React 19. ref is now a ' + 'regular prop. It will be removed from the JSX Element ' + 'type in a future release.');
     }
-    function ReactElement(
-      type,
-      key,
-      self,
-      source,
-      owner,
-      props,
-      debugStack,
-      debugTask
-    ) {
-      self = props.ref;
-      type = {
-        $$typeof: REACT_ELEMENT_TYPE,
-        type: type,
-        key: key,
-        props: props,
-        _owner: owner
-      };
-      null !== (void 0 !== self ? self : null)
-        ? Object.defineProperty(type, "ref", {
-            enumerable: !1,
-            get: elementRefGetterWithDeprecationWarning
-          })
-        : Object.defineProperty(type, "ref", { enumerable: !1, value: null });
-      type._store = {};
-      Object.defineProperty(type._store, "validated", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: 0
+
+    // An undefined `element.ref` is coerced to `null` for
+    // backwards compatibility.
+    var refProp = this.props.ref;
+    return refProp !== undefined ? refProp : null;
+  }
+}
+
+/**
+ * Factory method to create a new React element. This no longer adheres to
+ * the class pattern, so do not use new to call it. Also, instanceof check
+ * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check
+ * if something is a React Element.
+ *
+ * @param {*} type
+ * @param {*} props
+ * @param {*} key
+ * @param {string|object} ref
+ * @param {*} owner
+ * @param {*} self A *temporary* helper to detect places where `this` is
+ * different from the `owner` when React.createElement is called, so that we
+ * can warn. We want to get rid of owner and replace string `ref`s with arrow
+ * functions, and as long as `this` and owner are the same, there will be no
+ * change in behavior.
+ * @param {*} source An annotation object (added by a transpiler or otherwise)
+ * indicating filename, line number, and/or other information.
+ * @internal
+ */
+function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
+  // Ignore whatever was passed as the ref argument and treat `props.ref` as
+  // the source of truth. The only thing we use this for is `element.ref`,
+  // which will log a deprecation warning on access. In the next release, we
+  // can remove `element.ref` as well as the `ref` argument.
+  var refProp = props.ref;
+
+  // An undefined `element.ref` is coerced to `null` for
+  // backwards compatibility.
+  var ref = refProp !== undefined ? refProp : null;
+  var element;
+  {
+    // In dev, make `ref` a non-enumerable property with a warning. It's non-
+    // enumerable so that test matchers and serializers don't access it and
+    // trigger the warning.
+    //
+    // `ref` will be removed from the element completely in a future release.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      // Built-in properties that belong on the element
+      type: type,
+      key: key,
+      props: props,
+      // Record the component responsible for creating this element.
+      _owner: owner
+    };
+    if (ref !== null) {
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
+        get: elementRefGetterWithDeprecationWarning
       });
-      Object.defineProperty(type, "_debugInfo", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
+    } else {
+      // Don't warn on access if a ref is not given. This reduces false
+      // positives in cases where a test serializer uses
+      // getOwnPropertyDescriptors to compare objects, like Jest does, which is
+      // a problem because it bypasses non-enumerability.
+      //
+      // So unfortunately this will trigger a false positive warning in Jest
+      // when the diff is printed:
+      //
+      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);
+      //
+      // A bit sketchy, but this is what we've done for the `props.key` and
+      // `props.ref` accessors for years, which implies it will be good enough
+      // for `element.ref`, too. Let's see if anyone complains.
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
         value: null
       });
-      Object.defineProperty(type, "_debugStack", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: debugStack
-      });
-      Object.defineProperty(type, "_debugTask", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: debugTask
-      });
-      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
-      return type;
     }
-    function cloneAndReplaceKey(oldElement, newKey) {
-      newKey = ReactElement(
-        oldElement.type,
-        newKey,
-        void 0,
-        void 0,
-        oldElement._owner,
-        oldElement.props,
-        oldElement._debugStack,
-        oldElement._debugTask
-      );
-      oldElement._store &&
-        (newKey._store.validated = oldElement._store.validated);
-      return newKey;
+  }
+  {
+    // The validation flag is currently mutative. We put it on
+    // an external backing store so that we can freeze the whole object.
+    // This can be replaced with a WeakMap once they are implemented in
+    // commonly used development environments.
+    element._store = {};
+
+    // To make comparing ReactElements easier for testing purposes, we make
+    // the validation flag non-enumerable (where possible, which should
+    // include every environment we run tests in), so the test framework
+    // ignores it.
+    Object.defineProperty(element._store, 'validated', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: 0
+    });
+    // debugInfo contains Server Component debug information.
+    Object.defineProperty(element, '_debugInfo', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: null
+    });
+    Object.defineProperty(element, '_debugStack', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugStack
+    });
+    Object.defineProperty(element, '_debugTask', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugTask
+    });
+    if (Object.freeze) {
+      Object.freeze(element.props);
+      Object.freeze(element);
     }
-    function isValidElement(object) {
-      return (
-        "object" === typeof object &&
-        null !== object &&
-        object.$$typeof === REACT_ELEMENT_TYPE
-      );
+  }
+  return element;
+}
+
+/**
+ * Create and return a new ReactElement of the given type.
+ * See https://reactjs.org/docs/react-api.html#createelement
+ */
+function createElement(type, config, children) {
+  {
+    // We don't warn for invalid element type here because with owner stacks,
+    // we error in the renderer. The renderer is the only one that knows what
+    // types are valid for this particular renderer so we let it error there.
+
+    // Skip key warning if the type isn't valid since our key validation logic
+    // doesn't expect a non-string/function type and can throw confusing
+    // errors. We don't want exception behavior to differ between dev and
+    // prod. (Rendering will throw with a helpful message and as soon as the
+    // type is fixed, the key warnings will appear.)
+    for (var i = 2; i < arguments.length; i++) {
+      validateChildKeys(arguments[i]);
     }
-    function escape(key) {
-      var escaperLookup = { "=": "=0", ":": "=2" };
-      return (
-        "$" +
-        key.replace(/[=:]/g, function (match) {
-          return escaperLookup[match];
-        })
-      );
+
+    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.
+  }
+  var propName;
+
+  // Reserved names are extracted
+  var props = {};
+  var key = null;
+  if (config != null) {
+    {
+      if (!didWarnAboutOldJSXRuntime && '__self' in config &&
+      // Do not assume this is the result of an oudated JSX transform if key
+      // is present, because the modern JSX transform sometimes outputs
+      // createElement to preserve precedence between a static key and a
+      // spread key. To avoid false positive warnings, we never warn if
+      // there's a key.
+      !('key' in config)) {
+        didWarnAboutOldJSXRuntime = true;
+        console.warn('Your app (or one of its dependencies) is using an outdated JSX ' + 'transform. Update to the modern JSX transform for ' + 'faster performance: https://react.dev/link/new-jsx-transform');
+      }
     }
-    function getElementKey(element, index) {
-      return "object" === typeof element &&
-        null !== element &&
-        null != element.key
-        ? (checkKeyStringCoercion(element.key), escape("" + element.key))
-        : index.toString(36);
+    if (hasValidKey(config)) {
+      {
+        checkKeyStringCoercion(config.key);
+      }
+      key = '' + config.key;
     }
-    function noop$1() {}
-    function resolveThenable(thenable) {
-      switch (thenable.status) {
-        case "fulfilled":
-          return thenable.value;
-        case "rejected":
-          throw thenable.reason;
-        default:
-          switch (
-            ("string" === typeof thenable.status
-              ? thenable.then(noop$1, noop$1)
-              : ((thenable.status = "pending"),
-                thenable.then(
-                  function (fulfilledValue) {
-                    "pending" === thenable.status &&
-                      ((thenable.status = "fulfilled"),
-                      (thenable.value = fulfilledValue));
-                  },
-                  function (error) {
-                    "pending" === thenable.status &&
-                      ((thenable.status = "rejected"),
-                      (thenable.reason = error));
-                  }
-                )),
-            thenable.status)
-          ) {
-            case "fulfilled":
-              return thenable.value;
-            case "rejected":
-              throw thenable.reason;
-          }
+
+    // Remaining properties are added to a new props object
+    for (propName in config) {
+      if (hasOwnProperty.call(config, propName) &&
+      // Skip over reserved prop names
+      propName !== 'key' &&
+      // Even though we don't use these anymore in the runtime, we don't want
+      // them to appear as props, so in createElement we filter them out.
+      // We don't have to do this in the jsx() runtime because the jsx()
+      // transform never passed these as props; it used separate arguments.
+      propName !== '__self' && propName !== '__source') {
+        props[propName] = config[propName];
       }
-      throw thenable;
     }
-    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
-      var type = typeof children;
-      if ("undefined" === type || "boolean" === type) children = null;
-      var invokeCallback = !1;
-      if (null === children) invokeCallback = !0;
-      else
-        switch (type) {
-          case "bigint":
-          case "string":
-          case "number":
-            invokeCallback = !0;
-            break;
-          case "object":
-            switch (children.$$typeof) {
-              case REACT_ELEMENT_TYPE:
-              case REACT_PORTAL_TYPE:
-                invokeCallback = !0;
-                break;
-              case REACT_LAZY_TYPE:
-                return (
-                  (invokeCallback = children._init),
-                  mapIntoArray(
-                    invokeCallback(children._payload),
-                    array,
-                    escapedPrefix,
-                    nameSoFar,
-                    callback
-                  )
-                );
-            }
-        }
-      if (invokeCallback) {
-        invokeCallback = children;
-        callback = callback(invokeCallback);
-        var childKey =
-          "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
-        isArrayImpl(callback)
-          ? ((escapedPrefix = ""),
-            null != childKey &&
-              (escapedPrefix =
-                childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
-            mapIntoArray(callback, array, escapedPrefix, "", function (c) {
-              return c;
-            }))
-          : null != callback &&
-            (isValidElement(callback) &&
-              (null != callback.key &&
-                ((invokeCallback && invokeCallback.key === callback.key) ||
-                  checkKeyStringCoercion(callback.key)),
-              (escapedPrefix = cloneAndReplaceKey(
-                callback,
-                escapedPrefix +
-                  (null == callback.key ||
-                  (invokeCallback && invokeCallback.key === callback.key)
-                    ? ""
-                    : ("" + callback.key).replace(
-                        userProvidedKeyEscapeRegex,
-                        "$&/"
-                      ) + "/") +
-                  childKey
-              )),
-              "" !== nameSoFar &&
-                null != invokeCallback &&
-                isValidElement(invokeCallback) &&
-                null == invokeCallback.key &&
-                invokeCallback._store &&
-                !invokeCallback._store.validated &&
-                (escapedPrefix._store.validated = 2),
-              (callback = escapedPrefix)),
-            array.push(callback));
-        return 1;
+  }
+
+  // Children can be more than one argument, and those are transferred onto
+  // the newly allocated props object.
+  var childrenLength = arguments.length - 2;
+  if (childrenLength === 1) {
+    props.children = children;
+  } else if (childrenLength > 1) {
+    var childArray = Array(childrenLength);
+    for (var _i = 0; _i < childrenLength; _i++) {
+      childArray[_i] = arguments[_i + 2];
+    }
+    {
+      if (Object.freeze) {
+        Object.freeze(childArray);
       }
-      invokeCallback = 0;
-      childKey = "" === nameSoFar ? "." : nameSoFar + ":";
-      if (isArrayImpl(children))
-        for (var i = 0; i < children.length; i++)
-          (nameSoFar = children[i]),
-            (type = childKey + getElementKey(nameSoFar, i)),
-            (invokeCallback += mapIntoArray(
-              nameSoFar,
-              array,
-              escapedPrefix,
-              type,
-              callback
-            ));
-      else if (((i = getIteratorFn(children)), "function" === typeof i))
-        for (
-          i === children.entries &&
-            (didWarnAboutMaps ||
-              console.warn(
-                "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
-              ),
-            (didWarnAboutMaps = !0)),
-            children = i.call(children),
-            i = 0;
-          !(nameSoFar = children.next()).done;
-
-        )
-          (nameSoFar = nameSoFar.value),
-            (type = childKey + getElementKey(nameSoFar, i++)),
-            (invokeCallback += mapIntoArray(
-              nameSoFar,
-              array,
-              escapedPrefix,
-              type,
-              callback
-            ));
-      else if ("object" === type) {
-        if ("function" === typeof children.then)
-          return mapIntoArray(
-            resolveThenable(children),
-            array,
-            escapedPrefix,
-            nameSoFar,
-            callback
-          );
-        array = String(children);
-        throw Error(
-          "Objects are not valid as a React child (found: " +
-            ("[object Object]" === array
-              ? "object with keys {" + Object.keys(children).join(", ") + "}"
-              : array) +
-            "). If you meant to render a collection of children, use an array instead."
-        );
+    }
+    props.children = childArray;
+  }
+
+  // Resolve default props
+  if (type && type.defaultProps) {
+    var defaultProps = type.defaultProps;
+    for (propName in defaultProps) {
+      if (props[propName] === undefined) {
+        props[propName] = defaultProps[propName];
       }
-      return invokeCallback;
     }
-    function mapChildren(children, func, context) {
-      if (null == children) return children;
-      var result = [],
-        count = 0;
-      mapIntoArray(children, result, "", "", function (child) {
-        return func.call(context, child, count++);
-      });
-      return result;
+  }
+  {
+    if (key) {
+      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
+      defineKeyPropWarningGetter(props, displayName);
     }
-    function lazyInitializer(payload) {
-      if (-1 === payload._status) {
-        var ctor = payload._result;
-        ctor = ctor();
-        ctor.then(
-          function (moduleObject) {
-            if (0 === payload._status || -1 === payload._status)
-              (payload._status = 1), (payload._result = moduleObject);
-          },
-          function (error) {
-            if (0 === payload._status || -1 === payload._status)
-              (payload._status = 2), (payload._result = error);
-          }
-        );
-        -1 === payload._status &&
-          ((payload._status = 0), (payload._result = ctor));
+  }
+  var trackActualOwner = ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;
+  return ReactElement(type, key, undefined, undefined, getOwner(), props, (trackActualOwner ? Error('react-stack-top-frame') : unknownOwnerDebugStack), (trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask));
+}
+function cloneAndReplaceKey(oldElement, newKey) {
+  var clonedElement = ReactElement(oldElement.type, newKey, undefined, undefined, oldElement._owner, oldElement.props, oldElement._debugStack, oldElement._debugTask);
+  {
+    // The cloned element should inherit the original element's key validation.
+    if (oldElement._store) {
+      clonedElement._store.validated = oldElement._store.validated;
+    }
+  }
+  return clonedElement;
+}
+
+/**
+ * Clone and return a new ReactElement using element as the starting point.
+ * See https://reactjs.org/docs/react-api.html#cloneelement
+ */
+function cloneElement(element, config, children) {
+  if (element === null || element === undefined) {
+    throw new Error("The argument must be a React element, but you passed " + element + ".");
+  }
+  var propName;
+
+  // Original props are copied
+  var props = assign({}, element.props);
+
+  // Reserved names are extracted
+  var key = element.key;
+
+  // Owner will be preserved, unless ref is overridden
+  var owner = element._owner;
+  if (config != null) {
+    if (hasValidRef(config)) {
+      owner = getOwner() ;
+    }
+    if (hasValidKey(config)) {
+      {
+        checkKeyStringCoercion(config.key);
       }
-      if (1 === payload._status)
-        return (
-          (ctor = payload._result),
-          void 0 === ctor &&
-            console.error(
-              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
-              ctor
-            ),
-          "default" in ctor ||
-            console.error(
-              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
-              ctor
-            ),
-          ctor.default
-        );
-      throw payload._result;
+      key = '' + config.key;
     }
-    function resolveDispatcher() {
-      var dispatcher = ReactSharedInternals.H;
-      null === dispatcher &&
-        console.error(
-          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
-        );
-      return dispatcher;
+
+    // Remaining properties override existing props
+    for (propName in config) {
+      if (hasOwnProperty.call(config, propName) &&
+      // Skip over reserved prop names
+      propName !== 'key' &&
+      // ...and maybe these, too, though we currently rely on them for
+      // warnings and debug information in dev. Need to decide if we're OK
+      // with dropping them. In the jsx() runtime it's not an issue because
+      // the data gets passed as separate arguments instead of props, but
+      // it would be nice to stop relying on them entirely so we can drop
+      // them from the internal Fiber field.
+      propName !== '__self' && propName !== '__source' &&
+      // Undefined `ref` is ignored by cloneElement. We treat it the same as
+      // if the property were missing. This is mostly for
+      // backwards compatibility.
+      !(propName === 'ref' && config.ref === undefined)) {
+        props[propName] = config[propName];
+      }
     }
-    function noop() {}
-    function enqueueTask(task) {
-      if (null === enqueueTaskImpl)
-        try {
-          var requireString = ("require" + Math.random()).slice(0, 7);
-          enqueueTaskImpl = (module && module[requireString]).call(
-            module,
-            "timers"
-          ).setImmediate;
-        } catch (_err) {
-          enqueueTaskImpl = function (callback) {
-            !1 === didWarnAboutMessageChannel &&
-              ((didWarnAboutMessageChannel = !0),
-              "undefined" === typeof MessageChannel &&
-                console.error(
-                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
-                ));
-            var channel = new MessageChannel();
-            channel.port1.onmessage = callback;
-            channel.port2.postMessage(void 0);
-          };
-        }
-      return enqueueTaskImpl(task);
+  }
+
+  // Children can be more than one argument, and those are transferred onto
+  // the newly allocated props object.
+  var childrenLength = arguments.length - 2;
+  if (childrenLength === 1) {
+    props.children = children;
+  } else if (childrenLength > 1) {
+    var childArray = Array(childrenLength);
+    for (var i = 0; i < childrenLength; i++) {
+      childArray[i] = arguments[i + 2];
     }
-    function aggregateErrors(errors) {
-      return 1 < errors.length && "function" === typeof AggregateError
-        ? new AggregateError(errors)
-        : errors[0];
+    props.children = childArray;
+  }
+  var clonedElement = ReactElement(element.type, key, undefined, undefined, owner, props, element._debugStack, element._debugTask);
+  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
+    validateChildKeys(arguments[_i2]);
+  }
+  return clonedElement;
+}
+
+/**
+ * Ensure that every element either is passed in a static location, in an
+ * array with an explicit keys property defined, or in an object literal
+ * with valid key property.
+ *
+ * @internal
+ * @param {ReactNode} node Statically passed child of any type.
+ * @param {*} parentType node's parent's type.
+ */
+function validateChildKeys(node, parentType) {
+  {
+    // With owner stacks is, no warnings happens. All we do is
+    // mark elements as being in a valid static child position so they
+    // don't need keys.
+    if (isValidElement(node)) {
+      if (node._store) {
+        node._store.validated = 1;
+      }
     }
-    function popActScope(prevActQueue, prevActScopeDepth) {
-      prevActScopeDepth !== actScopeDepth - 1 &&
-        console.error(
-          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
-        );
-      actScopeDepth = prevActScopeDepth;
+  }
+}
+
+/**
+ * Verifies the object is a ReactElement.
+ * See https://reactjs.org/docs/react-api.html#isvalidelement
+ * @param {?object} object
+ * @return {boolean} True if `object` is a ReactElement.
+ * @final
+ */
+function isValidElement(object) {
+  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
+}
+
+var SEPARATOR = '.';
+var SUBSEPARATOR = ':';
+
+/**
+ * Escape and wrap key so it is safe to use as a reactid
+ *
+ * @param {string} key to be escaped.
+ * @return {string} the escaped key.
+ */
+function escape(key) {
+  var escapeRegex = /[=:]/g;
+  var escaperLookup = {
+    '=': '=0',
+    ':': '=2'
+  };
+  var escapedString = key.replace(escapeRegex, function (match) {
+    // $FlowFixMe[invalid-computed-prop]
+    return escaperLookup[match];
+  });
+  return '$' + escapedString;
+}
+
+/**
+ * TODO: Test that a single child and an array with one item have the same key
+ * pattern.
+ */
+
+var didWarnAboutMaps = false;
+var userProvidedKeyEscapeRegex = /\/+/g;
+function escapeUserProvidedKey(text) {
+  return text.replace(userProvidedKeyEscapeRegex, '$&/');
+}
+
+/**
+ * Generate a key string that identifies a element within a set.
+ *
+ * @param {*} element A element that could contain a manual key.
+ * @param {number} index Index that is used if a manual key is not provided.
+ * @return {string}
+ */
+function getElementKey(element, index) {
+  // Do some typechecking here since we call this blindly. We want to ensure
+  // that we don't block potential future ES APIs.
+  if (typeof element === 'object' && element !== null && element.key != null) {
+    // Explicit key
+    {
+      checkKeyStringCoercion(element.key);
     }
-    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
-      var queue = ReactSharedInternals.actQueue;
-      if (null !== queue)
-        if (0 !== queue.length)
-          try {
-            flushActQueue(queue);
-            enqueueTask(function () {
-              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
-            });
-            return;
-          } catch (error) {
-            ReactSharedInternals.thrownErrors.push(error);
-          }
-        else ReactSharedInternals.actQueue = null;
-      0 < ReactSharedInternals.thrownErrors.length
-        ? ((queue = aggregateErrors(ReactSharedInternals.thrownErrors)),
-          (ReactSharedInternals.thrownErrors.length = 0),
-          reject(queue))
-        : resolve(returnValue);
+    return escape('' + element.key);
+  }
+  // Implicit key determined by the index in the set
+  return index.toString(36);
+}
+function resolveThenable(thenable) {
+  switch (thenable.status) {
+    case 'fulfilled':
+      {
+        var fulfilledValue = thenable.value;
+        return fulfilledValue;
+      }
+    case 'rejected':
+      {
+        var rejectedError = thenable.reason;
+        throw rejectedError;
+      }
+    default:
+      {
+        if (typeof thenable.status === 'string') {
+          // Only instrument the thenable if the status if not defined. If
+          // it's defined, but an unknown value, assume it's been instrumented by
+          // some custom userspace implementation. We treat it as "pending".
+          // Attach a dummy listener, to ensure that any lazy initialization can
+          // happen. Flight lazily parses JSON when the value is actually awaited.
+          thenable.then(noop, noop);
+        } else {
+          // This is an uncached thenable that we haven't seen before.
+
+          // TODO: Detect infinite ping loops caused by uncached promises.
+
+          var pendingThenable = thenable;
+          pendingThenable.status = 'pending';
+          pendingThenable.then(function (fulfilledValue) {
+            if (thenable.status === 'pending') {
+              var fulfilledThenable = thenable;
+              fulfilledThenable.status = 'fulfilled';
+              fulfilledThenable.value = fulfilledValue;
+            }
+          }, function (error) {
+            if (thenable.status === 'pending') {
+              var rejectedThenable = thenable;
+              rejectedThenable.status = 'rejected';
+              rejectedThenable.reason = error;
+            }
+          });
+        }
+
+        // Check one more time in case the thenable resolved synchronously.
+        switch (thenable.status) {
+          case 'fulfilled':
+            {
+              var fulfilledThenable = thenable;
+              return fulfilledThenable.value;
+            }
+          case 'rejected':
+            {
+              var rejectedThenable = thenable;
+              var _rejectedError = rejectedThenable.reason;
+              throw _rejectedError;
+            }
+        }
+      }
+  }
+  throw thenable;
+}
+function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
+  var type = typeof children;
+  if (type === 'undefined' || type === 'boolean') {
+    // All of the above are perceived as null.
+    children = null;
+  }
+  var invokeCallback = false;
+  if (children === null) {
+    invokeCallback = true;
+  } else {
+    switch (type) {
+      case 'bigint':
+      case 'string':
+      case 'number':
+        invokeCallback = true;
+        break;
+      case 'object':
+        switch (children.$$typeof) {
+          case REACT_ELEMENT_TYPE:
+          case REACT_PORTAL_TYPE:
+            invokeCallback = true;
+            break;
+          case REACT_LAZY_TYPE:
+            var payload = children._payload;
+            var init = children._init;
+            return mapIntoArray(init(payload), array, escapedPrefix, nameSoFar, callback);
+        }
     }
-    function flushActQueue(queue) {
-      if (!isFlushing) {
-        isFlushing = !0;
-        var i = 0;
-        try {
-          for (; i < queue.length; i++) {
-            var callback = queue[i];
-            do {
-              ReactSharedInternals.didUsePromise = !1;
-              var continuation = callback(!1);
-              if (null !== continuation) {
-                if (ReactSharedInternals.didUsePromise) {
-                  queue[i] = callback;
-                  queue.splice(0, i);
-                  return;
-                }
-                callback = continuation;
-              } else break;
-            } while (1);
+  }
+  if (invokeCallback) {
+    var _child = children;
+    var mappedChild = callback(_child);
+    // If it's the only child, treat the name as if it was wrapped in an array
+    // so that it's consistent if the number of children grows:
+    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
+    if (isArray(mappedChild)) {
+      var escapedChildKey = '';
+      if (childKey != null) {
+        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
+      }
+      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
+        return c;
+      });
+    } else if (mappedChild != null) {
+      if (isValidElement(mappedChild)) {
+        {
+          // The `if` statement here prevents auto-disabling of the safe
+          // coercion ESLint rule, so we must manually disable it below.
+          // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key
+          if (mappedChild.key != null) {
+            if (!_child || _child.key !== mappedChild.key) {
+              checkKeyStringCoercion(mappedChild.key);
+            }
           }
-          queue.length = 0;
-        } catch (error) {
-          queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
-        } finally {
-          isFlushing = !1;
         }
+        var newChild = cloneAndReplaceKey(mappedChild,
+        // Keep both the (mapped) and old keys if they differ, just as
+        // traverseAllChildren used to do for objects as children
+        escapedPrefix + (
+        // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key
+        mappedChild.key != null && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey(
+        // $FlowFixMe[unsafe-addition]
+        '' + mappedChild.key // eslint-disable-line react-internal/safe-string-coercion
+        ) + '/' : '') + childKey);
+        {
+          // If `child` was an element without a `key`, we need to validate if
+          // it should have had a `key`, before assigning one to `mappedChild`.
+          // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key
+          if (nameSoFar !== '' && _child != null && isValidElement(_child) && _child.key == null) {
+            // We check truthiness of `child._store.validated` instead of being
+            // inequal to `1` to provide a bit of backward compatibility for any
+            // libraries (like `fbt`) which may be hacking this property.
+            if (_child._store && !_child._store.validated) {
+              // Mark this child as having failed validation, but let the actual
+              // renderer print the warning later.
+              newChild._store.validated = 2;
+            }
+          }
+        }
+        mappedChild = newChild;
       }
+      array.push(mappedChild);
     }
-    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
-      "function" ===
-        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&
-      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
-    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
-      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
-    Symbol.for("react.provider");
-    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
-      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
-      didWarnStateUpdateForUnmountedComponent = {},
-      ReactNoopUpdateQueue = {
-        isMounted: function () {
-          return !1;
-        },
-        enqueueForceUpdate: function (publicInstance) {
-          warnNoop(publicInstance, "forceUpdate");
-        },
-        enqueueReplaceState: function (publicInstance) {
-          warnNoop(publicInstance, "replaceState");
-        },
-        enqueueSetState: function (publicInstance) {
-          warnNoop(publicInstance, "setState");
+    return 1;
+  }
+  var child;
+  var nextName;
+  var subtreeCount = 0; // Count of children found in the current subtree.
+  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
+  if (isArray(children)) {
+    for (var i = 0; i < children.length; i++) {
+      child = children[i];
+      nextName = nextNamePrefix + getElementKey(child, i);
+      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
+    }
+  } else {
+    var iteratorFn = getIteratorFn(children);
+    if (typeof iteratorFn === 'function') {
+      var iterableChildren = children;
+      {
+        // Warn about using Maps as children
+        if (iteratorFn === iterableChildren.entries) {
+          if (!didWarnAboutMaps) {
+            console.warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
+          }
+          didWarnAboutMaps = true;
         }
-      },
-      assign = Object.assign,
-      emptyObject = {};
-    Object.freeze(emptyObject);
-    Component.prototype.isReactComponent = {};
-    Component.prototype.setState = function (partialState, callback) {
-      if (
-        "object" !== typeof partialState &&
-        "function" !== typeof partialState &&
-        null != partialState
-      )
-        throw Error(
-          "takes an object of state variables to update or a function which returns an object of state variables."
-        );
-      this.updater.enqueueSetState(this, partialState, callback, "setState");
-    };
-    Component.prototype.forceUpdate = function (callback) {
-      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
-    };
-    var deprecatedAPIs = {
-        isMounted: [
-          "isMounted",
-          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
-        ],
-        replaceState: [
-          "replaceState",
-          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
-        ]
-      },
-      fnName;
-    for (fnName in deprecatedAPIs)
-      deprecatedAPIs.hasOwnProperty(fnName) &&
-        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
-    ComponentDummy.prototype = Component.prototype;
-    deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
-    deprecatedAPIs.constructor = PureComponent;
-    assign(deprecatedAPIs, Component.prototype);
-    deprecatedAPIs.isPureReactComponent = !0;
-    var isArrayImpl = Array.isArray,
-      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
-      ReactSharedInternals = {
-        H: null,
-        A: null,
-        T: null,
-        S: null,
-        V: null,
-        actQueue: null,
-        isBatchingLegacy: !1,
-        didScheduleLegacyUpdate: !1,
-        didUsePromise: !1,
-        thrownErrors: [],
-        getCurrentStack: null,
-        recentlyCreatedOwnerStacks: 0
-      },
-      hasOwnProperty = Object.prototype.hasOwnProperty,
-      createTask = console.createTask
-        ? console.createTask
-        : function () {
-            return null;
-          };
-    deprecatedAPIs = {
-      "react-stack-bottom-frame": function (callStackForError) {
-        return callStackForError();
       }
-    };
-    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
-    var didWarnAboutElementRef = {};
-    var unknownOwnerDebugStack = deprecatedAPIs[
-      "react-stack-bottom-frame"
-    ].bind(deprecatedAPIs, UnknownOwner)();
-    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
-    var didWarnAboutMaps = !1,
-      userProvidedKeyEscapeRegex = /\/+/g,
-      reportGlobalError =
-        "function" === typeof reportError
-          ? reportError
-          : function (error) {
-              if (
-                "object" === typeof window &&
-                "function" === typeof window.ErrorEvent
-              ) {
-                var event = new window.ErrorEvent("error", {
-                  bubbles: !0,
-                  cancelable: !0,
-                  message:
-                    "object" === typeof error &&
-                    null !== error &&
-                    "string" === typeof error.message
-                      ? String(error.message)
-                      : String(error),
-                  error: error
-                });
-                if (!window.dispatchEvent(event)) return;
-              } else if (
-                "object" === typeof process &&
-                "function" === typeof process.emit
-              ) {
-                process.emit("uncaughtException", error);
-                return;
-              }
-              console.error(error);
-            },
-      didWarnAboutMessageChannel = !1,
-      enqueueTaskImpl = null,
-      actScopeDepth = 0,
-      didWarnNoAwaitAct = !1,
-      isFlushing = !1,
-      queueSeveralMicrotasks =
-        "function" === typeof queueMicrotask
-          ? function (callback) {
-              queueMicrotask(function () {
-                return queueMicrotask(callback);
-              });
-            }
-          : enqueueTask;
-    deprecatedAPIs = Object.freeze({
-      __proto__: null,
-      c: function (size) {
-        return resolveDispatcher().useMemoCache(size);
+      var iterator = iteratorFn.call(iterableChildren);
+      var step;
+      var ii = 0;
+      // $FlowFixMe[incompatible-use] `iteratorFn` might return null according to typing.
+      while (!(step = iterator.next()).done) {
+        child = step.value;
+        nextName = nextNamePrefix + getElementKey(child, ii++);
+        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
+      }
+    } else if (type === 'object') {
+      if (typeof children.then === 'function') {
+        return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
+      }
+
+      // eslint-disable-next-line react-internal/safe-string-coercion
+      var childrenString = String(children);
+      throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
+    }
+  }
+  return subtreeCount;
+}
+
+/**
+ * Maps children that are typically specified as `props.children`.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrenmap
+ *
+ * The provided mapFunction(child, index) will be called for each
+ * leaf child.
+ *
+ * @param {?*} children Children tree container.
+ * @param {function(*, int)} func The map function.
+ * @param {*} context Context for mapFunction.
+ * @return {object} Object containing the ordered map of results.
+ */
+function mapChildren(children, func, context) {
+  if (children == null) {
+    // $FlowFixMe limitation refining abstract types in Flow
+    return children;
+  }
+  var result = [];
+  var count = 0;
+  mapIntoArray(children, result, '', '', function (child) {
+    return func.call(context, child, count++);
+  });
+  return result;
+}
+
+/**
+ * Count the number of children that are typically specified as
+ * `props.children`.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrencount
+ *
+ * @param {?*} children Children tree container.
+ * @return {number} The number of children.
+ */
+function countChildren(children) {
+  var n = 0;
+  mapChildren(children, function () {
+    n++;
+    // Don't return anything
+  });
+  return n;
+}
+
+/**
+ * Iterates through children that are typically specified as `props.children`.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
+ *
+ * The provided forEachFunc(child, index) will be called for each
+ * leaf child.
+ *
+ * @param {?*} children Children tree container.
+ * @param {function(*, int)} forEachFunc
+ * @param {*} forEachContext Context for forEachContext.
+ */
+function forEachChildren(children, forEachFunc, forEachContext) {
+  mapChildren(children,
+  // $FlowFixMe[missing-this-annot]
+  function () {
+    forEachFunc.apply(this, arguments);
+    // Don't return anything.
+  }, forEachContext);
+}
+
+/**
+ * Flatten a children object (typically specified as `props.children`) and
+ * return an array with appropriately re-keyed children.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
+ */
+function toArray(children) {
+  return mapChildren(children, function (child) {
+    return child;
+  }) || [];
+}
+
+/**
+ * Returns the first child in a collection of children and verifies that there
+ * is only one child in the collection.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrenonly
+ *
+ * The current implementation of this function assumes that a single child gets
+ * passed without a wrapper, but the purpose of this helper function is to
+ * abstract away the particular structure of children.
+ *
+ * @param {?object} children Child collection structure.
+ * @return {ReactElement} The first and only `ReactElement` contained in the
+ * structure.
+ */
+function onlyChild(children) {
+  if (!isValidElement(children)) {
+    throw new Error('React.Children.only expected to receive a single React element child.');
+  }
+  return children;
+}
+
+function createContext(defaultValue) {
+  // TODO: Second argument used to be an optional `calculateChangedBits`
+  // function. Warn to reserve for future use?
+
+  var context = {
+    $$typeof: REACT_CONTEXT_TYPE,
+    // As a workaround to support multiple concurrent renderers, we categorize
+    // some renderers as primary and others as secondary. We only expect
+    // there to be two concurrent renderers at most: React Native (primary) and
+    // Fabric (secondary); React DOM (primary) and React ART (secondary).
+    // Secondary renderers store their context values on separate fields.
+    _currentValue: defaultValue,
+    _currentValue2: defaultValue,
+    // Used to track how many concurrent renderers this context currently
+    // supports within in a single renderer. Such as parallel server rendering.
+    _threadCount: 0,
+    // These are circular
+    Provider: null,
+    Consumer: null
+  };
+  context.Provider = context;
+  context.Consumer = {
+    $$typeof: REACT_CONSUMER_TYPE,
+    _context: context
+  };
+  {
+    context._currentRenderer = null;
+    context._currentRenderer2 = null;
+  }
+  return context;
+}
+
+var Uninitialized = -1;
+var Pending = 0;
+var Resolved = 1;
+var Rejected = 2;
+function lazyInitializer(payload) {
+  if (payload._status === Uninitialized) {
+    var ctor = payload._result;
+    var thenable = ctor();
+    // Transition to the next state.
+    // This might throw either because it's missing or throws. If so, we treat it
+    // as still uninitialized and try again next time. Which is the same as what
+    // happens if the ctor or any wrappers processing the ctor throws. This might
+    // end up fixing it if the resolution was a concurrency bug.
+    thenable.then(function (moduleObject) {
+      if (payload._status === Pending || payload._status === Uninitialized) {
+        // Transition to the next state.
+        var resolved = payload;
+        resolved._status = Resolved;
+        resolved._result = moduleObject;
+      }
+    }, function (error) {
+      if (payload._status === Pending || payload._status === Uninitialized) {
+        // Transition to the next state.
+        var rejected = payload;
+        rejected._status = Rejected;
+        rejected._result = error;
       }
     });
-    exports.Children = {
-      map: mapChildren,
-      forEach: function (children, forEachFunc, forEachContext) {
-        mapChildren(
-          children,
-          function () {
-            forEachFunc.apply(this, arguments);
-          },
-          forEachContext
-        );
-      },
-      count: function (children) {
-        var n = 0;
-        mapChildren(children, function () {
-          n++;
-        });
-        return n;
+    if (payload._status === Uninitialized) {
+      // In case, we're still uninitialized, then we're waiting for the thenable
+      // to resolve. Set it as pending in the meantime.
+      var pending = payload;
+      pending._status = Pending;
+      pending._result = thenable;
+    }
+  }
+  if (payload._status === Resolved) {
+    var moduleObject = payload._result;
+    {
+      if (moduleObject === undefined) {
+        console.error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' +
+        // Break up imports to avoid accidentally parsing them as dependencies.
+        'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
+      }
+    }
+    {
+      if (!('default' in moduleObject)) {
+        console.error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' +
+        // Break up imports to avoid accidentally parsing them as dependencies.
+        'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
+      }
+    }
+    return moduleObject.default;
+  } else {
+    throw payload._result;
+  }
+}
+function lazy(ctor) {
+  var payload = {
+    // We use these fields to store the result.
+    _status: Uninitialized,
+    _result: ctor
+  };
+  var lazyType = {
+    $$typeof: REACT_LAZY_TYPE,
+    _payload: payload,
+    _init: lazyInitializer
+  };
+  return lazyType;
+}
+
+function forwardRef(render) {
+  {
+    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
+      console.error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
+    } else if (typeof render !== 'function') {
+      console.error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
+    } else {
+      if (render.length !== 0 && render.length !== 2) {
+        console.error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
+      }
+    }
+    if (render != null) {
+      if (render.defaultProps != null) {
+        console.error('forwardRef render functions do not support defaultProps. ' + 'Did you accidentally pass a React component?');
+      }
+    }
+  }
+  var elementType = {
+    $$typeof: REACT_FORWARD_REF_TYPE,
+    render: render
+  };
+  {
+    var ownName;
+    Object.defineProperty(elementType, 'displayName', {
+      enumerable: false,
+      configurable: true,
+      get: function () {
+        return ownName;
       },
-      toArray: function (children) {
-        return (
-          mapChildren(children, function (child) {
-            return child;
-          }) || []
-        );
+      set: function (name) {
+        ownName = name;
+
+        // The inner component shouldn't inherit this display name in most cases,
+        // because the component may be used elsewhere.
+        // But it's nice for anonymous functions to inherit the name,
+        // so that our component-stack generation logic will display their frames.
+        // An anonymous function generally suggests a pattern like:
+        //   React.forwardRef((props, ref) => {...});
+        // This kind of inner function is not used elsewhere so the side effect is okay.
+        if (!render.name && !render.displayName) {
+          Object.defineProperty(render, 'name', {
+            value: name
+          });
+          render.displayName = name;
+        }
+      }
+    });
+  }
+  return elementType;
+}
+
+function memo(type, compare) {
+  {
+    if (type == null) {
+      console.error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
+    }
+  }
+  var elementType = {
+    $$typeof: REACT_MEMO_TYPE,
+    type: type,
+    compare: compare === undefined ? null : compare
+  };
+  {
+    var ownName;
+    Object.defineProperty(elementType, 'displayName', {
+      enumerable: false,
+      configurable: true,
+      get: function () {
+        return ownName;
       },
-      only: function (children) {
-        if (!isValidElement(children))
-          throw Error(
-            "React.Children.only expected to receive a single React element child."
-          );
-        return children;
+      set: function (name) {
+        ownName = name;
+
+        // The inner component shouldn't inherit this display name in most cases,
+        // because the component may be used elsewhere.
+        // But it's nice for anonymous functions to inherit the name,
+        // so that our component-stack generation logic will display their frames.
+        // An anonymous function generally suggests a pattern like:
+        //   React.memo((props) => {...});
+        // This kind of inner function is not used elsewhere so the side effect is okay.
+        if (!type.name && !type.displayName) {
+          Object.defineProperty(type, 'name', {
+            value: name
+          });
+          type.displayName = name;
+        }
       }
-    };
-    exports.Component = Component;
-    exports.Fragment = REACT_FRAGMENT_TYPE;
-    exports.Profiler = REACT_PROFILER_TYPE;
-    exports.PureComponent = PureComponent;
-    exports.StrictMode = REACT_STRICT_MODE_TYPE;
-    exports.Suspense = REACT_SUSPENSE_TYPE;
-    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
-      ReactSharedInternals;
-    exports.__COMPILER_RUNTIME = deprecatedAPIs;
-    exports.act = function (callback) {
-      var prevActQueue = ReactSharedInternals.actQueue,
-        prevActScopeDepth = actScopeDepth;
-      actScopeDepth++;
-      var queue = (ReactSharedInternals.actQueue =
-          null !== prevActQueue ? prevActQueue : []),
-        didAwaitActCall = !1;
-      try {
-        var result = callback();
-      } catch (error) {
-        ReactSharedInternals.thrownErrors.push(error);
+    });
+  }
+  return elementType;
+}
+
+function noopCache(fn) {
+  // On the client (i.e. not a Server Components environment) `cache` has
+  // no caching behavior. We just return the function as-is.
+  //
+  // We intend to implement client caching in a future major release. In the
+  // meantime, it's only exposed as an API so that Shared Components can use
+  // per-request caching on the server without breaking on the client. But it
+  // does mean they need to be aware of the behavioral difference.
+  //
+  // The rest of the behavior is the same as the server implementation  it
+  // returns a new reference, extra properties like `displayName` are not
+  // preserved, the length of the new function is 0, etc. That way apps can't
+  // accidentally depend on those details.
+  return function () {
+    // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.
+    return fn.apply(null, arguments);
+  };
+}
+var cache = noopCache ;
+function noopCacheSignal() {
+  return null;
+}
+var cacheSignal = noopCacheSignal ;
+
+function postpone(reason) {
+  // eslint-disable-next-line react-internal/prod-error-codes
+  var postponeInstance = new Error(reason);
+  postponeInstance.$$typeof = REACT_POSTPONE_TYPE;
+  throw postponeInstance;
+}
+
+function resolveDispatcher() {
+  var dispatcher = ReactSharedInternals.H;
+  {
+    if (dispatcher === null) {
+      console.error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.');
+    }
+  }
+  // Will result in a null access error if accessed outside render phase. We
+  // intentionally don't throw our own error because this is in a hot path.
+  // Also helps ensure this is inlined.
+  return dispatcher;
+}
+function getCacheForType(resourceType) {
+  var dispatcher = ReactSharedInternals.A;
+  if (!dispatcher) {
+    // If there is no dispatcher, then we treat this as not being cached.
+    return resourceType();
+  }
+  return dispatcher.getCacheForType(resourceType);
+}
+function useContext(Context) {
+  var dispatcher = resolveDispatcher();
+  {
+    if (Context.$$typeof === REACT_CONSUMER_TYPE) {
+      console.error('Calling useContext(Context.Consumer) is not supported and will cause bugs. ' + 'Did you mean to call useContext(Context) instead?');
+    }
+  }
+  return dispatcher.useContext(Context);
+}
+function useState(initialState) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useState(initialState);
+}
+function useReducer(reducer, initialArg, init) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useReducer(reducer, initialArg, init);
+}
+function useRef(initialValue) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useRef(initialValue);
+}
+function useEffect(create, deps) {
+  {
+    if (create == null) {
+      console.warn('React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?');
+    }
+  }
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useEffect(create, deps);
+}
+function useInsertionEffect(create, deps) {
+  {
+    if (create == null) {
+      console.warn('React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?');
+    }
+  }
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useInsertionEffect(create, deps);
+}
+function useLayoutEffect(create, deps) {
+  {
+    if (create == null) {
+      console.warn('React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?');
+    }
+  }
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useLayoutEffect(create, deps);
+}
+function useCallback(callback, deps) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useCallback(callback, deps);
+}
+function useMemo(create, deps) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useMemo(create, deps);
+}
+function useImperativeHandle(ref, create, deps) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useImperativeHandle(ref, create, deps);
+}
+function useDebugValue(value, formatterFn) {
+  {
+    var dispatcher = resolveDispatcher();
+    return dispatcher.useDebugValue(value, formatterFn);
+  }
+}
+function useTransition() {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useTransition();
+}
+function useDeferredValue(value, initialValue) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useDeferredValue(value, initialValue);
+}
+function useId() {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useId();
+}
+function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
+}
+function useCacheRefresh() {
+  var dispatcher = resolveDispatcher();
+  // $FlowFixMe[not-a-function] This is unstable, thus optional
+  return dispatcher.useCacheRefresh();
+}
+function use(usable) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.use(usable);
+}
+function useMemoCache(size) {
+  var dispatcher = resolveDispatcher();
+  // $FlowFixMe[not-a-function] This is unstable, thus optional
+  return dispatcher.useMemoCache(size);
+}
+function useEffectEvent(callback) {
+  var dispatcher = resolveDispatcher();
+  // $FlowFixMe[not-a-function] This is unstable, thus optional
+  return dispatcher.useEffectEvent(callback);
+}
+function useOptimistic(passthrough, reducer) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useOptimistic(passthrough, reducer);
+}
+function useActionState(action, initialState, permalink) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useActionState(action, initialState, permalink);
+}
+
+var reportGlobalError = typeof reportError === 'function' ?
+// In modern browsers, reportError will dispatch an error event,
+// emulating an uncaught JavaScript error.
+reportError : function (error) {
+  if (typeof window === 'object' && typeof window.ErrorEvent === 'function') {
+    // Browser Polyfill
+    var message = typeof error === 'object' && error !== null && typeof error.message === 'string' ?
+    // eslint-disable-next-line react-internal/safe-string-coercion
+    String(error.message) :
+    // eslint-disable-next-line react-internal/safe-string-coercion
+    String(error);
+    var event = new window.ErrorEvent('error', {
+      bubbles: true,
+      cancelable: true,
+      message: message,
+      error: error
+    });
+    var shouldLog = window.dispatchEvent(event);
+    if (!shouldLog) {
+      return;
+    }
+  } else if (typeof process === 'object' &&
+  // $FlowFixMe[method-unbinding]
+  typeof process.emit === 'function') {
+    // Node Polyfill
+    process.emit('uncaughtException', error);
+    return;
+  }
+  console['error'](error);
+};
+
+function releaseAsyncTransition() {
+  {
+    ReactSharedInternals.asyncTransitions--;
+  }
+}
+function startTransition(scope, options) {
+  var prevTransition = ReactSharedInternals.T;
+  var currentTransition = {};
+  {
+    currentTransition.types = prevTransition !== null ?
+    // If we're a nested transition, we should use the same set as the parent
+    // since we're conceptually always joined into the same entangled transition.
+    // In practice, this only matters if we add transition types in the inner
+    // without setting state. In that case, the inner transition can finish
+    // without waiting for the outer.
+    prevTransition.types : null;
+  }
+  {
+    currentTransition.gesture = null;
+  }
+  {
+    currentTransition._updatedFibers = new Set();
+  }
+  ReactSharedInternals.T = currentTransition;
+  try {
+    var returnValue = scope();
+    var onStartTransitionFinish = ReactSharedInternals.S;
+    if (onStartTransitionFinish !== null) {
+      onStartTransitionFinish(currentTransition, returnValue);
+    }
+    if (typeof returnValue === 'object' && returnValue !== null && typeof returnValue.then === 'function') {
+      if (true) {
+        // Keep track of the number of async transitions still running so we can warn.
+        ReactSharedInternals.asyncTransitions++;
+        returnValue.then(releaseAsyncTransition, releaseAsyncTransition);
       }
-      if (0 < ReactSharedInternals.thrownErrors.length)
-        throw (
-          (popActScope(prevActQueue, prevActScopeDepth),
-          (callback = aggregateErrors(ReactSharedInternals.thrownErrors)),
-          (ReactSharedInternals.thrownErrors.length = 0),
-          callback)
-        );
-      if (
-        null !== result &&
-        "object" === typeof result &&
-        "function" === typeof result.then
-      ) {
-        var thenable = result;
-        queueSeveralMicrotasks(function () {
-          didAwaitActCall ||
-            didWarnNoAwaitAct ||
-            ((didWarnNoAwaitAct = !0),
-            console.error(
-              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
-            ));
-        });
-        return {
-          then: function (resolve, reject) {
-            didAwaitActCall = !0;
-            thenable.then(
-              function (returnValue) {
-                popActScope(prevActQueue, prevActScopeDepth);
-                if (0 === prevActScopeDepth) {
-                  try {
-                    flushActQueue(queue),
-                      enqueueTask(function () {
-                        return recursivelyFlushAsyncActWork(
-                          returnValue,
-                          resolve,
-                          reject
-                        );
-                      });
-                  } catch (error$0) {
-                    ReactSharedInternals.thrownErrors.push(error$0);
-                  }
-                  if (0 < ReactSharedInternals.thrownErrors.length) {
-                    var _thrownError = aggregateErrors(
-                      ReactSharedInternals.thrownErrors
-                    );
-                    ReactSharedInternals.thrownErrors.length = 0;
-                    reject(_thrownError);
-                  }
-                } else resolve(returnValue);
-              },
-              function (error) {
-                popActScope(prevActQueue, prevActScopeDepth);
-                0 < ReactSharedInternals.thrownErrors.length
-                  ? ((error = aggregateErrors(
-                      ReactSharedInternals.thrownErrors
-                    )),
-                    (ReactSharedInternals.thrownErrors.length = 0),
-                    reject(error))
-                  : reject(error);
-              }
-            );
+      returnValue.then(noop, reportGlobalError);
+    }
+  } catch (error) {
+    reportGlobalError(error);
+  } finally {
+    warnAboutTransitionSubscriptions(prevTransition, currentTransition);
+    if (prevTransition !== null && currentTransition.types !== null) {
+      // If we created a new types set in the inner transition, we transfer it to the parent
+      // since they should share the same set. They're conceptually entangled.
+      {
+        if (prevTransition.types !== null && prevTransition.types !== currentTransition.types) {
+          // Just assert that assumption holds that we're not overriding anything.
+          console.error('We expected inner Transitions to have transferred the outer types set and ' + 'that you cannot add to the outer Transition while inside the inner.' + 'This is a bug in React.');
+        }
+      }
+      prevTransition.types = currentTransition.types;
+    }
+    ReactSharedInternals.T = prevTransition;
+  }
+}
+function startGestureTransition(provider, scope, options) {
+  if (provider == null) {
+    // We enforce this at runtime even though the type also enforces it since we
+    // use null as a signal internally so it would lead it to be treated as a
+    // regular transition otherwise.
+    throw new Error('A Timeline is required as the first argument to startGestureTransition.');
+  }
+  var prevTransition = ReactSharedInternals.T;
+  var currentTransition = {};
+  {
+    currentTransition.types = null;
+  }
+  {
+    currentTransition.gesture = provider;
+  }
+  {
+    currentTransition._updatedFibers = new Set();
+  }
+  ReactSharedInternals.T = currentTransition;
+  try {
+    var returnValue = scope();
+    if (true) {
+      if (typeof returnValue === 'object' && returnValue !== null && typeof returnValue.then === 'function') {
+        console.error('Cannot use an async function in startGestureTransition. It must be able to start immediately.');
+      }
+    }
+    var onStartGestureTransitionFinish = ReactSharedInternals.G;
+    if (onStartGestureTransitionFinish !== null) {
+      return onStartGestureTransitionFinish(currentTransition, provider, options);
+    }
+  } catch (error) {
+    reportGlobalError(error);
+  } finally {
+    ReactSharedInternals.T = prevTransition;
+  }
+  return noop;
+}
+function warnAboutTransitionSubscriptions(prevTransition, currentTransition) {
+  {
+    if (prevTransition === null && currentTransition._updatedFibers) {
+      var updatedFibersCount = currentTransition._updatedFibers.size;
+      currentTransition._updatedFibers.clear();
+      if (updatedFibersCount > 10) {
+        console.warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
+      }
+    }
+  }
+}
+
+function addTransitionType(type) {
+  {
+    var transition = ReactSharedInternals.T;
+    if (transition !== null) {
+      var transitionTypes = transition.types;
+      if (transitionTypes === null) {
+        transition.types = [type];
+      } else if (transitionTypes.indexOf(type) === -1) {
+        transitionTypes.push(type);
+      }
+    } else {
+      // We're in the async gap. Simulate an implicit startTransition around it.
+      {
+        if (ReactSharedInternals.asyncTransitions === 0) {
+          {
+            console.error('addTransitionType can only be called inside a `startTransition()` ' + 'or `startGestureTransition()` callback. ' + 'It must be associated with a specific Transition.');
+          }
+        }
+      }
+      startTransition(addTransitionType.bind(null, type));
+    }
+  }
+}
+
+var didWarnAboutMessageChannel = false;
+var enqueueTaskImpl = null;
+function enqueueTask(task) {
+  if (enqueueTaskImpl === null) {
+    try {
+      // read require off the module object to get around the bundlers.
+      // we don't want them to detect a require and bundle a Node polyfill.
+      var requireString = ('require' + Math.random()).slice(0, 7);
+      // $FlowFixMe[invalid-computed-prop]
+      var nodeRequire = module && module[requireString];
+      // assuming we're in node, let's try to get node's
+      // version of setImmediate, bypassing fake timers if any.
+      enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;
+    } catch (_err) {
+      // we're in a browser
+      // we can't use regular timers because they may still be faked
+      // so we try MessageChannel+postMessage instead
+      enqueueTaskImpl = function (callback) {
+        {
+          if (didWarnAboutMessageChannel === false) {
+            didWarnAboutMessageChannel = true;
+            if (typeof MessageChannel === 'undefined') {
+              console.error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');
+            }
           }
-        };
+        }
+        var channel = new MessageChannel();
+        channel.port1.onmessage = callback;
+        channel.port2.postMessage(undefined);
+      };
+    }
+  }
+  return enqueueTaskImpl(task);
+}
+
+// `act` calls can be nested, so we track the depth. This represents the
+// number of `act` scopes on the stack.
+var actScopeDepth = 0;
+
+// We only warn the first time you neglect to await an async `act` scope.
+var didWarnNoAwaitAct = false;
+function aggregateErrors(errors) {
+  if (errors.length > 1 && typeof AggregateError === 'function') {
+    // eslint-disable-next-line no-undef
+    return new AggregateError(errors);
+  }
+  return errors[0];
+}
+function act(callback) {
+  {
+    // When ReactSharedInternals.actQueue is not null, it signals to React that
+    // we're currently inside an `act` scope. React will push all its tasks to
+    // this queue instead of scheduling them with platform APIs.
+    //
+    // We set this to an empty array when we first enter an `act` scope, and
+    // only unset it once we've left the outermost `act` scope  remember that
+    // `act` calls can be nested.
+    //
+    // If we're already inside an `act` scope, reuse the existing queue.
+    var prevIsBatchingLegacy = false;
+    var prevActQueue = ReactSharedInternals.actQueue;
+    var prevActScopeDepth = actScopeDepth;
+    actScopeDepth++;
+    var queue = ReactSharedInternals.actQueue = prevActQueue !== null ? prevActQueue : [];
+    var result;
+    // This tracks whether the `act` call is awaited. In certain cases, not
+    // awaiting it is a mistake, so we will detect that and warn.
+    var didAwaitActCall = false;
+    try {
+      // Reset this to `false` right before entering the React work loop. The
+      // only place we ever read this fields is just below, right after running
+      // the callback. So we don't need to reset after the callback runs.
+      if (!disableLegacyMode) ;
+      result = callback();
+      var didScheduleLegacyUpdate = !disableLegacyMode ? ReactSharedInternals.didScheduleLegacyUpdate : false;
+
+      // Replicate behavior of original `act` implementation in legacy mode,
+      // which flushed updates immediately after the scope function exits, even
+      // if it's an async function.
+      if (!prevIsBatchingLegacy && didScheduleLegacyUpdate) {
+        flushActQueue(queue);
       }
-      var returnValue$jscomp$0 = result;
+      // `isBatchingLegacy` gets reset using the regular stack, not the async
+      // one used to track `act` scopes. Why, you may be wondering? Because
+      // that's how it worked before version 18. Yes, it's confusing! We should
+      // delete legacy mode!!
+      if (!disableLegacyMode) ;
+    } catch (error) {
+      // `isBatchingLegacy` gets reset using the regular stack, not the async
+      // one used to track `act` scopes. Why, you may be wondering? Because
+      // that's how it worked before version 18. Yes, it's confusing! We should
+      // delete legacy mode!!
+      ReactSharedInternals.thrownErrors.push(error);
+    }
+    if (ReactSharedInternals.thrownErrors.length > 0) {
       popActScope(prevActQueue, prevActScopeDepth);
-      0 === prevActScopeDepth &&
-        (flushActQueue(queue),
-        0 !== queue.length &&
-          queueSeveralMicrotasks(function () {
-            didAwaitActCall ||
-              didWarnNoAwaitAct ||
-              ((didWarnNoAwaitAct = !0),
-              console.error(
-                "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
-              ));
-          }),
-        (ReactSharedInternals.actQueue = null));
-      if (0 < ReactSharedInternals.thrownErrors.length)
-        throw (
-          ((callback = aggregateErrors(ReactSharedInternals.thrownErrors)),
-          (ReactSharedInternals.thrownErrors.length = 0),
-          callback)
-        );
+      var thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
+      ReactSharedInternals.thrownErrors.length = 0;
+      throw thrownError;
+    }
+    if (result !== null && typeof result === 'object' &&
+    // $FlowFixMe[method-unbinding]
+    typeof result.then === 'function') {
+      // A promise/thenable was returned from the callback. Wait for it to
+      // resolve before flushing the queue.
+      //
+      // If `act` were implemented as an async function, this whole block could
+      // be a single `await` call. That's really the only difference between
+      // this branch and the next one.
+      var thenable = result;
+
+      // Warn if the an `act` call with an async scope is not awaited. In a
+      // future release, consider making this an error.
+      queueSeveralMicrotasks(function () {
+        if (!didAwaitActCall && !didWarnNoAwaitAct) {
+          didWarnNoAwaitAct = true;
+          console.error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');
+        }
+      });
       return {
         then: function (resolve, reject) {
-          didAwaitActCall = !0;
-          0 === prevActScopeDepth
-            ? ((ReactSharedInternals.actQueue = queue),
-              enqueueTask(function () {
-                return recursivelyFlushAsyncActWork(
-                  returnValue$jscomp$0,
-                  resolve,
-                  reject
-                );
-              }))
-            : resolve(returnValue$jscomp$0);
+          didAwaitActCall = true;
+          thenable.then(function (returnValue) {
+            popActScope(prevActQueue, prevActScopeDepth);
+            if (prevActScopeDepth === 0) {
+              // We're exiting the outermost `act` scope. Flush the queue.
+              try {
+                flushActQueue(queue);
+                enqueueTask(function () {
+                  return (
+                    // Recursively flush tasks scheduled by a microtask.
+                    recursivelyFlushAsyncActWork(returnValue, resolve, reject)
+                  );
+                });
+              } catch (error) {
+                // `thenable` might not be a real promise, and `flushActQueue`
+                // might throw, so we need to wrap `flushActQueue` in a
+                // try/catch.
+                ReactSharedInternals.thrownErrors.push(error);
+              }
+              if (ReactSharedInternals.thrownErrors.length > 0) {
+                var _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
+                ReactSharedInternals.thrownErrors.length = 0;
+                reject(_thrownError);
+              }
+            } else {
+              resolve(returnValue);
+            }
+          }, function (error) {
+            popActScope(prevActQueue, prevActScopeDepth);
+            if (ReactSharedInternals.thrownErrors.length > 0) {
+              var _thrownError2 = aggregateErrors(ReactSharedInternals.thrownErrors);
+              ReactSharedInternals.thrownErrors.length = 0;
+              reject(_thrownError2);
+            } else {
+              reject(error);
+            }
+          });
         }
       };
-    };
-    exports.cache = function (fn) {
-      return function () {
-        return fn.apply(null, arguments);
-      };
-    };
-    exports.captureOwnerStack = function () {
-      var getCurrentStack = ReactSharedInternals.getCurrentStack;
-      return null === getCurrentStack ? null : getCurrentStack();
-    };
-    exports.cloneElement = function (element, config, children) {
-      if (null === element || void 0 === element)
-        throw Error(
-          "The argument must be a React element, but you passed " +
-            element +
-            "."
-        );
-      var props = assign({}, element.props),
-        key = element.key,
-        owner = element._owner;
-      if (null != config) {
-        var JSCompiler_inline_result;
-        a: {
-          if (
-            hasOwnProperty.call(config, "ref") &&
-            (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
-              config,
-              "ref"
-            ).get) &&
-            JSCompiler_inline_result.isReactWarning
-          ) {
-            JSCompiler_inline_result = !1;
-            break a;
-          }
-          JSCompiler_inline_result = void 0 !== config.ref;
+    } else {
+      var returnValue = result;
+      // The callback is not an async function. Exit the current
+      // scope immediately.
+      popActScope(prevActQueue, prevActScopeDepth);
+      if (prevActScopeDepth === 0) {
+        // We're exiting the outermost `act` scope. Flush the queue.
+        flushActQueue(queue);
+
+        // If the queue is not empty, it implies that we intentionally yielded
+        // to the main thread, because something suspended. We will continue
+        // in an asynchronous task.
+        //
+        // Warn if something suspends but the `act` call is not awaited.
+        // In a future release, consider making this an error.
+        if (queue.length !== 0) {
+          queueSeveralMicrotasks(function () {
+            if (!didAwaitActCall && !didWarnNoAwaitAct) {
+              didWarnNoAwaitAct = true;
+              console.error('A component suspended inside an `act` scope, but the ' + '`act` call was not awaited. When testing React ' + 'components that depend on asynchronous data, you must ' + 'await the result:\n\n' + 'await act(() => ...)');
+            }
+          });
         }
-        JSCompiler_inline_result && (owner = getOwner());
-        hasValidKey(config) &&
-          (checkKeyStringCoercion(config.key), (key = "" + config.key));
-        for (propName in config)
-          !hasOwnProperty.call(config, propName) ||
-            "key" === propName ||
-            "__self" === propName ||
-            "__source" === propName ||
-            ("ref" === propName && void 0 === config.ref) ||
-            (props[propName] = config[propName]);
-      }
-      var propName = arguments.length - 2;
-      if (1 === propName) props.children = children;
-      else if (1 < propName) {
-        JSCompiler_inline_result = Array(propName);
-        for (var i = 0; i < propName; i++)
-          JSCompiler_inline_result[i] = arguments[i + 2];
-        props.children = JSCompiler_inline_result;
-      }
-      props = ReactElement(
-        element.type,
-        key,
-        void 0,
-        void 0,
-        owner,
-        props,
-        element._debugStack,
-        element._debugTask
-      );
-      for (key = 2; key < arguments.length; key++)
-        (owner = arguments[key]),
-          isValidElement(owner) && owner._store && (owner._store.validated = 1);
-      return props;
-    };
-    exports.createContext = function (defaultValue) {
-      defaultValue = {
-        $$typeof: REACT_CONTEXT_TYPE,
-        _currentValue: defaultValue,
-        _currentValue2: defaultValue,
-        _threadCount: 0,
-        Provider: null,
-        Consumer: null
-      };
-      defaultValue.Provider = defaultValue;
-      defaultValue.Consumer = {
-        $$typeof: REACT_CONSUMER_TYPE,
-        _context: defaultValue
-      };
-      defaultValue._currentRenderer = null;
-      defaultValue._currentRenderer2 = null;
-      return defaultValue;
-    };
-    exports.createElement = function (type, config, children) {
-      for (var i = 2; i < arguments.length; i++) {
-        var node = arguments[i];
-        isValidElement(node) && node._store && (node._store.validated = 1);
+
+        // Like many things in this module, this is next part is confusing.
+        //
+        // We do not currently require every `act` call that is passed a
+        // callback to be awaited, through arguably we should. Since this
+        // callback was synchronous, we need to exit the current scope before
+        // returning.
+        //
+        // However, if thenable we're about to return *is* awaited, we'll
+        // immediately restore the current scope. So it shouldn't observable.
+        //
+        // This doesn't affect the case where the scope callback is async,
+        // because we always require those calls to be awaited.
+        //
+        // TODO: In a future version, consider always requiring all `act` calls
+        // to be awaited, regardless of whether the callback is sync or async.
+        ReactSharedInternals.actQueue = null;
       }
-      i = {};
-      node = null;
-      if (null != config)
-        for (propName in (didWarnAboutOldJSXRuntime ||
-          !("__self" in config) ||
-          "key" in config ||
-          ((didWarnAboutOldJSXRuntime = !0),
-          console.warn(
-            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
-          )),
-        hasValidKey(config) &&
-          (checkKeyStringCoercion(config.key), (node = "" + config.key)),
-        config))
-          hasOwnProperty.call(config, propName) &&
-            "key" !== propName &&
-            "__self" !== propName &&
-            "__source" !== propName &&
-            (i[propName] = config[propName]);
-      var childrenLength = arguments.length - 2;
-      if (1 === childrenLength) i.children = children;
-      else if (1 < childrenLength) {
-        for (
-          var childArray = Array(childrenLength), _i = 0;
-          _i < childrenLength;
-          _i++
-        )
-          childArray[_i] = arguments[_i + 2];
-        Object.freeze && Object.freeze(childArray);
-        i.children = childArray;
+      if (ReactSharedInternals.thrownErrors.length > 0) {
+        var _thrownError3 = aggregateErrors(ReactSharedInternals.thrownErrors);
+        ReactSharedInternals.thrownErrors.length = 0;
+        throw _thrownError3;
       }
-      if (type && type.defaultProps)
-        for (propName in ((childrenLength = type.defaultProps), childrenLength))
-          void 0 === i[propName] && (i[propName] = childrenLength[propName]);
-      node &&
-        defineKeyPropWarningGetter(
-          i,
-          "function" === typeof type
-            ? type.displayName || type.name || "Unknown"
-            : type
-        );
-      var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
-      return ReactElement(
-        type,
-        node,
-        void 0,
-        void 0,
-        getOwner(),
-        i,
-        propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
-        propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
-      );
-    };
-    exports.createRef = function () {
-      var refObject = { current: null };
-      Object.seal(refObject);
-      return refObject;
-    };
-    exports.forwardRef = function (render) {
-      null != render && render.$$typeof === REACT_MEMO_TYPE
-        ? console.error(
-            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
-          )
-        : "function" !== typeof render
-          ? console.error(
-              "forwardRef requires a render function but was given %s.",
-              null === render ? "null" : typeof render
-            )
-          : 0 !== render.length &&
-            2 !== render.length &&
-            console.error(
-              "forwardRef render functions accept exactly two parameters: props and ref. %s",
-              1 === render.length
-                ? "Did you forget to use the ref parameter?"
-                : "Any additional parameter will be undefined."
-            );
-      null != render &&
-        null != render.defaultProps &&
-        console.error(
-          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
-        );
-      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render: render },
-        ownName;
-      Object.defineProperty(elementType, "displayName", {
-        enumerable: !1,
-        configurable: !0,
-        get: function () {
-          return ownName;
-        },
-        set: function (name) {
-          ownName = name;
-          render.name ||
-            render.displayName ||
-            (Object.defineProperty(render, "name", { value: name }),
-            (render.displayName = name));
-        }
-      });
-      return elementType;
-    };
-    exports.isValidElement = isValidElement;
-    exports.lazy = function (ctor) {
       return {
-        $$typeof: REACT_LAZY_TYPE,
-        _payload: { _status: -1, _result: ctor },
-        _init: lazyInitializer
-      };
-    };
-    exports.memo = function (type, compare) {
-      null == type &&
-        console.error(
-          "memo: The first argument must be a component. Instead received: %s",
-          null === type ? "null" : typeof type
-        );
-      compare = {
-        $$typeof: REACT_MEMO_TYPE,
-        type: type,
-        compare: void 0 === compare ? null : compare
+        then: function (resolve, reject) {
+          didAwaitActCall = true;
+          if (prevActScopeDepth === 0) {
+            // If the `act` call is awaited, restore the queue we were
+            // using before (see long comment above) so we can flush it.
+            ReactSharedInternals.actQueue = queue;
+            enqueueTask(function () {
+              return (
+                // Recursively flush tasks scheduled by a microtask.
+                recursivelyFlushAsyncActWork(returnValue, resolve, reject)
+              );
+            });
+          } else {
+            resolve(returnValue);
+          }
+        }
       };
-      var ownName;
-      Object.defineProperty(compare, "displayName", {
-        enumerable: !1,
-        configurable: !0,
-        get: function () {
-          return ownName;
-        },
-        set: function (name) {
-          ownName = name;
-          type.name ||
-            type.displayName ||
-            (Object.defineProperty(type, "name", { value: name }),
-            (type.displayName = name));
+    }
+  }
+}
+function popActScope(prevActQueue, prevActScopeDepth) {
+  {
+    if (prevActScopeDepth !== actScopeDepth - 1) {
+      console.error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');
+    }
+    actScopeDepth = prevActScopeDepth;
+  }
+}
+function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
+  {
+    // Check if any tasks were scheduled asynchronously.
+    var queue = ReactSharedInternals.actQueue;
+    if (queue !== null) {
+      if (queue.length !== 0) {
+        // Async tasks were scheduled, mostly likely in a microtask.
+        // Keep flushing until there are no more.
+        try {
+          flushActQueue(queue);
+          // The work we just performed may have schedule additional async
+          // tasks. Wait a macrotask and check again.
+          enqueueTask(function () {
+            return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
+          });
+          return;
+        } catch (error) {
+          // Leave remaining tasks on the queue if something throws.
+          ReactSharedInternals.thrownErrors.push(error);
         }
-      });
-      return compare;
-    };
-    exports.startTransition = function (scope) {
-      var prevTransition = ReactSharedInternals.T,
-        currentTransition = {};
-      ReactSharedInternals.T = currentTransition;
-      currentTransition._updatedFibers = new Set();
+      } else {
+        // The queue is empty. We can finish.
+        ReactSharedInternals.actQueue = null;
+      }
+    }
+    if (ReactSharedInternals.thrownErrors.length > 0) {
+      var thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
+      ReactSharedInternals.thrownErrors.length = 0;
+      reject(thrownError);
+    } else {
+      resolve(returnValue);
+    }
+  }
+}
+var isFlushing = false;
+function flushActQueue(queue) {
+  {
+    if (!isFlushing) {
+      // Prevent re-entrance.
+      isFlushing = true;
+      var i = 0;
       try {
-        var returnValue = scope(),
-          onStartTransitionFinish = ReactSharedInternals.S;
-        null !== onStartTransitionFinish &&
-          onStartTransitionFinish(currentTransition, returnValue);
-        "object" === typeof returnValue &&
-          null !== returnValue &&
-          "function" === typeof returnValue.then &&
-          returnValue.then(noop, reportGlobalError);
+        for (; i < queue.length; i++) {
+          var callback = queue[i];
+          do {
+            ReactSharedInternals.didUsePromise = false;
+            var continuation = callback(false);
+            if (continuation !== null) {
+              if (ReactSharedInternals.didUsePromise) {
+                // The component just suspended. Yield to the main thread in
+                // case the promise is already resolved. If so, it will ping in
+                // a microtask and we can resume without unwinding the stack.
+                queue[i] = callback;
+                queue.splice(0, i);
+                return;
+              }
+              callback = continuation;
+            } else {
+              break;
+            }
+          } while (true);
+        }
+        // We flushed the entire queue.
+        queue.length = 0;
       } catch (error) {
-        reportGlobalError(error);
+        // If something throws, leave the remaining callbacks on the queue.
+        queue.splice(0, i + 1);
+        ReactSharedInternals.thrownErrors.push(error);
       } finally {
-        null === prevTransition &&
-          currentTransition._updatedFibers &&
-          ((scope = currentTransition._updatedFibers.size),
-          currentTransition._updatedFibers.clear(),
-          10 < scope &&
-            console.warn(
-              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
-            )),
-          (ReactSharedInternals.T = prevTransition);
+        isFlushing = false;
       }
-    };
-    exports.unstable_useCacheRefresh = function () {
-      return resolveDispatcher().useCacheRefresh();
-    };
-    exports.use = function (usable) {
-      return resolveDispatcher().use(usable);
-    };
-    exports.useActionState = function (action, initialState, permalink) {
-      return resolveDispatcher().useActionState(
-        action,
-        initialState,
-        permalink
-      );
-    };
-    exports.useCallback = function (callback, deps) {
-      return resolveDispatcher().useCallback(callback, deps);
-    };
-    exports.useContext = function (Context) {
-      var dispatcher = resolveDispatcher();
-      Context.$$typeof === REACT_CONSUMER_TYPE &&
-        console.error(
-          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
-        );
-      return dispatcher.useContext(Context);
-    };
-    exports.useDebugValue = function (value, formatterFn) {
-      return resolveDispatcher().useDebugValue(value, formatterFn);
-    };
-    exports.useDeferredValue = function (value, initialValue) {
-      return resolveDispatcher().useDeferredValue(value, initialValue);
-    };
-    exports.useEffect = function (create, createDeps, update) {
-      null == create &&
-        console.warn(
-          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
-        );
-      var dispatcher = resolveDispatcher();
-      if ("function" === typeof update)
-        throw Error(
-          "useEffect CRUD overload is not enabled in this build of React."
-        );
-      return dispatcher.useEffect(create, createDeps);
-    };
-    exports.useId = function () {
-      return resolveDispatcher().useId();
-    };
-    exports.useImperativeHandle = function (ref, create, deps) {
-      return resolveDispatcher().useImperativeHandle(ref, create, deps);
-    };
-    exports.useInsertionEffect = function (create, deps) {
-      null == create &&
-        console.warn(
-          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
-        );
-      return resolveDispatcher().useInsertionEffect(create, deps);
-    };
-    exports.useLayoutEffect = function (create, deps) {
-      null == create &&
-        console.warn(
-          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
-        );
-      return resolveDispatcher().useLayoutEffect(create, deps);
-    };
-    exports.useMemo = function (create, deps) {
-      return resolveDispatcher().useMemo(create, deps);
-    };
-    exports.useOptimistic = function (passthrough, reducer) {
-      return resolveDispatcher().useOptimistic(passthrough, reducer);
-    };
-    exports.useReducer = function (reducer, initialArg, init) {
-      return resolveDispatcher().useReducer(reducer, initialArg, init);
-    };
-    exports.useRef = function (initialValue) {
-      return resolveDispatcher().useRef(initialValue);
-    };
-    exports.useState = function (initialState) {
-      return resolveDispatcher().useState(initialState);
-    };
-    exports.useSyncExternalStore = function (
-      subscribe,
-      getSnapshot,
-      getServerSnapshot
-    ) {
-      return resolveDispatcher().useSyncExternalStore(
-        subscribe,
-        getSnapshot,
-        getServerSnapshot
-      );
-    };
-    exports.useTransition = function () {
-      return resolveDispatcher().useTransition();
-    };
-    exports.version = "19.1.0";
-    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
-      "function" ===
-        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&
-      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
-  })();
+    }
+  }
+}
+
+// Some of our warnings attempt to detect if the `act` call is awaited by
+// checking in an asynchronous task. Wait a few microtasks before checking. The
+// only reason one isn't sufficient is we want to accommodate the case where an
+// `act` call is returned from an async function without first being awaited,
+// since that's a somewhat common pattern. If you do this too many times in a
+// nested sequence, you might get a warning, but you can always fix by awaiting
+// the call.
+//
+// A macrotask would also work (and is the fallback) but depending on the test
+// environment it may cause the warning to fire too late.
+var queueSeveralMicrotasks = typeof queueMicrotask === 'function' ? function (callback) {
+  queueMicrotask(function () {
+    return queueMicrotask(callback);
+  });
+} : enqueueTask;
+
+function captureOwnerStack() {
+  {
+    var getCurrentStack = ReactSharedInternals.getCurrentStack;
+    if (getCurrentStack === null) {
+      return null;
+    }
+    // The current stack will be the owner stack which it is always here.
+    return getCurrentStack();
+  }
+}
+
+var ReactCompilerRuntime = /*#__PURE__*/Object.freeze({
+  __proto__: null,
+  c: useMemoCache
+});
+
+var Children = {
+  map: mapChildren,
+  forEach: forEachChildren,
+  count: countChildren,
+  toArray: toArray,
+  only: onlyChild
+};
+
+function experimental_useOptimistic(passthrough, reducer) {
+  {
+    console.error('useOptimistic is now in canary. Remove the experimental_ prefix. ' + 'The prefixed alias will be removed in an upcoming release.');
+  }
+  return useOptimistic(passthrough, reducer);
+}
+
+exports.Children = Children;
+exports.Component = Component;
+exports.Fragment = REACT_FRAGMENT_TYPE;
+exports.Profiler = REACT_PROFILER_TYPE;
+exports.PureComponent = PureComponent;
+exports.StrictMode = REACT_STRICT_MODE_TYPE;
+exports.Suspense = REACT_SUSPENSE_TYPE;
+exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
+exports.__COMPILER_RUNTIME = ReactCompilerRuntime;
+exports.act = act;
+exports.cache = cache;
+exports.cacheSignal = cacheSignal;
+exports.captureOwnerStack = captureOwnerStack;
+exports.cloneElement = cloneElement;
+exports.createContext = createContext;
+exports.createElement = createElement;
+exports.createRef = createRef;
+exports.experimental_useEffectEvent = useEffectEvent;
+exports.experimental_useOptimistic = experimental_useOptimistic;
+exports.forwardRef = forwardRef;
+exports.isValidElement = isValidElement;
+exports.lazy = lazy;
+exports.memo = memo;
+exports.startTransition = startTransition;
+exports.unstable_Activity = REACT_ACTIVITY_TYPE;
+exports.unstable_SuspenseList = REACT_SUSPENSE_LIST_TYPE;
+exports.unstable_ViewTransition = REACT_VIEW_TRANSITION_TYPE;
+exports.unstable_addTransitionType = addTransitionType;
+exports.unstable_getCacheForType = getCacheForType;
+exports.unstable_postpone = postpone;
+exports.unstable_startGestureTransition = startGestureTransition;
+exports.unstable_useCacheRefresh = useCacheRefresh;
+exports.use = use;
+exports.useActionState = useActionState;
+exports.useCallback = useCallback;
+exports.useContext = useContext;
+exports.useDebugValue = useDebugValue;
+exports.useDeferredValue = useDeferredValue;
+exports.useEffect = useEffect;
+exports.useId = useId;
+exports.useImperativeHandle = useImperativeHandle;
+exports.useInsertionEffect = useInsertionEffect;
+exports.useLayoutEffect = useLayoutEffect;
+exports.useMemo = useMemo;
+exports.useOptimistic = useOptimistic;
+exports.useReducer = useReducer;
+exports.useRef = useRef;
+exports.useState = useState;
+exports.useSyncExternalStore = useSyncExternalStore;
+exports.useTransition = useTransition;
+exports.version = ReactVersion;
+//# sourceMappingURL=react.development.js.map
diff --git a/cjs/react.development.js.map b/cjs/react.development.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..b4453fa1c7a192c5fde878c68938fde7ae852f29
--- /dev/null
+++ b/cjs/react.development.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react.development.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactVersion.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactFeatureFlags.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactNoopUpdateQueue.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/assign.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactBaseClasses.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactCreateRef.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/isArray.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/noop.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/CheckStringCoercion.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/getComponentNameFromType.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactSharedInternalsClient.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/hasOwnProperty.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXElement.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactChildren.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactContext.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactLazy.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactForwardRef.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactMemo.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactCacheClient.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactPostpone.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactHooks.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/reportGlobalError.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactStartTransition.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactTransitionType.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/enqueueTask.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactAct.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactOwnerStack.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactClient.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/index.experimental.development.js"],"sourcesContent":["export default '19.2.0-canary-602917c8-20250701';\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n */\n\n// -----------------------------------------------------------------------------\n// Land or remove (zero effort)\n//\n// Flags that can likely be deleted or landed without consequences\n// -----------------------------------------------------------------------------\n\n// None\n\n// -----------------------------------------------------------------------------\n// Killswitch\n//\n// Flags that exist solely to turn off a change in case it causes a regression\n// when it rolls out to prod. We should remove these as soon as possible.\n// -----------------------------------------------------------------------------\n\nexport const enableHydrationLaneScheduling = true;\n\n// -----------------------------------------------------------------------------\n// Land or remove (moderate effort)\n//\n// Flags that can be probably deleted or landed, but might require extra effort\n// like migrating internal callers or performance testing.\n// -----------------------------------------------------------------------------\n\n// TODO: Finish rolling out in www\nexport const favorSafetyOverHydrationPerf = true;\n\n// Need to remove didTimeout argument from Scheduler before landing\nexport const disableSchedulerTimeoutInWorkLoop = false;\n\n// -----------------------------------------------------------------------------\n// Slated for removal in the future (significant effort)\n//\n// These are experiments that didn't work out, and never shipped, but we can't\n// delete from the codebase until we migrate internal callers.\n// -----------------------------------------------------------------------------\n\n// Add a callback property to suspense to notify which promises are currently\n// in the update queue. This allows reporting and tracing of what is causing\n// the user to see a loading state.\n//\n// Also allows hydration callbacks to fire when a dehydrated boundary gets\n// hydrated or deleted.\n//\n// This will eventually be replaced by the Transition Tracing proposal.\nexport const enableSuspenseCallback = false;\n\n// Experimental Scope support.\nexport const enableScopeAPI = false;\n\n// Experimental Create Event Handle API.\nexport const enableCreateEventHandleAPI = false;\n\n// Support legacy Primer support on internal FB www\nexport const enableLegacyFBSupport = false;\n\n// -----------------------------------------------------------------------------\n// Ongoing experiments\n//\n// These are features that we're either actively exploring or are reasonably\n// likely to include in an upcoming release.\n// -----------------------------------------------------------------------------\n\n// Yield to the browser event loop and not just the scheduler event loop before passive effects.\n// Fix gated tests that fail with this flag enabled before turning it back on.\nexport const enableYieldingBeforePassive = false;\n\n// Experiment to intentionally yield less to block high framerate animations.\nexport const enableThrottledScheduling = false;\n\nexport const enableLegacyCache = __EXPERIMENTAL__;\n\nexport const enableAsyncIterableChildren = __EXPERIMENTAL__;\n\nexport const enableTaint = __EXPERIMENTAL__;\n\nexport const enablePostpone = __EXPERIMENTAL__;\n\nexport const enableHalt = __EXPERIMENTAL__;\n\nexport const enableViewTransition = __EXPERIMENTAL__;\n\nexport const enableGestureTransition = __EXPERIMENTAL__;\n\nexport const enableScrollEndPolyfill = __EXPERIMENTAL__;\n\nexport const enableSuspenseyImages = false;\n\nexport const enableFizzBlockingRender = __EXPERIMENTAL__; // rel=\"expect\"\n\nexport const enableSrcObject = __EXPERIMENTAL__;\n\nexport const enableHydrationChangeEvent = __EXPERIMENTAL__;\n\nexport const enableDefaultTransitionIndicator = __EXPERIMENTAL__;\n\n/**\n * Switches Fiber creation to a simple object instead of a constructor.\n */\nexport const enableObjectFiber = false;\n\nexport const enableTransitionTracing = false;\n\n// FB-only usage. The new API has different semantics.\nexport const enableLegacyHidden = false;\n\n// Enables unstable_avoidThisFallback feature in Fiber\nexport const enableSuspenseAvoidThisFallback = false;\n\nexport const enableCPUSuspense = __EXPERIMENTAL__;\n\n// Test this at Meta before enabling.\nexport const enableNoCloningMemoCache = false;\n\nexport const enableUseEffectEventHook = __EXPERIMENTAL__;\n\n// Test in www before enabling in open source.\n// Enables DOM-server to stream its instruction set as data-attributes\n// (handled with an MutationObserver) instead of inline-scripts\nexport const enableFizzExternalRuntime = __EXPERIMENTAL__;\n\nexport const alwaysThrottleRetries = true;\n\nexport const passChildrenWhenCloningPersistedNodes = false;\n\n/**\n * Enables a new Fiber flag used in persisted mode to reduce the number\n * of cloned host components.\n */\nexport const enablePersistedModeClonedFlag = false;\n\nexport const enableEagerAlternateStateNodeCleanup = true;\n\n/**\n * Enables an expiration time for retry lanes to avoid starvation.\n */\nexport const enableRetryLaneExpiration = false;\nexport const retryLaneExpirationMs = 5000;\nexport const syncLaneExpirationMs = 250;\nexport const transitionLaneExpirationMs = 5000;\n\n/**\n * Enables a new error detection for infinite render loops from updates caused\n * by setState or similar outside of the component owning the state.\n */\nexport const enableInfiniteRenderLoopDetection = false;\n\nexport const enableLazyPublicInstanceInFabric = false;\n\nexport const enableFragmentRefs = __EXPERIMENTAL__;\n\n// -----------------------------------------------------------------------------\n// Ready for next major.\n//\n// Alias __NEXT_MAJOR__ to __EXPERIMENTAL__ for easier skimming.\n// -----------------------------------------------------------------------------\n\n// TODO: Anything that's set to `true` in this section should either be cleaned\n// up (if it's on everywhere, including Meta and RN builds) or moved to a\n// different section of this file.\n\n// const __NEXT_MAJOR__ = __EXPERIMENTAL__;\n\n// Renames the internal symbol for elements since they have changed signature/constructor\nexport const renameElementSymbol = true;\n\n/**\n * Enables a fix to run insertion effect cleanup on hidden subtrees.\n */\nexport const enableHiddenSubtreeInsertionEffectCleanup = false;\n\n/**\n * Removes legacy style context defined using static `contextTypes` and consumed with static `childContextTypes`.\n */\nexport const disableLegacyContext = true;\n/**\n * Removes legacy style context just from function components.\n */\nexport const disableLegacyContextForFunctionComponents = true;\n\n// Enable the moveBefore() alternative to insertBefore(). This preserves states of moves.\nexport const enableMoveBefore = false;\n\n// Disabled caching behavior of `react/cache` in client runtimes.\nexport const disableClientCache = true;\n\n// Warn on any usage of ReactTestRenderer\nexport const enableReactTestRendererWarning = true;\n\n// Disables legacy mode\n// This allows us to land breaking changes to remove legacy mode APIs in experimental builds\n// before removing them in stable in the next Major\nexport const disableLegacyMode = true;\n\n// -----------------------------------------------------------------------------\n// Chopping Block\n//\n// Planned feature deprecations and breaking changes. Sorted roughly in order of\n// when we plan to enable them.\n// -----------------------------------------------------------------------------\n\n// -----------------------------------------------------------------------------\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nexport const disableCommentsAsDOMContainers = true;\n\nexport const enableTrustedTypesIntegration = false;\n\n// Prevent the value and checked attributes from syncing with their related\n// DOM properties\nexport const disableInputAttributeSyncing = false;\n\n// Disables children for <textarea> elements\nexport const disableTextareaChildren = false;\n\n// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n\n// Gather advanced timing metrics for Profiler subtrees.\nexport const enableProfilerTimer = __PROFILE__;\n\n// Adds performance.measure() marks using Chrome extensions to allow formatted\n// Component rendering tracks to show up in the Performance tab.\n// This flag will be used for both Server Component and Client Component tracks.\n// All calls should also be gated on enableProfilerTimer.\nexport const enableComponentPerformanceTrack = __EXPERIMENTAL__;\n\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nexport const enableSchedulingProfiler: boolean =\n  !enableComponentPerformanceTrack && __PROFILE__;\n\n// Record durations for commit and passive effects phases.\nexport const enableProfilerCommitHooks = __PROFILE__;\n\n// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nexport const enableProfilerNestedUpdatePhase = __PROFILE__;\n\nexport const enableAsyncDebugInfo = __EXPERIMENTAL__;\n\n// Track which Fiber(s) schedule render work.\nexport const enableUpdaterTracking = __PROFILE__;\n\nexport const ownerStackLimit = 1e4;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  if (__DEV__) {\n    const constructor = publicInstance.constructor;\n    const componentName =\n      (constructor && (constructor.displayName || constructor.name)) ||\n      'ReactClass';\n    const warningKey = `${componentName}.${callerName}`;\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n    console.error(\n      \"Can't call %s on a component that is not yet mounted. \" +\n        'This is a no-op, but it might indicate a bug in your application. ' +\n        'Instead, assign to `this.state` directly or define a `state = {};` ' +\n        'class property with the desired state in the %s component.',\n      callerName,\n      componentName,\n    );\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nconst ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (\n    publicInstance,\n    completeState,\n    callback,\n    callerName,\n  ) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (\n    publicInstance,\n    partialState,\n    callback,\n    callerName,\n  ) {\n    warnNoop(publicInstance, 'setState');\n  },\n};\n\nexport default ReactNoopUpdateQueue;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst assign = Object.assign;\n\nexport default assign;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ReactNoopUpdateQueue from './ReactNoopUpdateQueue';\nimport assign from 'shared/assign';\n\nconst emptyObject = {};\nif (__DEV__) {\n  Object.freeze(emptyObject);\n}\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nComponent.prototype.setState = function (partialState, callback) {\n  if (\n    typeof partialState !== 'object' &&\n    typeof partialState !== 'function' &&\n    partialState != null\n  ) {\n    throw new Error(\n      'takes an object of state variables to update or a ' +\n        'function which returns an object of state variables.',\n    );\n  }\n\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\nif (__DEV__) {\n  const deprecatedAPIs = {\n    isMounted: [\n      'isMounted',\n      'Instead, make sure to clean up subscriptions and pending requests in ' +\n        'componentWillUnmount to prevent memory leaks.',\n    ],\n    replaceState: [\n      'replaceState',\n      'Refactor your code to use setState instead (see ' +\n        'https://github.com/facebook/react/issues/3236).',\n    ],\n  };\n  const defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        console.warn(\n          '%s(...) is deprecated in plain JavaScript React classes. %s',\n          info[0],\n          info[1],\n        );\n        return undefined;\n      },\n    });\n  };\n  for (const fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\n\n/**\n * Convenience component with default shallow equality check for sCU.\n */\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nconst pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());\npureComponentPrototype.constructor = PureComponent;\n// Avoid an extra prototype jump for these methods.\nassign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\nexport {Component, PureComponent};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n * @flow\n */\n\nimport type {RefObject} from 'shared/ReactTypes';\n\n// an immutable object with a single mutable value\nexport function createRef(): RefObject {\n  const refObject = {\n    current: null,\n  };\n  if (__DEV__) {\n    Object.seal(refObject);\n  }\n  return refObject;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\ndeclare function isArray(a: mixed): boolean %checks(Array.isArray(a));\n\nconst isArrayImpl = Array.isArray;\n\nfunction isArray(a: mixed): boolean {\n  return isArrayImpl(a);\n}\n\nexport default isArray;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport default function noop() {}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value: mixed): string {\n  if (__DEV__) {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    const hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    const type =\n      (hasToStringTag && (value: any)[Symbol.toStringTag]) ||\n      (value: any).constructor.name ||\n      'Object';\n    // $FlowFixMe[incompatible-return]\n    return type;\n  }\n}\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value: mixed): boolean {\n  if (__DEV__) {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\n/** @noinline */\nfunction testStringCoercion(value: mixed) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + (value: any);\n}\n\nexport function checkAttributeStringCoercion(\n  value: mixed,\n  attributeName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` attribute is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        attributeName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkKeyStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided key is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkPropStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` prop is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkOptionStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` option is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkCSSPropertyStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` CSS property is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkHtmlStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided HTML markup uses a value of unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkFormFieldValueStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'Form field values (value, checked, defaultValue, or defaultChecked props)' +\n          ' must be strings, not %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {LazyComponent} from 'react/src/ReactLazy';\nimport type {ReactContext, ReactConsumerType} from 'shared/ReactTypes';\n\nimport {\n  REACT_CONTEXT_TYPE,\n  REACT_CONSUMER_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_TRACING_MARKER_TYPE,\n  REACT_VIEW_TRANSITION_TYPE,\n  REACT_ACTIVITY_TYPE,\n} from 'shared/ReactSymbols';\n\nimport {\n  enableTransitionTracing,\n  enableViewTransition,\n} from './ReactFeatureFlags';\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getWrappedName(\n  outerType: mixed,\n  innerType: any,\n  wrapperName: string,\n): string {\n  const displayName = (outerType: any).displayName;\n  if (displayName) {\n    return displayName;\n  }\n  const functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? `${wrapperName}(${functionName})` : wrapperName;\n}\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type: ReactContext<any>) {\n  return type.displayName || 'Context';\n}\n\nconst REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\n// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nexport default function getComponentNameFromType(type: mixed): string | null {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n  if (typeof type === 'function') {\n    if ((type: any).$$typeof === REACT_CLIENT_REFERENCE) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n    return (type: any).displayName || type.name || null;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n    case REACT_ACTIVITY_TYPE:\n      return 'Activity';\n    case REACT_VIEW_TRANSITION_TYPE:\n      if (enableViewTransition) {\n        return 'ViewTransition';\n      }\n    // Fall through\n    case REACT_TRACING_MARKER_TYPE:\n      if (enableTransitionTracing) {\n        return 'TracingMarker';\n      }\n  }\n  if (typeof type === 'object') {\n    if (__DEV__) {\n      if (typeof (type: any).tag === 'number') {\n        console.error(\n          'Received an unexpected object in getComponentNameFromType(). ' +\n            'This is likely a bug in React. Please file an issue.',\n        );\n      }\n    }\n    switch (type.$$typeof) {\n      case REACT_PORTAL_TYPE:\n        return 'Portal';\n      case REACT_CONTEXT_TYPE:\n        const context: ReactContext<any> = (type: any);\n        return getContextName(context);\n      case REACT_CONSUMER_TYPE:\n        const consumer: ReactConsumerType<any> = (type: any);\n        return getContextName(consumer._context) + '.Consumer';\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n      case REACT_MEMO_TYPE:\n        const outerName = (type: any).displayName || null;\n        if (outerName !== null) {\n          return outerName;\n        }\n        return getComponentNameFromType(type.type) || 'Memo';\n      case REACT_LAZY_TYPE: {\n        const lazyComponent: LazyComponent<any, any> = (type: any);\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n        try {\n          return getComponentNameFromType(init(payload));\n        } catch (x) {\n          return null;\n        }\n      }\n    }\n  }\n  return null;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {AsyncDispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {Transition} from './ReactStartTransition';\nimport type {GestureProvider, GestureOptions} from 'shared/ReactTypes';\n\nimport {enableGestureTransition} from 'shared/ReactFeatureFlags';\n\ntype onStartTransitionFinish = (Transition, mixed) => void;\ntype onStartGestureTransitionFinish = (\n  Transition,\n  GestureProvider,\n  ?GestureOptions,\n) => () => void;\n\nexport type SharedStateClient = {\n  H: null | Dispatcher, // ReactCurrentDispatcher for Hooks\n  A: null | AsyncDispatcher, // ReactCurrentCache for Cache\n  T: null | Transition, // ReactCurrentBatchConfig for Transitions\n  S: null | onStartTransitionFinish,\n  G: null | onStartGestureTransitionFinish,\n\n  // DEV-only\n\n  // ReactCurrentActQueue\n  actQueue: null | Array<RendererTask>,\n\n  // When zero this means we're outside an async startTransition.\n  asyncTransitions: number,\n\n  // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n  isBatchingLegacy: boolean,\n  didScheduleLegacyUpdate: boolean,\n\n  // Tracks whether something called `use` during the current batch of work.\n  // Determines whether we should yield to microtasks to unwrap already resolved\n  // promises without suspending.\n  didUsePromise: boolean,\n\n  // Track first uncaught error within this act\n  thrownErrors: Array<mixed>,\n\n  // ReactDebugCurrentFrame\n  getCurrentStack: null | (() => string),\n\n  // ReactOwnerStackReset\n  recentlyCreatedOwnerStacks: 0,\n};\n\nexport type RendererTask = boolean => RendererTask | null;\n\nconst ReactSharedInternals: SharedStateClient = ({\n  H: null,\n  A: null,\n  T: null,\n  S: null,\n}: any);\nif (enableGestureTransition) {\n  ReactSharedInternals.G = null;\n}\n\nif (__DEV__) {\n  ReactSharedInternals.actQueue = null;\n  ReactSharedInternals.asyncTransitions = 0;\n  ReactSharedInternals.isBatchingLegacy = false;\n  ReactSharedInternals.didScheduleLegacyUpdate = false;\n  ReactSharedInternals.didUsePromise = false;\n  ReactSharedInternals.thrownErrors = [];\n  // Stack implementation injected by the current renderer.\n  ReactSharedInternals.getCurrentStack = (null: null | (() => string));\n  ReactSharedInternals.recentlyCreatedOwnerStacks = 0;\n}\n\nexport default ReactSharedInternals;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// $FlowFixMe[method-unbinding]\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport default hasOwnProperty;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport assign from 'shared/assign';\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\nimport isArray from 'shared/isArray';\nimport {ownerStackLimit} from 'shared/ReactFeatureFlags';\n\nconst createTask =\n  // eslint-disable-next-line react-internal/no-production-logging\n  __DEV__ && console.createTask\n    ? // eslint-disable-next-line react-internal/no-production-logging\n      console.createTask\n    : () => null;\n\nfunction getTaskName(type) {\n  if (type === REACT_FRAGMENT_TYPE) {\n    return '<>';\n  }\n  if (\n    typeof type === 'object' &&\n    type !== null &&\n    type.$$typeof === REACT_LAZY_TYPE\n  ) {\n    // We don't want to eagerly initialize the initializer in DEV mode so we can't\n    // call it to extract the type so we don't know the type of this component.\n    return '<...>';\n  }\n  try {\n    const name = getComponentNameFromType(type);\n    return name ? '<' + name + '>' : '<...>';\n  } catch (x) {\n    return '<...>';\n  }\n}\n\nfunction getOwner() {\n  if (__DEV__) {\n    const dispatcher = ReactSharedInternals.A;\n    if (dispatcher === null) {\n      return null;\n    }\n    return dispatcher.getOwner();\n  }\n  return null;\n}\n\n/** @noinline */\nfunction UnknownOwner() {\n  /** @noinline */\n  return (() => Error('react-stack-top-frame'))();\n}\nconst createFakeCallStack = {\n  react_stack_bottom_frame: function (callStackForError) {\n    return callStackForError();\n  },\n};\n\nlet specialPropKeyWarningShown;\nlet didWarnAboutElementRef;\nlet didWarnAboutOldJSXRuntime;\nlet unknownOwnerDebugStack;\nlet unknownOwnerDebugTask;\n\nif (__DEV__) {\n  didWarnAboutElementRef = {};\n\n  // We use this technique to trick minifiers to preserve the function name.\n  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(\n    createFakeCallStack,\n    UnknownOwner,\n  )();\n  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://react.dev/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction elementRefGetterWithDeprecationWarning() {\n  if (__DEV__) {\n    const componentName = getComponentNameFromType(this.type);\n    if (!didWarnAboutElementRef[componentName]) {\n      didWarnAboutElementRef[componentName] = true;\n      console.error(\n        'Accessing element.ref was removed in React 19. ref is now a ' +\n          'regular prop. It will be removed from the JSX Element ' +\n          'type in a future release.',\n      );\n    }\n\n    // An undefined `element.ref` is coerced to `null` for\n    // backwards compatibility.\n    const refProp = this.props.ref;\n    return refProp !== undefined ? refProp : null;\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nfunction ReactElement(\n  type,\n  key,\n  self,\n  source,\n  owner,\n  props,\n  debugStack,\n  debugTask,\n) {\n  // Ignore whatever was passed as the ref argument and treat `props.ref` as\n  // the source of truth. The only thing we use this for is `element.ref`,\n  // which will log a deprecation warning on access. In the next release, we\n  // can remove `element.ref` as well as the `ref` argument.\n  const refProp = props.ref;\n\n  // An undefined `element.ref` is coerced to `null` for\n  // backwards compatibility.\n  const ref = refProp !== undefined ? refProp : null;\n\n  let element;\n  if (__DEV__) {\n    // In dev, make `ref` a non-enumerable property with a warning. It's non-\n    // enumerable so that test matchers and serializers don't access it and\n    // trigger the warning.\n    //\n    // `ref` will be removed from the element completely in a future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n\n      props,\n\n      // Record the component responsible for creating this element.\n      _owner: owner,\n    };\n    if (ref !== null) {\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        get: elementRefGetterWithDeprecationWarning,\n      });\n    } else {\n      // Don't warn on access if a ref is not given. This reduces false\n      // positives in cases where a test serializer uses\n      // getOwnPropertyDescriptors to compare objects, like Jest does, which is\n      // a problem because it bypasses non-enumerability.\n      //\n      // So unfortunately this will trigger a false positive warning in Jest\n      // when the diff is printed:\n      //\n      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);\n      //\n      // A bit sketchy, but this is what we've done for the `props.key` and\n      // `props.ref` accessors for years, which implies it will be good enough\n      // for `element.ref`, too. Let's see if anyone complains.\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        value: null,\n      });\n    }\n  } else {\n    // In prod, `ref` is a regular property and _owner doesn't exist.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n      ref,\n\n      props,\n    };\n  }\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: 0,\n    });\n    // debugInfo contains Server Component debug information.\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null,\n    });\n    Object.defineProperty(element, '_debugStack', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugStack,\n    });\n    Object.defineProperty(element, '_debugTask', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugTask,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxProd(type, config, maybeKey) {\n  let key = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  let props;\n  if (!('key' in config)) {\n    // If key was not spread in, we can reuse the original props object. This\n    // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n    // target and the compiler always passes a new object. For `createElement`,\n    // we can't assume a new object is passed every time because it can be\n    // called manually.\n    //\n    // Spreading key is a warning in dev. In a future release, we will not\n    // remove a spread key from the props object. (But we'll still warn.) We'll\n    // always pass the object straight through.\n    props = config;\n  } else {\n    // We need to remove reserved props (key, prop, ref). Create a fresh props\n    // object and copy over all the non-reserved props. We don't use `delete`\n    // because in V8 it will deopt the object to dictionary mode.\n    props = {};\n    for (const propName in config) {\n      // Skip over reserved prop names\n      if (propName !== 'key') {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    undefined,\n    undefined,\n  );\n}\n\n// While `jsxDEV` should never be called when running in production, we do\n// support `jsx` and `jsxs` when running in development. This supports the case\n// where a third-party dependency ships code that was compiled for production;\n// we want to still provide warnings in development.\n//\n// So these functions are the _dev_ implementations of the _production_\n// API signatures.\n//\n// Since these functions are dev-only, it's ok to add an indirection here. They\n// only exist to provide different versions of `isStaticChildren`. (We shouldn't\n// use this pattern for the prod versions, though, because it will add an call\n// frame.)\nexport function jsxProdSignatureRunningInDevWithDynamicChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = false;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nexport function jsxProdSignatureRunningInDevWithStaticChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = true;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nconst didWarnAboutKeySpread = {};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return jsxDEVImpl(\n    type,\n    config,\n    maybeKey,\n    isStaticChildren,\n    source,\n    self,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nfunction jsxDEVImpl(\n  type,\n  config,\n  maybeKey,\n  isStaticChildren,\n  source,\n  self,\n  debugStack,\n  debugTask,\n) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    // With owner stacks, we no longer need the type here so this comment is\n    // no longer true. Which is why we can run this even for invalid types.\n    const children = config.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          console.error(\n            'React.jsx: Static children should always be an array. ' +\n              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n              'Use the Babel transform instead.',\n          );\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n\n    // Warn about key spread regardless of whether the type is valid.\n    if (hasOwnProperty.call(config, 'key')) {\n      const componentName = getComponentNameFromType(type);\n      const keys = Object.keys(config).filter(k => k !== 'key');\n      const beforeExample =\n        keys.length > 0\n          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'\n          : '{key: someKey}';\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        const afterExample =\n          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n        console.error(\n          'A props object containing a \"key\" prop is being spread into JSX:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s {...props} />\\n' +\n            'React keys must be passed directly to JSX without using spread:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s key={someKey} {...props} />',\n          beforeExample,\n          componentName,\n          afterExample,\n          componentName,\n        );\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    let key = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    let props;\n    if (!('key' in config)) {\n      // If key was not spread in, we can reuse the original props object. This\n      // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n      // target and the compiler always passes a new object. For `createElement`,\n      // we can't assume a new object is passed every time because it can be\n      // called manually.\n      //\n      // Spreading key is a warning in dev. In a future release, we will not\n      // remove a spread key from the props object. (But we'll still warn.) We'll\n      // always pass the object straight through.\n      props = config;\n    } else {\n      // We need to remove reserved props (key, prop, ref). Create a fresh props\n      // object and copy over all the non-reserved props. We don't use `delete`\n      // because in V8 it will deopt the object to dictionary mode.\n      props = {};\n      for (const propName in config) {\n        // Skip over reserved prop names\n        if (propName !== 'key') {\n          props[propName] = config[propName];\n        }\n      }\n    }\n\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    return ReactElement(\n      type,\n      key,\n      self,\n      source,\n      getOwner(),\n      props,\n      debugStack,\n      debugTask,\n    );\n  }\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n  }\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const clonedElement = ReactElement(\n    oldElement.type,\n    newKey,\n    undefined,\n    undefined,\n    !__DEV__ ? undefined : oldElement._owner,\n    oldElement.props,\n    __DEV__ && oldElement._debugStack,\n    __DEV__ && oldElement._debugTask,\n  );\n  if (__DEV__) {\n    // The cloned element should inherit the original element's key validation.\n    if (oldElement._store) {\n      clonedElement._store.validated = oldElement._store.validated;\n    }\n  }\n  return clonedElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = !__DEV__ ? undefined : element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      owner = __DEV__ ? getOwner() : undefined;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // ...and maybe these, too, though we currently rely on them for\n        // warnings and debug information in dev. Need to decide if we're OK\n        // with dropping them. In the jsx() runtime it's not an issue because\n        // the data gets passed as separate arguments instead of props, but\n        // it would be nice to stop relying on them entirely so we can drop\n        // them from the internal Fiber field.\n        propName !== '__self' &&\n        propName !== '__source' &&\n        // Undefined `ref` is ignored by cloneElement. We treat it the same as\n        // if the property were missing. This is mostly for\n        // backwards compatibility.\n        !(propName === 'ref' && config.ref === undefined)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  const clonedElement = ReactElement(\n    element.type,\n    key,\n    undefined,\n    undefined,\n    owner,\n    props,\n    __DEV__ && element._debugStack,\n    __DEV__ && element._debugTask,\n  );\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], clonedElement.type);\n  }\n\n  return clonedElement;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    // With owner stacks is, no warnings happens. All we do is\n    // mark elements as being in a valid static child position so they\n    // don't need keys.\n    if (isValidElement(node)) {\n      if (node._store) {\n        node._store.validated = 1;\n      }\n    }\n  }\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  ReactNodeList,\n  Thenable,\n  PendingThenable,\n  FulfilledThenable,\n  RejectedThenable,\n} from 'shared/ReactTypes';\n\nimport isArray from 'shared/isArray';\nimport noop from 'shared/noop';\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_PORTAL_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\n\nimport {isValidElement, cloneAndReplaceKey} from './jsx/ReactJSXElement';\n\nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key: string): string {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedString = key.replace(escapeRegex, function (match) {\n    // $FlowFixMe[invalid-computed-prop]\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nlet didWarnAboutMaps = false;\n\nconst userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text: string): string {\n  return text.replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\n/**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getElementKey(element: any, index: number): string {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    // Explicit key\n    if (__DEV__) {\n      checkKeyStringCoercion(element.key);\n    }\n    return escape('' + element.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction resolveThenable<T>(thenable: Thenable<T>): T {\n  switch (thenable.status) {\n    case 'fulfilled': {\n      const fulfilledValue: T = thenable.value;\n      return fulfilledValue;\n    }\n    case 'rejected': {\n      const rejectedError = thenable.reason;\n      throw rejectedError;\n    }\n    default: {\n      if (typeof thenable.status === 'string') {\n        // Only instrument the thenable if the status if not defined. If\n        // it's defined, but an unknown value, assume it's been instrumented by\n        // some custom userspace implementation. We treat it as \"pending\".\n        // Attach a dummy listener, to ensure that any lazy initialization can\n        // happen. Flight lazily parses JSON when the value is actually awaited.\n        thenable.then(noop, noop);\n      } else {\n        // This is an uncached thenable that we haven't seen before.\n\n        // TODO: Detect infinite ping loops caused by uncached promises.\n\n        const pendingThenable: PendingThenable<T> = (thenable: any);\n        pendingThenable.status = 'pending';\n        pendingThenable.then(\n          fulfilledValue => {\n            if (thenable.status === 'pending') {\n              const fulfilledThenable: FulfilledThenable<T> = (thenable: any);\n              fulfilledThenable.status = 'fulfilled';\n              fulfilledThenable.value = fulfilledValue;\n            }\n          },\n          (error: mixed) => {\n            if (thenable.status === 'pending') {\n              const rejectedThenable: RejectedThenable<T> = (thenable: any);\n              rejectedThenable.status = 'rejected';\n              rejectedThenable.reason = error;\n            }\n          },\n        );\n      }\n\n      // Check one more time in case the thenable resolved synchronously.\n      switch ((thenable: Thenable<T>).status) {\n        case 'fulfilled': {\n          const fulfilledThenable: FulfilledThenable<T> = (thenable: any);\n          return fulfilledThenable.value;\n        }\n        case 'rejected': {\n          const rejectedThenable: RejectedThenable<T> = (thenable: any);\n          const rejectedError = rejectedThenable.reason;\n          throw rejectedError;\n        }\n      }\n    }\n  }\n  throw thenable;\n}\n\nfunction mapIntoArray(\n  children: ?ReactNodeList,\n  array: Array<React$Node>,\n  escapedPrefix: string,\n  nameSoFar: string,\n  callback: (?React$Node) => ?ReactNodeList,\n): number {\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  let invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'bigint':\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch ((children: any).$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n            break;\n          case REACT_LAZY_TYPE:\n            const payload = (children: any)._payload;\n            const init = (children: any)._init;\n            return mapIntoArray(\n              init(payload),\n              array,\n              escapedPrefix,\n              nameSoFar,\n              callback,\n            );\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    const child = children;\n    let mappedChild = callback(child);\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows:\n    const childKey =\n      nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;\n    if (isArray(mappedChild)) {\n      let escapedChildKey = '';\n      if (childKey != null) {\n        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n      }\n      mapIntoArray(mappedChild, array, escapedChildKey, '', c => c);\n    } else if (mappedChild != null) {\n      if (isValidElement(mappedChild)) {\n        if (__DEV__) {\n          // The `if` statement here prevents auto-disabling of the safe\n          // coercion ESLint rule, so we must manually disable it below.\n          // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n          if (mappedChild.key != null) {\n            if (!child || child.key !== mappedChild.key) {\n              checkKeyStringCoercion(mappedChild.key);\n            }\n          }\n        }\n        const newChild = cloneAndReplaceKey(\n          mappedChild,\n          // Keep both the (mapped) and old keys if they differ, just as\n          // traverseAllChildren used to do for objects as children\n          escapedPrefix +\n            // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n            (mappedChild.key != null &&\n            (!child || child.key !== mappedChild.key)\n              ? escapeUserProvidedKey(\n                  // $FlowFixMe[unsafe-addition]\n                  '' + mappedChild.key, // eslint-disable-line react-internal/safe-string-coercion\n                ) + '/'\n              : '') +\n            childKey,\n        );\n        if (__DEV__) {\n          // If `child` was an element without a `key`, we need to validate if\n          // it should have had a `key`, before assigning one to `mappedChild`.\n          // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n          if (\n            nameSoFar !== '' &&\n            child != null &&\n            isValidElement(child) &&\n            child.key == null\n          ) {\n            // We check truthiness of `child._store.validated` instead of being\n            // inequal to `1` to provide a bit of backward compatibility for any\n            // libraries (like `fbt`) which may be hacking this property.\n            if (child._store && !child._store.validated) {\n              // Mark this child as having failed validation, but let the actual\n              // renderer print the warning later.\n              newChild._store.validated = 2;\n            }\n          }\n        }\n        mappedChild = newChild;\n      }\n      array.push(mappedChild);\n    }\n    return 1;\n  }\n\n  let child;\n  let nextName;\n  let subtreeCount = 0; // Count of children found in the current subtree.\n  const nextNamePrefix =\n    nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getElementKey(child, i);\n      subtreeCount += mapIntoArray(\n        child,\n        array,\n        escapedPrefix,\n        nextName,\n        callback,\n      );\n    }\n  } else {\n    const iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      const iterableChildren: Iterable<React$Node> & {\n        entries: any,\n      } = (children: any);\n\n      if (__DEV__) {\n        // Warn about using Maps as children\n        if (iteratorFn === iterableChildren.entries) {\n          if (!didWarnAboutMaps) {\n            console.warn(\n              'Using Maps as children is not supported. ' +\n                'Use an array of keyed ReactElements instead.',\n            );\n          }\n          didWarnAboutMaps = true;\n        }\n      }\n\n      const iterator = iteratorFn.call(iterableChildren);\n      let step;\n      let ii = 0;\n      // $FlowFixMe[incompatible-use] `iteratorFn` might return null according to typing.\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getElementKey(child, ii++);\n        subtreeCount += mapIntoArray(\n          child,\n          array,\n          escapedPrefix,\n          nextName,\n          callback,\n        );\n      }\n    } else if (type === 'object') {\n      if (typeof (children: any).then === 'function') {\n        return mapIntoArray(\n          resolveThenable((children: any)),\n          array,\n          escapedPrefix,\n          nameSoFar,\n          callback,\n        );\n      }\n\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      const childrenString = String((children: any));\n\n      throw new Error(\n        `Objects are not valid as a React child (found: ${\n          childrenString === '[object Object]'\n            ? 'object with keys {' +\n              Object.keys((children: any)).join(', ') +\n              '}'\n            : childrenString\n        }). ` +\n          'If you meant to render a collection of children, use an array ' +\n          'instead.',\n      );\n    }\n  }\n\n  return subtreeCount;\n}\n\ntype MapFunc = (child: ?React$Node, index: number) => ?ReactNodeList;\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(\n  children: ?ReactNodeList,\n  func: MapFunc,\n  context: mixed,\n): ?Array<React$Node> {\n  if (children == null) {\n    // $FlowFixMe limitation refining abstract types in Flow\n    return children;\n  }\n  const result: Array<React$Node> = [];\n  let count = 0;\n  mapIntoArray(children, result, '', '', function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children: ?ReactNodeList): number {\n  let n = 0;\n  mapChildren(children, () => {\n    n++;\n    // Don't return anything\n  });\n  return n;\n}\n\ntype ForEachFunc = (child: ?React$Node) => void;\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(\n  children: ?ReactNodeList,\n  forEachFunc: ForEachFunc,\n  forEachContext: mixed,\n): void {\n  mapChildren(\n    children,\n    // $FlowFixMe[missing-this-annot]\n    function () {\n      forEachFunc.apply(this, arguments);\n      // Don't return anything.\n    },\n    forEachContext,\n  );\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\nfunction toArray(children: ?ReactNodeList): Array<React$Node> {\n  return mapChildren(children, child => child) || [];\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild<T>(children: T): T {\n  if (!isValidElement(children)) {\n    throw new Error(\n      'React.Children.only expected to receive a single React element child.',\n    );\n  }\n\n  return children;\n}\n\nexport {\n  forEachChildren as forEach,\n  mapChildren as map,\n  countChildren as count,\n  onlyChild as only,\n  toArray,\n};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {REACT_CONSUMER_TYPE, REACT_CONTEXT_TYPE} from 'shared/ReactSymbols';\n\nimport type {ReactContext} from 'shared/ReactTypes';\n\nexport function createContext<T>(defaultValue: T): ReactContext<T> {\n  // TODO: Second argument used to be an optional `calculateChangedBits`\n  // function. Warn to reserve for future use?\n\n  const context: ReactContext<T> = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    // As a workaround to support multiple concurrent renderers, we categorize\n    // some renderers as primary and others as secondary. We only expect\n    // there to be two concurrent renderers at most: React Native (primary) and\n    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n    // Secondary renderers store their context values on separate fields.\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    // Used to track how many concurrent renderers this context currently\n    // supports within in a single renderer. Such as parallel server rendering.\n    _threadCount: 0,\n    // These are circular\n    Provider: (null: any),\n    Consumer: (null: any),\n  };\n\n  context.Provider = context;\n  context.Consumer = {\n    $$typeof: REACT_CONSUMER_TYPE,\n    _context: context,\n  };\n  if (__DEV__) {\n    context._currentRenderer = null;\n    context._currentRenderer2 = null;\n  }\n\n  return context;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Wakeable, Thenable, ReactDebugInfo} from 'shared/ReactTypes';\n\nimport {REACT_LAZY_TYPE} from 'shared/ReactSymbols';\n\nconst Uninitialized = -1;\nconst Pending = 0;\nconst Resolved = 1;\nconst Rejected = 2;\n\ntype UninitializedPayload<T> = {\n  _status: -1,\n  _result: () => Thenable<{default: T, ...}>,\n};\n\ntype PendingPayload = {\n  _status: 0,\n  _result: Wakeable,\n};\n\ntype ResolvedPayload<T> = {\n  _status: 1,\n  _result: {default: T, ...},\n};\n\ntype RejectedPayload = {\n  _status: 2,\n  _result: mixed,\n};\n\ntype Payload<T> =\n  | UninitializedPayload<T>\n  | PendingPayload\n  | ResolvedPayload<T>\n  | RejectedPayload;\n\nexport type LazyComponent<T, P> = {\n  $$typeof: symbol | number,\n  _payload: P,\n  _init: (payload: P) => T,\n  _debugInfo?: null | ReactDebugInfo,\n};\n\nfunction lazyInitializer<T>(payload: Payload<T>): T {\n  if (payload._status === Uninitialized) {\n    const ctor = payload._result;\n    const thenable = ctor();\n    // Transition to the next state.\n    // This might throw either because it's missing or throws. If so, we treat it\n    // as still uninitialized and try again next time. Which is the same as what\n    // happens if the ctor or any wrappers processing the ctor throws. This might\n    // end up fixing it if the resolution was a concurrency bug.\n    thenable.then(\n      moduleObject => {\n        if (\n          (payload: Payload<T>)._status === Pending ||\n          payload._status === Uninitialized\n        ) {\n          // Transition to the next state.\n          const resolved: ResolvedPayload<T> = (payload: any);\n          resolved._status = Resolved;\n          resolved._result = moduleObject;\n        }\n      },\n      error => {\n        if (\n          (payload: Payload<T>)._status === Pending ||\n          payload._status === Uninitialized\n        ) {\n          // Transition to the next state.\n          const rejected: RejectedPayload = (payload: any);\n          rejected._status = Rejected;\n          rejected._result = error;\n        }\n      },\n    );\n    if (payload._status === Uninitialized) {\n      // In case, we're still uninitialized, then we're waiting for the thenable\n      // to resolve. Set it as pending in the meantime.\n      const pending: PendingPayload = (payload: any);\n      pending._status = Pending;\n      pending._result = thenable;\n    }\n  }\n  if (payload._status === Resolved) {\n    const moduleObject = payload._result;\n    if (__DEV__) {\n      if (moduleObject === undefined) {\n        console.error(\n          'lazy: Expected the result of a dynamic imp' +\n            'ort() call. ' +\n            'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' +\n            \"ort('./MyComponent'))\\n\\n\" +\n            'Did you accidentally put curly braces around the import?',\n          moduleObject,\n        );\n      }\n    }\n    if (__DEV__) {\n      if (!('default' in moduleObject)) {\n        console.error(\n          'lazy: Expected the result of a dynamic imp' +\n            'ort() call. ' +\n            'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' +\n            \"ort('./MyComponent'))\",\n          moduleObject,\n        );\n      }\n    }\n    return moduleObject.default;\n  } else {\n    throw payload._result;\n  }\n}\n\nexport function lazy<T>(\n  ctor: () => Thenable<{default: T, ...}>,\n): LazyComponent<T, Payload<T>> {\n  const payload: Payload<T> = {\n    // We use these fields to store the result.\n    _status: Uninitialized,\n    _result: ctor,\n  };\n\n  const lazyType: LazyComponent<T, Payload<T>> = {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: payload,\n    _init: lazyInitializer,\n  };\n\n  return lazyType;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n */\n\nimport {REACT_FORWARD_REF_TYPE, REACT_MEMO_TYPE} from 'shared/ReactSymbols';\n\nexport function forwardRef<Props, ElementType: React$ElementType>(\n  render: (\n    props: Props,\n    ref: React$RefSetter<React$ElementRef<ElementType>>,\n  ) => React$Node,\n) {\n  if (__DEV__) {\n    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n      console.error(\n        'forwardRef requires a render function but received a `memo` ' +\n          'component. Instead of forwardRef(memo(...)), use ' +\n          'memo(forwardRef(...)).',\n      );\n    } else if (typeof render !== 'function') {\n      console.error(\n        'forwardRef requires a render function but was given %s.',\n        render === null ? 'null' : typeof render,\n      );\n    } else {\n      if (render.length !== 0 && render.length !== 2) {\n        console.error(\n          'forwardRef render functions accept exactly two parameters: props and ref. %s',\n          render.length === 1\n            ? 'Did you forget to use the ref parameter?'\n            : 'Any additional parameter will be undefined.',\n        );\n      }\n    }\n\n    if (render != null) {\n      if (render.defaultProps != null) {\n        console.error(\n          'forwardRef render functions do not support defaultProps. ' +\n            'Did you accidentally pass a React component?',\n        );\n      }\n    }\n  }\n\n  const elementType = {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render,\n  };\n  if (__DEV__) {\n    let ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name;\n\n        // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.forwardRef((props, ref) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n        if (!render.name && !render.displayName) {\n          Object.defineProperty(render, 'name', {\n            value: name,\n          });\n          render.displayName = name;\n        }\n      },\n    });\n  }\n  return elementType;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n */\n\nimport {REACT_MEMO_TYPE} from 'shared/ReactSymbols';\n\nexport function memo<Props>(\n  type: React$ElementType,\n  compare?: (oldProps: Props, newProps: Props) => boolean,\n) {\n  if (__DEV__) {\n    if (type == null) {\n      console.error(\n        'memo: The first argument must be a component. Instead ' +\n          'received: %s',\n        type === null ? 'null' : typeof type,\n      );\n    }\n  }\n  const elementType = {\n    $$typeof: REACT_MEMO_TYPE,\n    type,\n    compare: compare === undefined ? null : compare,\n  };\n  if (__DEV__) {\n    let ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name;\n\n        // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.memo((props) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n        if (!type.name && !type.displayName) {\n          Object.defineProperty(type, 'name', {\n            value: name,\n          });\n          type.displayName = name;\n        }\n      },\n    });\n  }\n  return elementType;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {disableClientCache} from 'shared/ReactFeatureFlags';\nimport {\n  cache as cacheImpl,\n  cacheSignal as cacheSignalImpl,\n} from './ReactCacheImpl';\n\nfunction noopCache<A: Iterable<mixed>, T>(fn: (...A) => T): (...A) => T {\n  // On the client (i.e. not a Server Components environment) `cache` has\n  // no caching behavior. We just return the function as-is.\n  //\n  // We intend to implement client caching in a future major release. In the\n  // meantime, it's only exposed as an API so that Shared Components can use\n  // per-request caching on the server without breaking on the client. But it\n  // does mean they need to be aware of the behavioral difference.\n  //\n  // The rest of the behavior is the same as the server implementation  it\n  // returns a new reference, extra properties like `displayName` are not\n  // preserved, the length of the new function is 0, etc. That way apps can't\n  // accidentally depend on those details.\n  return function () {\n    // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.\n    return fn.apply(null, arguments);\n  };\n}\n\nexport const cache: typeof noopCache = disableClientCache\n  ? noopCache\n  : cacheImpl;\n\nfunction noopCacheSignal(): null | AbortSignal {\n  return null;\n}\n\nexport const cacheSignal: () => null | AbortSignal = disableClientCache\n  ? noopCacheSignal\n  : cacheSignalImpl;\n","/**\n * Copyright (c) Meta Platforms, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {REACT_POSTPONE_TYPE} from 'shared/ReactSymbols';\n\ndeclare class Postpone extends Error {\n  $$typeof: symbol;\n}\n\nexport type {Postpone};\n\nexport function postpone(reason: string): void {\n  // eslint-disable-next-line react-internal/prod-error-codes\n  const postponeInstance: Postpone = (new Error(reason): any);\n  postponeInstance.$$typeof = REACT_POSTPONE_TYPE;\n  throw postponeInstance;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  ReactContext,\n  StartTransitionOptions,\n  Usable,\n  Awaited,\n} from 'shared/ReactTypes';\nimport {REACT_CONSUMER_TYPE} from 'shared/ReactSymbols';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\ntype BasicStateAction<S> = (S => S) | S;\ntype Dispatch<A> = A => void;\n\nfunction resolveDispatcher() {\n  const dispatcher = ReactSharedInternals.H;\n  if (__DEV__) {\n    if (dispatcher === null) {\n      console.error(\n        'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n          ' one of the following reasons:\\n' +\n          '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n          '2. You might be breaking the Rules of Hooks\\n' +\n          '3. You might have more than one copy of React in the same app\\n' +\n          'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.',\n      );\n    }\n  }\n  // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n  return ((dispatcher: any): Dispatcher);\n}\n\nexport function getCacheForType<T>(resourceType: () => T): T {\n  const dispatcher = ReactSharedInternals.A;\n  if (!dispatcher) {\n    // If there is no dispatcher, then we treat this as not being cached.\n    return resourceType();\n  }\n  return dispatcher.getCacheForType(resourceType);\n}\n\nexport function useContext<T>(Context: ReactContext<T>): T {\n  const dispatcher = resolveDispatcher();\n  if (__DEV__) {\n    if (Context.$$typeof === REACT_CONSUMER_TYPE) {\n      console.error(\n        'Calling useContext(Context.Consumer) is not supported and will cause bugs. ' +\n          'Did you mean to call useContext(Context) instead?',\n      );\n    }\n  }\n  return dispatcher.useContext(Context);\n}\n\nexport function useState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n\nexport function useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\n\nexport function useRef<T>(initialValue: T): {current: T} {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\n\nexport function useEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\n\nexport function useInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\n\nexport function useLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\n\nexport function useCallback<T>(\n  callback: T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\n\nexport function useMemo<T>(\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\n\nexport function useImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\n\nexport function useDebugValue<T>(\n  value: T,\n  formatterFn: ?(value: T) => mixed,\n): void {\n  if (__DEV__) {\n    const dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\n\nexport function useTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\n\nexport function useDeferredValue<T>(value: T, initialValue?: T): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value, initialValue);\n}\n\nexport function useId(): string {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\n\nexport function useSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n  );\n}\n\nexport function useCacheRefresh(): <T>(?() => T, ?T) => void {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useCacheRefresh();\n}\n\nexport function use<T>(usable: Usable<T>): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.use(usable);\n}\n\nexport function useMemoCache(size: number): Array<mixed> {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useMemoCache(size);\n}\n\nexport function useEffectEvent<Args, F: (...Array<Args>) => mixed>(\n  callback: F,\n): F {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useEffectEvent(callback);\n}\n\nexport function useOptimistic<S, A>(\n  passthrough: S,\n  reducer: ?(S, A) => S,\n): [S, (A) => void] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useOptimistic(passthrough, reducer);\n}\n\nexport function useActionState<S, P>(\n  action: (Awaited<S>, P) => S,\n  initialState: Awaited<S>,\n  permalink?: string,\n): [Awaited<S>, (P) => void, boolean] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useActionState(action, initialState, permalink);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst reportGlobalError: (error: mixed) => void =\n  typeof reportError === 'function'\n    ? // In modern browsers, reportError will dispatch an error event,\n      // emulating an uncaught JavaScript error.\n      reportError\n    : error => {\n        if (\n          typeof window === 'object' &&\n          typeof window.ErrorEvent === 'function'\n        ) {\n          // Browser Polyfill\n          const message =\n            typeof error === 'object' &&\n            error !== null &&\n            typeof error.message === 'string'\n              ? // eslint-disable-next-line react-internal/safe-string-coercion\n                String(error.message)\n              : // eslint-disable-next-line react-internal/safe-string-coercion\n                String(error);\n          const event = new window.ErrorEvent('error', {\n            bubbles: true,\n            cancelable: true,\n            message: message,\n            error: error,\n          });\n          const shouldLog = window.dispatchEvent(event);\n          if (!shouldLog) {\n            return;\n          }\n        } else if (\n          typeof process === 'object' &&\n          // $FlowFixMe[method-unbinding]\n          typeof process.emit === 'function'\n        ) {\n          // Node Polyfill\n          process.emit('uncaughtException', error);\n          return;\n        }\n        console['error'](error);\n      };\n\nexport default reportGlobalError;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  StartTransitionOptions,\n  GestureProvider,\n  GestureOptions,\n} from 'shared/ReactTypes';\nimport type {TransitionTypes} from './ReactTransitionType';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nimport {\n  enableTransitionTracing,\n  enableViewTransition,\n  enableGestureTransition,\n} from 'shared/ReactFeatureFlags';\n\nimport reportGlobalError from 'shared/reportGlobalError';\n\nimport noop from 'shared/noop';\n\nexport type Transition = {\n  types: null | TransitionTypes, // enableViewTransition\n  gesture: null | GestureProvider, // enableGestureTransition\n  name: null | string, // enableTransitionTracing only\n  startTime: number, // enableTransitionTracing only\n  _updatedFibers: Set<Fiber>, // DEV-only\n  ...\n};\n\nfunction releaseAsyncTransition() {\n  if (__DEV__) {\n    ReactSharedInternals.asyncTransitions--;\n  }\n}\n\nexport function startTransition(\n  scope: () => void,\n  options?: StartTransitionOptions,\n): void {\n  const prevTransition = ReactSharedInternals.T;\n  const currentTransition: Transition = ({}: any);\n  if (enableViewTransition) {\n    currentTransition.types =\n      prevTransition !== null\n        ? // If we're a nested transition, we should use the same set as the parent\n          // since we're conceptually always joined into the same entangled transition.\n          // In practice, this only matters if we add transition types in the inner\n          // without setting state. In that case, the inner transition can finish\n          // without waiting for the outer.\n          prevTransition.types\n        : null;\n  }\n  if (enableGestureTransition) {\n    currentTransition.gesture = null;\n  }\n  if (enableTransitionTracing) {\n    currentTransition.name =\n      options !== undefined && options.name !== undefined ? options.name : null;\n    currentTransition.startTime = -1; // TODO: This should read the timestamp.\n  }\n  if (__DEV__) {\n    currentTransition._updatedFibers = new Set();\n  }\n  ReactSharedInternals.T = currentTransition;\n\n  try {\n    const returnValue = scope();\n    const onStartTransitionFinish = ReactSharedInternals.S;\n    if (onStartTransitionFinish !== null) {\n      onStartTransitionFinish(currentTransition, returnValue);\n    }\n    if (\n      typeof returnValue === 'object' &&\n      returnValue !== null &&\n      typeof returnValue.then === 'function'\n    ) {\n      if (__DEV__) {\n        // Keep track of the number of async transitions still running so we can warn.\n        ReactSharedInternals.asyncTransitions++;\n        returnValue.then(releaseAsyncTransition, releaseAsyncTransition);\n      }\n      returnValue.then(noop, reportGlobalError);\n    }\n  } catch (error) {\n    reportGlobalError(error);\n  } finally {\n    warnAboutTransitionSubscriptions(prevTransition, currentTransition);\n    if (prevTransition !== null && currentTransition.types !== null) {\n      // If we created a new types set in the inner transition, we transfer it to the parent\n      // since they should share the same set. They're conceptually entangled.\n      if (__DEV__) {\n        if (\n          prevTransition.types !== null &&\n          prevTransition.types !== currentTransition.types\n        ) {\n          // Just assert that assumption holds that we're not overriding anything.\n          console.error(\n            'We expected inner Transitions to have transferred the outer types set and ' +\n              'that you cannot add to the outer Transition while inside the inner.' +\n              'This is a bug in React.',\n          );\n        }\n      }\n      prevTransition.types = currentTransition.types;\n    }\n    ReactSharedInternals.T = prevTransition;\n  }\n}\n\nexport function startGestureTransition(\n  provider: GestureProvider,\n  scope: () => void,\n  options?: GestureOptions & StartTransitionOptions,\n): () => void {\n  if (!enableGestureTransition) {\n    // eslint-disable-next-line react-internal/prod-error-codes\n    throw new Error(\n      'startGestureTransition should not be exported when the enableGestureTransition flag is off.',\n    );\n  }\n  if (provider == null) {\n    // We enforce this at runtime even though the type also enforces it since we\n    // use null as a signal internally so it would lead it to be treated as a\n    // regular transition otherwise.\n    throw new Error(\n      'A Timeline is required as the first argument to startGestureTransition.',\n    );\n  }\n  const prevTransition = ReactSharedInternals.T;\n  const currentTransition: Transition = ({}: any);\n  if (enableViewTransition) {\n    currentTransition.types = null;\n  }\n  if (enableGestureTransition) {\n    currentTransition.gesture = provider;\n  }\n  if (enableTransitionTracing) {\n    currentTransition.name =\n      options !== undefined && options.name !== undefined ? options.name : null;\n    currentTransition.startTime = -1; // TODO: This should read the timestamp.\n  }\n  if (__DEV__) {\n    currentTransition._updatedFibers = new Set();\n  }\n  ReactSharedInternals.T = currentTransition;\n\n  try {\n    const returnValue = scope();\n    if (__DEV__) {\n      if (\n        typeof returnValue === 'object' &&\n        returnValue !== null &&\n        typeof returnValue.then === 'function'\n      ) {\n        console.error(\n          'Cannot use an async function in startGestureTransition. It must be able to start immediately.',\n        );\n      }\n    }\n    const onStartGestureTransitionFinish = ReactSharedInternals.G;\n    if (onStartGestureTransitionFinish !== null) {\n      return onStartGestureTransitionFinish(\n        currentTransition,\n        provider,\n        options,\n      );\n    }\n  } catch (error) {\n    reportGlobalError(error);\n  } finally {\n    ReactSharedInternals.T = prevTransition;\n  }\n  return noop;\n}\n\nfunction warnAboutTransitionSubscriptions(\n  prevTransition: Transition | null,\n  currentTransition: Transition,\n) {\n  if (__DEV__) {\n    if (prevTransition === null && currentTransition._updatedFibers) {\n      const updatedFibersCount = currentTransition._updatedFibers.size;\n      currentTransition._updatedFibers.clear();\n      if (updatedFibersCount > 10) {\n        console.warn(\n          'Detected a large number of updates inside startTransition. ' +\n            'If this is due to a subscription please re-write it to use React provided hooks. ' +\n            'Otherwise concurrent mode guarantees are off the table.',\n        );\n      }\n    }\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {\n  enableViewTransition,\n  enableGestureTransition,\n} from 'shared/ReactFeatureFlags';\nimport {startTransition} from './ReactStartTransition';\n\nexport type TransitionTypes = Array<string>;\n\nexport function addTransitionType(type: string): void {\n  if (enableViewTransition) {\n    const transition = ReactSharedInternals.T;\n    if (transition !== null) {\n      const transitionTypes = transition.types;\n      if (transitionTypes === null) {\n        transition.types = [type];\n      } else if (transitionTypes.indexOf(type) === -1) {\n        transitionTypes.push(type);\n      }\n    } else {\n      // We're in the async gap. Simulate an implicit startTransition around it.\n      if (__DEV__) {\n        if (ReactSharedInternals.asyncTransitions === 0) {\n          if (enableGestureTransition) {\n            console.error(\n              'addTransitionType can only be called inside a `startTransition()` ' +\n                'or `startGestureTransition()` callback. ' +\n                'It must be associated with a specific Transition.',\n            );\n          } else {\n            console.error(\n              'addTransitionType can only be called inside a `startTransition()` ' +\n                'callback. It must be associated with a specific Transition.',\n            );\n          }\n        }\n      }\n      startTransition(addTransitionType.bind(null, type));\n    }\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nlet didWarnAboutMessageChannel = false;\nlet enqueueTaskImpl = null;\n\nexport default function enqueueTask(task: () => void): void {\n  if (enqueueTaskImpl === null) {\n    try {\n      // read require off the module object to get around the bundlers.\n      // we don't want them to detect a require and bundle a Node polyfill.\n      const requireString = ('require' + Math.random()).slice(0, 7);\n      // $FlowFixMe[invalid-computed-prop]\n      const nodeRequire = module && module[requireString];\n      // assuming we're in node, let's try to get node's\n      // version of setImmediate, bypassing fake timers if any.\n      enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n    } catch (_err) {\n      // we're in a browser\n      // we can't use regular timers because they may still be faked\n      // so we try MessageChannel+postMessage instead\n      enqueueTaskImpl = function (callback: () => void) {\n        if (__DEV__) {\n          if (didWarnAboutMessageChannel === false) {\n            didWarnAboutMessageChannel = true;\n            if (typeof MessageChannel === 'undefined') {\n              console.error(\n                'This browser does not have a MessageChannel implementation, ' +\n                  'so enqueuing tasks via await act(async () => ...) will fail. ' +\n                  'Please file an issue at https://github.com/facebook/react/issues ' +\n                  'if you encounter this warning.',\n              );\n            }\n          }\n        }\n        const channel = new MessageChannel();\n        channel.port1.onmessage = callback;\n        channel.port2.postMessage(undefined);\n      };\n    }\n  }\n  return enqueueTaskImpl(task);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Thenable} from 'shared/ReactTypes';\nimport type {RendererTask} from './ReactSharedInternalsClient';\nimport ReactSharedInternals from './ReactSharedInternalsClient';\nimport queueMacrotask from 'shared/enqueueTask';\n\nimport {disableLegacyMode} from 'shared/ReactFeatureFlags';\n\n// `act` calls can be nested, so we track the depth. This represents the\n// number of `act` scopes on the stack.\nlet actScopeDepth = 0;\n\n// We only warn the first time you neglect to await an async `act` scope.\nlet didWarnNoAwaitAct = false;\n\nfunction aggregateErrors(errors: Array<mixed>): mixed {\n  if (errors.length > 1 && typeof AggregateError === 'function') {\n    // eslint-disable-next-line no-undef\n    return new AggregateError(errors);\n  }\n  return errors[0];\n}\n\nexport function act<T>(callback: () => T | Thenable<T>): Thenable<T> {\n  if (__DEV__) {\n    // When ReactSharedInternals.actQueue is not null, it signals to React that\n    // we're currently inside an `act` scope. React will push all its tasks to\n    // this queue instead of scheduling them with platform APIs.\n    //\n    // We set this to an empty array when we first enter an `act` scope, and\n    // only unset it once we've left the outermost `act` scope  remember that\n    // `act` calls can be nested.\n    //\n    // If we're already inside an `act` scope, reuse the existing queue.\n    const prevIsBatchingLegacy = !disableLegacyMode\n      ? ReactSharedInternals.isBatchingLegacy\n      : false;\n    const prevActQueue = ReactSharedInternals.actQueue;\n    const prevActScopeDepth = actScopeDepth;\n    actScopeDepth++;\n    const queue = (ReactSharedInternals.actQueue =\n      prevActQueue !== null ? prevActQueue : []);\n    // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n    // set to `true` while the given callback is executed, not for updates\n    // triggered during an async event, because this is how the legacy\n    // implementation of `act` behaved.\n    if (!disableLegacyMode) {\n      ReactSharedInternals.isBatchingLegacy = true;\n    }\n\n    let result;\n    // This tracks whether the `act` call is awaited. In certain cases, not\n    // awaiting it is a mistake, so we will detect that and warn.\n    let didAwaitActCall = false;\n    try {\n      // Reset this to `false` right before entering the React work loop. The\n      // only place we ever read this fields is just below, right after running\n      // the callback. So we don't need to reset after the callback runs.\n      if (!disableLegacyMode) {\n        ReactSharedInternals.didScheduleLegacyUpdate = false;\n      }\n      result = callback();\n      const didScheduleLegacyUpdate = !disableLegacyMode\n        ? ReactSharedInternals.didScheduleLegacyUpdate\n        : false;\n\n      // Replicate behavior of original `act` implementation in legacy mode,\n      // which flushed updates immediately after the scope function exits, even\n      // if it's an async function.\n      if (!prevIsBatchingLegacy && didScheduleLegacyUpdate) {\n        flushActQueue(queue);\n      }\n      // `isBatchingLegacy` gets reset using the regular stack, not the async\n      // one used to track `act` scopes. Why, you may be wondering? Because\n      // that's how it worked before version 18. Yes, it's confusing! We should\n      // delete legacy mode!!\n      if (!disableLegacyMode) {\n        ReactSharedInternals.isBatchingLegacy = prevIsBatchingLegacy;\n      }\n    } catch (error) {\n      // `isBatchingLegacy` gets reset using the regular stack, not the async\n      // one used to track `act` scopes. Why, you may be wondering? Because\n      // that's how it worked before version 18. Yes, it's confusing! We should\n      // delete legacy mode!!\n      ReactSharedInternals.thrownErrors.push(error);\n    }\n    if (ReactSharedInternals.thrownErrors.length > 0) {\n      if (!disableLegacyMode) {\n        ReactSharedInternals.isBatchingLegacy = prevIsBatchingLegacy;\n      }\n      popActScope(prevActQueue, prevActScopeDepth);\n      const thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);\n      ReactSharedInternals.thrownErrors.length = 0;\n      throw thrownError;\n    }\n\n    if (\n      result !== null &&\n      typeof result === 'object' &&\n      // $FlowFixMe[method-unbinding]\n      typeof result.then === 'function'\n    ) {\n      // A promise/thenable was returned from the callback. Wait for it to\n      // resolve before flushing the queue.\n      //\n      // If `act` were implemented as an async function, this whole block could\n      // be a single `await` call. That's really the only difference between\n      // this branch and the next one.\n      const thenable = ((result: any): Thenable<T>);\n\n      // Warn if the an `act` call with an async scope is not awaited. In a\n      // future release, consider making this an error.\n      queueSeveralMicrotasks(() => {\n        if (!didAwaitActCall && !didWarnNoAwaitAct) {\n          didWarnNoAwaitAct = true;\n          console.error(\n            'You called act(async () => ...) without await. ' +\n              'This could lead to unexpected testing behaviour, ' +\n              'interleaving multiple act calls and mixing their ' +\n              'scopes. ' +\n              'You should - await act(async () => ...);',\n          );\n        }\n      });\n\n      return {\n        then(resolve: T => mixed, reject: mixed => mixed) {\n          didAwaitActCall = true;\n          thenable.then(\n            returnValue => {\n              popActScope(prevActQueue, prevActScopeDepth);\n              if (prevActScopeDepth === 0) {\n                // We're exiting the outermost `act` scope. Flush the queue.\n                try {\n                  flushActQueue(queue);\n                  queueMacrotask(() =>\n                    // Recursively flush tasks scheduled by a microtask.\n                    recursivelyFlushAsyncActWork(returnValue, resolve, reject),\n                  );\n                } catch (error) {\n                  // `thenable` might not be a real promise, and `flushActQueue`\n                  // might throw, so we need to wrap `flushActQueue` in a\n                  // try/catch.\n                  ReactSharedInternals.thrownErrors.push(error);\n                }\n                if (ReactSharedInternals.thrownErrors.length > 0) {\n                  const thrownError = aggregateErrors(\n                    ReactSharedInternals.thrownErrors,\n                  );\n                  ReactSharedInternals.thrownErrors.length = 0;\n                  reject(thrownError);\n                }\n              } else {\n                resolve(returnValue);\n              }\n            },\n            error => {\n              popActScope(prevActQueue, prevActScopeDepth);\n              if (ReactSharedInternals.thrownErrors.length > 0) {\n                const thrownError = aggregateErrors(\n                  ReactSharedInternals.thrownErrors,\n                );\n                ReactSharedInternals.thrownErrors.length = 0;\n                reject(thrownError);\n              } else {\n                reject(error);\n              }\n            },\n          );\n        },\n      };\n    } else {\n      const returnValue: T = (result: any);\n      // The callback is not an async function. Exit the current\n      // scope immediately.\n      popActScope(prevActQueue, prevActScopeDepth);\n      if (prevActScopeDepth === 0) {\n        // We're exiting the outermost `act` scope. Flush the queue.\n        flushActQueue(queue);\n\n        // If the queue is not empty, it implies that we intentionally yielded\n        // to the main thread, because something suspended. We will continue\n        // in an asynchronous task.\n        //\n        // Warn if something suspends but the `act` call is not awaited.\n        // In a future release, consider making this an error.\n        if (queue.length !== 0) {\n          queueSeveralMicrotasks(() => {\n            if (!didAwaitActCall && !didWarnNoAwaitAct) {\n              didWarnNoAwaitAct = true;\n              console.error(\n                'A component suspended inside an `act` scope, but the ' +\n                  '`act` call was not awaited. When testing React ' +\n                  'components that depend on asynchronous data, you must ' +\n                  'await the result:\\n\\n' +\n                  'await act(() => ...)',\n              );\n            }\n          });\n        }\n\n        // Like many things in this module, this is next part is confusing.\n        //\n        // We do not currently require every `act` call that is passed a\n        // callback to be awaited, through arguably we should. Since this\n        // callback was synchronous, we need to exit the current scope before\n        // returning.\n        //\n        // However, if thenable we're about to return *is* awaited, we'll\n        // immediately restore the current scope. So it shouldn't observable.\n        //\n        // This doesn't affect the case where the scope callback is async,\n        // because we always require those calls to be awaited.\n        //\n        // TODO: In a future version, consider always requiring all `act` calls\n        // to be awaited, regardless of whether the callback is sync or async.\n        ReactSharedInternals.actQueue = null;\n      }\n\n      if (ReactSharedInternals.thrownErrors.length > 0) {\n        const thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);\n        ReactSharedInternals.thrownErrors.length = 0;\n        throw thrownError;\n      }\n\n      return {\n        then(resolve: T => mixed, reject: mixed => mixed) {\n          didAwaitActCall = true;\n          if (prevActScopeDepth === 0) {\n            // If the `act` call is awaited, restore the queue we were\n            // using before (see long comment above) so we can flush it.\n            ReactSharedInternals.actQueue = queue;\n            queueMacrotask(() =>\n              // Recursively flush tasks scheduled by a microtask.\n              recursivelyFlushAsyncActWork(returnValue, resolve, reject),\n            );\n          } else {\n            resolve(returnValue);\n          }\n        },\n      };\n    }\n  } else {\n    throw new Error('act(...) is not supported in production builds of React.');\n  }\n}\n\nfunction popActScope(\n  prevActQueue: null | Array<RendererTask>,\n  prevActScopeDepth: number,\n) {\n  if (__DEV__) {\n    if (prevActScopeDepth !== actScopeDepth - 1) {\n      console.error(\n        'You seem to have overlapping act() calls, this is not supported. ' +\n          'Be sure to await previous act() calls before making a new one. ',\n      );\n    }\n    actScopeDepth = prevActScopeDepth;\n  }\n}\n\nfunction recursivelyFlushAsyncActWork<T>(\n  returnValue: T,\n  resolve: T => mixed,\n  reject: mixed => mixed,\n) {\n  if (__DEV__) {\n    // Check if any tasks were scheduled asynchronously.\n    const queue = ReactSharedInternals.actQueue;\n    if (queue !== null) {\n      if (queue.length !== 0) {\n        // Async tasks were scheduled, mostly likely in a microtask.\n        // Keep flushing until there are no more.\n        try {\n          flushActQueue(queue);\n          // The work we just performed may have schedule additional async\n          // tasks. Wait a macrotask and check again.\n          queueMacrotask(() =>\n            recursivelyFlushAsyncActWork(returnValue, resolve, reject),\n          );\n          return;\n        } catch (error) {\n          // Leave remaining tasks on the queue if something throws.\n          ReactSharedInternals.thrownErrors.push(error);\n        }\n      } else {\n        // The queue is empty. We can finish.\n        ReactSharedInternals.actQueue = null;\n      }\n    }\n    if (ReactSharedInternals.thrownErrors.length > 0) {\n      const thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);\n      ReactSharedInternals.thrownErrors.length = 0;\n      reject(thrownError);\n    } else {\n      resolve(returnValue);\n    }\n  }\n}\n\nlet isFlushing = false;\nfunction flushActQueue(queue: Array<RendererTask>) {\n  if (__DEV__) {\n    if (!isFlushing) {\n      // Prevent re-entrance.\n      isFlushing = true;\n      let i = 0;\n      try {\n        for (; i < queue.length; i++) {\n          let callback: RendererTask = queue[i];\n          do {\n            ReactSharedInternals.didUsePromise = false;\n            const continuation = callback(false);\n            if (continuation !== null) {\n              if (ReactSharedInternals.didUsePromise) {\n                // The component just suspended. Yield to the main thread in\n                // case the promise is already resolved. If so, it will ping in\n                // a microtask and we can resume without unwinding the stack.\n                queue[i] = callback;\n                queue.splice(0, i);\n                return;\n              }\n              callback = continuation;\n            } else {\n              break;\n            }\n          } while (true);\n        }\n        // We flushed the entire queue.\n        queue.length = 0;\n      } catch (error) {\n        // If something throws, leave the remaining callbacks on the queue.\n        queue.splice(0, i + 1);\n        ReactSharedInternals.thrownErrors.push(error);\n      } finally {\n        isFlushing = false;\n      }\n    }\n  }\n}\n\n// Some of our warnings attempt to detect if the `act` call is awaited by\n// checking in an asynchronous task. Wait a few microtasks before checking. The\n// only reason one isn't sufficient is we want to accommodate the case where an\n// `act` call is returned from an async function without first being awaited,\n// since that's a somewhat common pattern. If you do this too many times in a\n// nested sequence, you might get a warning, but you can always fix by awaiting\n// the call.\n//\n// A macrotask would also work (and is the fallback) but depending on the test\n// environment it may cause the warning to fire too late.\nconst queueSeveralMicrotasks =\n  typeof queueMicrotask === 'function'\n    ? (callback: () => void) => {\n        queueMicrotask(() => queueMicrotask(callback));\n      }\n    : queueMacrotask;\n","/**\n * Copyright (c) Meta Platforms, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nexport function captureOwnerStack(): null | string {\n  if (__DEV__) {\n    const getCurrentStack = ReactSharedInternals.getCurrentStack;\n    if (getCurrentStack === null) {\n      return null;\n    }\n    // The current stack will be the owner stack which it is always here.\n    return getCurrentStack();\n  }\n\n  return null;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport ReactVersion from 'shared/ReactVersion';\nimport {\n  REACT_FRAGMENT_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_LEGACY_HIDDEN_TYPE,\n  REACT_ACTIVITY_TYPE,\n  REACT_SCOPE_TYPE,\n  REACT_TRACING_MARKER_TYPE,\n  REACT_VIEW_TRANSITION_TYPE,\n} from 'shared/ReactSymbols';\n\nimport {Component, PureComponent} from './ReactBaseClasses';\nimport {createRef} from './ReactCreateRef';\nimport {forEach, map, count, toArray, only} from './ReactChildren';\nimport {\n  createElement,\n  cloneElement,\n  isValidElement,\n} from './jsx/ReactJSXElement';\nimport {createContext} from './ReactContext';\nimport {lazy} from './ReactLazy';\nimport {forwardRef} from './ReactForwardRef';\nimport {memo} from './ReactMemo';\nimport {cache, cacheSignal} from './ReactCacheClient';\nimport {postpone} from './ReactPostpone';\nimport {\n  getCacheForType,\n  useCallback,\n  useContext,\n  useEffect,\n  useEffectEvent,\n  useImperativeHandle,\n  useDebugValue,\n  useInsertionEffect,\n  useLayoutEffect,\n  useMemo,\n  useSyncExternalStore,\n  useReducer,\n  useRef,\n  useState,\n  useTransition,\n  useDeferredValue,\n  useId,\n  useCacheRefresh,\n  use,\n  useOptimistic,\n  useActionState,\n} from './ReactHooks';\nimport ReactSharedInternals from './ReactSharedInternalsClient';\nimport {startTransition, startGestureTransition} from './ReactStartTransition';\nimport {addTransitionType} from './ReactTransitionType';\nimport {act} from './ReactAct';\nimport {captureOwnerStack} from './ReactOwnerStack';\nimport * as ReactCompilerRuntime from './ReactCompilerRuntime';\n\nconst Children = {\n  map,\n  forEach,\n  count,\n  toArray,\n  only,\n};\n\nexport {\n  Children,\n  createRef,\n  Component,\n  PureComponent,\n  createContext,\n  forwardRef,\n  lazy,\n  memo,\n  cache,\n  cacheSignal,\n  postpone as unstable_postpone,\n  useCallback,\n  useContext,\n  useEffect,\n  useEffectEvent as experimental_useEffectEvent,\n  useImperativeHandle,\n  useDebugValue,\n  useInsertionEffect,\n  useLayoutEffect,\n  useMemo,\n  useOptimistic,\n  useActionState,\n  useSyncExternalStore,\n  useReducer,\n  useRef,\n  useState,\n  REACT_FRAGMENT_TYPE as Fragment,\n  REACT_PROFILER_TYPE as Profiler,\n  REACT_STRICT_MODE_TYPE as StrictMode,\n  REACT_SUSPENSE_TYPE as Suspense,\n  createElement,\n  cloneElement,\n  isValidElement,\n  ReactVersion as version,\n  ReactSharedInternals as __CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  ReactCompilerRuntime as __COMPILER_RUNTIME,\n  // Concurrent Mode\n  useTransition,\n  startTransition,\n  useDeferredValue,\n  REACT_SUSPENSE_LIST_TYPE as unstable_SuspenseList,\n  REACT_LEGACY_HIDDEN_TYPE as unstable_LegacyHidden,\n  REACT_ACTIVITY_TYPE as unstable_Activity,\n  getCacheForType as unstable_getCacheForType,\n  useCacheRefresh as unstable_useCacheRefresh,\n  use,\n  // enableScopeAPI\n  REACT_SCOPE_TYPE as unstable_Scope,\n  // enableTransitionTracing\n  REACT_TRACING_MARKER_TYPE as unstable_TracingMarker,\n  // enableViewTransition\n  REACT_VIEW_TRANSITION_TYPE as unstable_ViewTransition,\n  addTransitionType as unstable_addTransitionType,\n  // enableGestureTransition\n  startGestureTransition as unstable_startGestureTransition,\n  // DEV-only\n  useId,\n  act,\n  captureOwnerStack,\n};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport {\n  __CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  __COMPILER_RUNTIME,\n  Children,\n  Component,\n  Fragment,\n  Profiler,\n  PureComponent,\n  StrictMode,\n  Suspense,\n  cloneElement,\n  createContext,\n  createElement,\n  createRef,\n  use,\n  forwardRef,\n  isValidElement,\n  lazy,\n  memo,\n  cache,\n  cacheSignal,\n  startTransition,\n  unstable_Activity,\n  unstable_postpone,\n  unstable_getCacheForType,\n  unstable_SuspenseList,\n  unstable_ViewTransition,\n  unstable_startGestureTransition,\n  unstable_addTransitionType,\n  unstable_useCacheRefresh,\n  useId,\n  useCallback,\n  useContext,\n  useDebugValue,\n  useDeferredValue,\n  useEffect,\n  experimental_useEffectEvent,\n  useImperativeHandle,\n  useInsertionEffect,\n  useLayoutEffect,\n  useMemo,\n  useOptimistic,\n  useReducer,\n  useRef,\n  useState,\n  useSyncExternalStore,\n  useTransition,\n  useActionState,\n  version,\n  act, // DEV-only\n  captureOwnerStack, // DEV-only\n} from './src/ReactClient';\n\nimport {useOptimistic} from './src/ReactClient';\n\nexport function experimental_useOptimistic<S, A>(\n  passthrough: S,\n  reducer: ?(S, A) => S,\n): [S, (A) => void] {\n  if (__DEV__) {\n    console.error(\n      'useOptimistic is now in canary. Remove the experimental_ prefix. ' +\n        'The prefixed alias will be removed in an upcoming release.',\n    );\n  }\n  return useOptimistic(passthrough, reducer);\n}\n"],"names":["disableLegacyMode","ownerStackLimit","REACT_ELEMENT_TYPE","Symbol","for","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_CONSUMER_TYPE","REACT_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_ACTIVITY_TYPE","REACT_POSTPONE_TYPE","REACT_VIEW_TRANSITION_TYPE","MAYBE_ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","didWarnStateUpdateForUnmountedComponent","warnNoop","publicInstance","callerName","constructor","componentName","displayName","name","warningKey","console","error","ReactNoopUpdateQueue","isMounted","enqueueForceUpdate","callback","enqueueReplaceState","completeState","enqueueSetState","partialState","assign","Object","emptyObject","freeze","Component","props","context","updater","refs","prototype","isReactComponent","setState","Error","forceUpdate","deprecatedAPIs","replaceState","defineDeprecationWarning","methodName","info","defineProperty","get","warn","undefined","fnName","hasOwnProperty","ComponentDummy","PureComponent","pureComponentPrototype","isPureReactComponent","createRef","refObject","current","seal","isArrayImpl","Array","isArray","a","noop","typeName","value","hasToStringTag","toStringTag","type","willCoercionThrow","testStringCoercion","e","checkKeyStringCoercion","getWrappedName","outerType","innerType","wrapperName","functionName","getContextName","REACT_CLIENT_REFERENCE","getComponentNameFromType","$$typeof","tag","consumer","_context","render","outerName","lazyComponent","payload","_payload","init","_init","x","ReactSharedInternals","H","A","T","S","G","actQueue","asyncTransitions","isBatchingLegacy","didScheduleLegacyUpdate","didUsePromise","thrownErrors","getCurrentStack","recentlyCreatedOwnerStacks","createTask","getTaskName","getOwner","dispatcher","UnknownOwner","createFakeCallStack","react_stack_bottom_frame","callStackForError","specialPropKeyWarningShown","didWarnAboutElementRef","didWarnAboutOldJSXRuntime","unknownOwnerDebugStack","unknownOwnerDebugTask","bind","hasValidRef","config","call","getter","getOwnPropertyDescriptor","isReactWarning","ref","hasValidKey","key","defineKeyPropWarningGetter","warnAboutAccessingKey","configurable","elementRefGetterWithDeprecationWarning","refProp","ReactElement","self","source","owner","debugStack","debugTask","element","_owner","enumerable","_store","writable","createElement","children","i","arguments","length","validateChildKeys","propName","childrenLength","childArray","defaultProps","trackActualOwner","cloneAndReplaceKey","oldElement","newKey","clonedElement","_debugStack","_debugTask","validated","cloneElement","node","parentType","isValidElement","object","SEPARATOR","SUBSEPARATOR","escape","escapeRegex","escaperLookup","escapedString","replace","match","didWarnAboutMaps","userProvidedKeyEscapeRegex","escapeUserProvidedKey","text","getElementKey","index","toString","resolveThenable","thenable","status","fulfilledValue","rejectedError","reason","then","pendingThenable","fulfilledThenable","rejectedThenable","mapIntoArray","array","escapedPrefix","nameSoFar","invokeCallback","child","mappedChild","childKey","escapedChildKey","c","newChild","push","nextName","subtreeCount","nextNamePrefix","iteratorFn","iterableChildren","entries","step","ii","next","done","childrenString","String","keys","join","mapChildren","func","result","count","countChildren","n","forEachChildren","forEachFunc","forEachContext","apply","toArray","onlyChild","createContext","defaultValue","_currentValue","_currentValue2","_threadCount","Provider","Consumer","_currentRenderer","_currentRenderer2","Uninitialized","Pending","Resolved","Rejected","lazyInitializer","_status","ctor","_result","moduleObject","resolved","rejected","pending","default","lazy","lazyType","forwardRef","elementType","ownName","set","memo","compare","noopCache","fn","cache","noopCacheSignal","cacheSignal","postpone","postponeInstance","resolveDispatcher","getCacheForType","resourceType","useContext","Context","useState","initialState","useReducer","reducer","initialArg","useRef","initialValue","useEffect","create","deps","useInsertionEffect","useLayoutEffect","useCallback","useMemo","useImperativeHandle","useDebugValue","formatterFn","useTransition","useDeferredValue","useId","useSyncExternalStore","subscribe","getSnapshot","getServerSnapshot","useCacheRefresh","use","usable","useMemoCache","size","useEffectEvent","useOptimistic","passthrough","useActionState","action","permalink","reportGlobalError","reportError","window","ErrorEvent","message","event","bubbles","cancelable","shouldLog","dispatchEvent","process","emit","releaseAsyncTransition","startTransition","scope","options","prevTransition","currentTransition","types","gesture","_updatedFibers","Set","returnValue","onStartTransitionFinish","__DEV__","warnAboutTransitionSubscriptions","startGestureTransition","provider","onStartGestureTransitionFinish","updatedFibersCount","clear","addTransitionType","transition","transitionTypes","indexOf","didWarnAboutMessageChannel","enqueueTaskImpl","enqueueTask","task","requireString","Math","random","slice","nodeRequire","module","setImmediate","_err","MessageChannel","channel","port1","onmessage","port2","postMessage","actScopeDepth","didWarnNoAwaitAct","aggregateErrors","errors","AggregateError","act","prevIsBatchingLegacy","prevActQueue","prevActScopeDepth","queue","didAwaitActCall","flushActQueue","popActScope","thrownError","queueSeveralMicrotasks","resolve","reject","queueMacrotask","recursivelyFlushAsyncActWork","isFlushing","continuation","splice","queueMicrotask","captureOwnerStack","Children","map","forEach","only","experimental_useOptimistic"],"mappings":"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"}
\ No newline at end of file
diff --git a/cjs/react.production.js b/cjs/react.production.js
index fb59cdd15d670fb7b3c5a91094029c23dfee1ef5..f483d5f121b5ccee7ee04f999006dbbf9d4584b2 100644
--- a/cjs/react.production.js
+++ b/cjs/react.production.js
@@ -1,546 +1,1106 @@
-/**
- * @license React
- * react.production.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
+'use strict';
+
+var ReactVersion = '19.2.0-experimental-602917c8-20250701';
 
-"use strict";
-var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
-  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
-  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
-  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
-  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-  REACT_MEMO_TYPE = Symbol.for("react.memo"),
-  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+const REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+const REACT_PORTAL_TYPE = Symbol.for('react.portal');
+const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+const REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
+const REACT_PROFILER_TYPE = Symbol.for('react.profiler');
+const REACT_CONSUMER_TYPE = Symbol.for('react.consumer');
+const REACT_CONTEXT_TYPE = Symbol.for('react.context');
+const REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+const REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
+const REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
+const REACT_MEMO_TYPE = Symbol.for('react.memo');
+const REACT_LAZY_TYPE = Symbol.for('react.lazy');
+const REACT_ACTIVITY_TYPE = Symbol.for('react.activity');
+const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
+const REACT_VIEW_TRANSITION_TYPE = Symbol.for('react.view_transition');
+const MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+const FAUX_ITERATOR_SYMBOL = '@@iterator';
 function getIteratorFn(maybeIterable) {
-  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
-  maybeIterable =
-    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-    maybeIterable["@@iterator"];
-  return "function" === typeof maybeIterable ? maybeIterable : null;
-}
-var ReactNoopUpdateQueue = {
-    isMounted: function () {
-      return !1;
-    },
-    enqueueForceUpdate: function () {},
-    enqueueReplaceState: function () {},
-    enqueueSetState: function () {}
+  if (maybeIterable === null || typeof maybeIterable !== 'object') {
+    return null;
+  }
+  const maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
+  if (typeof maybeIterator === 'function') {
+    return maybeIterator;
+  }
+  return null;
+}
+
+/**
+ * This is the abstract API for an update queue.
+ */
+const ReactNoopUpdateQueue = {
+  /**
+   * Checks whether or not this composite component is mounted.
+   * @param {ReactClass} publicInstance The instance we want to test.
+   * @return {boolean} True if mounted, false otherwise.
+   * @protected
+   * @final
+   */
+  isMounted: function (publicInstance) {
+    return false;
+  },
+  /**
+   * Forces an update. This should only be invoked when it is known with
+   * certainty that we are **not** in a DOM transaction.
+   *
+   * You may want to call this when you know that some deeper aspect of the
+   * component's state has changed but `setState` was not called.
+   *
+   * This will not invoke `shouldComponentUpdate`, but it will invoke
+   * `componentWillUpdate` and `componentDidUpdate`.
+   *
+   * @param {ReactClass} publicInstance The instance that should rerender.
+   * @param {?function} callback Called after component is updated.
+   * @param {?string} callerName name of the calling function in the public API.
+   * @internal
+   */
+  enqueueForceUpdate: function (publicInstance, callback, callerName) {
+  },
+  /**
+   * Replaces all of the state. Always use this or `setState` to mutate state.
+   * You should treat `this.state` as immutable.
+   *
+   * There is no guarantee that `this.state` will be immediately updated, so
+   * accessing `this.state` after calling this method may return the old value.
+   *
+   * @param {ReactClass} publicInstance The instance that should rerender.
+   * @param {object} completeState Next state.
+   * @param {?function} callback Called after component is updated.
+   * @param {?string} callerName name of the calling function in the public API.
+   * @internal
+   */
+  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
   },
-  assign = Object.assign,
-  emptyObject = {};
+  /**
+   * Sets a subset of the state. This only exists because _pendingState is
+   * internal. This provides a merging strategy that is not available to deep
+   * properties which is confusing. TODO: Expose pendingState or don't use it
+   * during the merge.
+   *
+   * @param {ReactClass} publicInstance The instance that should rerender.
+   * @param {object} partialState Next partial state to be merged with state.
+   * @param {?function} callback Called after component is updated.
+   * @param {?string} Name of the calling function in the public API.
+   * @internal
+   */
+  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
+  }
+};
+
+const assign = Object.assign;
+
+const emptyObject = {};
+
+/**
+ * Base class helpers for the updating state of a component.
+ */
 function Component(props, context, updater) {
   this.props = props;
   this.context = context;
+  // If a component has string refs, we will assign a different object later.
   this.refs = emptyObject;
+  // We initialize the default updater but the real one gets injected by the
+  // renderer.
   this.updater = updater || ReactNoopUpdateQueue;
 }
 Component.prototype.isReactComponent = {};
+
+/**
+ * Sets a subset of the state. Always use this to mutate
+ * state. You should treat `this.state` as immutable.
+ *
+ * There is no guarantee that `this.state` will be immediately updated, so
+ * accessing `this.state` after calling this method may return the old value.
+ *
+ * There is no guarantee that calls to `setState` will run synchronously,
+ * as they may eventually be batched together.  You can provide an optional
+ * callback that will be executed when the call to setState is actually
+ * completed.
+ *
+ * When a function is provided to setState, it will be called at some point in
+ * the future (not synchronously). It will be called with the up to date
+ * component arguments (state, props, context). These values can be different
+ * from this.* because your function may be called after receiveProps but before
+ * shouldComponentUpdate, and this new state, props, and context will not yet be
+ * assigned to this.
+ *
+ * @param {object|function} partialState Next partial state or function to
+ *        produce next partial state to be merged with current state.
+ * @param {?function} callback Called after state is updated.
+ * @final
+ * @protected
+ */
 Component.prototype.setState = function (partialState, callback) {
-  if (
-    "object" !== typeof partialState &&
-    "function" !== typeof partialState &&
-    null != partialState
-  )
-    throw Error(
-      "takes an object of state variables to update or a function which returns an object of state variables."
-    );
-  this.updater.enqueueSetState(this, partialState, callback, "setState");
+  if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
+    throw new Error('takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
+  }
+  this.updater.enqueueSetState(this, partialState, callback, 'setState');
 };
+
+/**
+ * Forces an update. This should only be invoked when it is known with
+ * certainty that we are **not** in a DOM transaction.
+ *
+ * You may want to call this when you know that some deeper aspect of the
+ * component's state has changed but `setState` was not called.
+ *
+ * This will not invoke `shouldComponentUpdate`, but it will invoke
+ * `componentWillUpdate` and `componentDidUpdate`.
+ *
+ * @param {?function} callback Called after update is complete.
+ * @final
+ * @protected
+ */
 Component.prototype.forceUpdate = function (callback) {
-  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
+  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
 };
 function ComponentDummy() {}
 ComponentDummy.prototype = Component.prototype;
+
+/**
+ * Convenience component with default shallow equality check for sCU.
+ */
 function PureComponent(props, context, updater) {
   this.props = props;
   this.context = context;
+  // If a component has string refs, we will assign a different object later.
   this.refs = emptyObject;
   this.updater = updater || ReactNoopUpdateQueue;
 }
-var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
+const pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
 pureComponentPrototype.constructor = PureComponent;
+// Avoid an extra prototype jump for these methods.
 assign(pureComponentPrototype, Component.prototype);
-pureComponentPrototype.isPureReactComponent = !0;
-var isArrayImpl = Array.isArray,
-  ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null },
-  hasOwnProperty = Object.prototype.hasOwnProperty;
-function ReactElement(type, key, self, source, owner, props) {
-  self = props.ref;
-  return {
-    $$typeof: REACT_ELEMENT_TYPE,
-    type: type,
-    key: key,
-    ref: void 0 !== self ? self : null,
-    props: props
+pureComponentPrototype.isPureReactComponent = true;
+
+// an immutable object with a single mutable value
+function createRef() {
+  const refObject = {
+    current: null
   };
+  return refObject;
+}
+
+const isArrayImpl = Array.isArray;
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+function noop() {}
+
+const ReactSharedInternals = {
+  H: null,
+  A: null,
+  T: null,
+  S: null
+};
+{
+  ReactSharedInternals.G = null;
+}
+
+// $FlowFixMe[method-unbinding]
+const hasOwnProperty = Object.prototype.hasOwnProperty;
+
+function getOwner() {
+  return null;
+}
+function hasValidRef(config) {
+  return config.ref !== undefined;
+}
+function hasValidKey(config) {
+  return config.key !== undefined;
+}
+
+/**
+ * Factory method to create a new React element. This no longer adheres to
+ * the class pattern, so do not use new to call it. Also, instanceof check
+ * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check
+ * if something is a React Element.
+ *
+ * @param {*} type
+ * @param {*} props
+ * @param {*} key
+ * @param {string|object} ref
+ * @param {*} owner
+ * @param {*} self A *temporary* helper to detect places where `this` is
+ * different from the `owner` when React.createElement is called, so that we
+ * can warn. We want to get rid of owner and replace string `ref`s with arrow
+ * functions, and as long as `this` and owner are the same, there will be no
+ * change in behavior.
+ * @param {*} source An annotation object (added by a transpiler or otherwise)
+ * indicating filename, line number, and/or other information.
+ * @internal
+ */
+function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
+  // Ignore whatever was passed as the ref argument and treat `props.ref` as
+  // the source of truth. The only thing we use this for is `element.ref`,
+  // which will log a deprecation warning on access. In the next release, we
+  // can remove `element.ref` as well as the `ref` argument.
+  const refProp = props.ref;
+
+  // An undefined `element.ref` is coerced to `null` for
+  // backwards compatibility.
+  const ref = refProp !== undefined ? refProp : null;
+  let element;
+  {
+    // In prod, `ref` is a regular property and _owner doesn't exist.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      // Built-in properties that belong on the element
+      type,
+      key,
+      ref,
+      props
+    };
+  }
+  return element;
+}
+
+/**
+ * Create and return a new ReactElement of the given type.
+ * See https://reactjs.org/docs/react-api.html#createelement
+ */
+function createElement(type, config, children) {
+  let propName;
+
+  // Reserved names are extracted
+  const props = {};
+  let key = null;
+  if (config != null) {
+    if (hasValidKey(config)) {
+      key = '' + config.key;
+    }
+
+    // Remaining properties are added to a new props object
+    for (propName in config) {
+      if (hasOwnProperty.call(config, propName) &&
+      // Skip over reserved prop names
+      propName !== 'key' &&
+      // Even though we don't use these anymore in the runtime, we don't want
+      // them to appear as props, so in createElement we filter them out.
+      // We don't have to do this in the jsx() runtime because the jsx()
+      // transform never passed these as props; it used separate arguments.
+      propName !== '__self' && propName !== '__source') {
+        props[propName] = config[propName];
+      }
+    }
+  }
+
+  // Children can be more than one argument, and those are transferred onto
+  // the newly allocated props object.
+  const childrenLength = arguments.length - 2;
+  if (childrenLength === 1) {
+    props.children = children;
+  } else if (childrenLength > 1) {
+    const childArray = Array(childrenLength);
+    for (let i = 0; i < childrenLength; i++) {
+      childArray[i] = arguments[i + 2];
+    }
+    props.children = childArray;
+  }
+
+  // Resolve default props
+  if (type && type.defaultProps) {
+    const defaultProps = type.defaultProps;
+    for (propName in defaultProps) {
+      if (props[propName] === undefined) {
+        props[propName] = defaultProps[propName];
+      }
+    }
+  }
+  return ReactElement(type, key, undefined, undefined, getOwner(), props);
 }
 function cloneAndReplaceKey(oldElement, newKey) {
-  return ReactElement(
-    oldElement.type,
-    newKey,
-    void 0,
-    void 0,
-    void 0,
-    oldElement.props
-  );
+  const clonedElement = ReactElement(oldElement.type, newKey, undefined, undefined, undefined , oldElement.props);
+  return clonedElement;
 }
+
+/**
+ * Clone and return a new ReactElement using element as the starting point.
+ * See https://reactjs.org/docs/react-api.html#cloneelement
+ */
+function cloneElement(element, config, children) {
+  if (element === null || element === undefined) {
+    throw new Error("The argument must be a React element, but you passed " + element + ".");
+  }
+  let propName;
+
+  // Original props are copied
+  const props = assign({}, element.props);
+
+  // Reserved names are extracted
+  let key = element.key;
+
+  // Owner will be preserved, unless ref is overridden
+  let owner = undefined ;
+  if (config != null) {
+    if (hasValidRef(config)) {
+      owner = undefined;
+    }
+    if (hasValidKey(config)) {
+      key = '' + config.key;
+    }
+
+    // Remaining properties override existing props
+    for (propName in config) {
+      if (hasOwnProperty.call(config, propName) &&
+      // Skip over reserved prop names
+      propName !== 'key' &&
+      // ...and maybe these, too, though we currently rely on them for
+      // warnings and debug information in dev. Need to decide if we're OK
+      // with dropping them. In the jsx() runtime it's not an issue because
+      // the data gets passed as separate arguments instead of props, but
+      // it would be nice to stop relying on them entirely so we can drop
+      // them from the internal Fiber field.
+      propName !== '__self' && propName !== '__source' &&
+      // Undefined `ref` is ignored by cloneElement. We treat it the same as
+      // if the property were missing. This is mostly for
+      // backwards compatibility.
+      !(propName === 'ref' && config.ref === undefined)) {
+        props[propName] = config[propName];
+      }
+    }
+  }
+
+  // Children can be more than one argument, and those are transferred onto
+  // the newly allocated props object.
+  const childrenLength = arguments.length - 2;
+  if (childrenLength === 1) {
+    props.children = children;
+  } else if (childrenLength > 1) {
+    const childArray = Array(childrenLength);
+    for (let i = 0; i < childrenLength; i++) {
+      childArray[i] = arguments[i + 2];
+    }
+    props.children = childArray;
+  }
+  const clonedElement = ReactElement(element.type, key, undefined, undefined, owner, props);
+  return clonedElement;
+}
+
+/**
+ * Verifies the object is a ReactElement.
+ * See https://reactjs.org/docs/react-api.html#isvalidelement
+ * @param {?object} object
+ * @return {boolean} True if `object` is a ReactElement.
+ * @final
+ */
 function isValidElement(object) {
-  return (
-    "object" === typeof object &&
-    null !== object &&
-    object.$$typeof === REACT_ELEMENT_TYPE
-  );
+  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
 }
+
+const SEPARATOR = '.';
+const SUBSEPARATOR = ':';
+
+/**
+ * Escape and wrap key so it is safe to use as a reactid
+ *
+ * @param {string} key to be escaped.
+ * @return {string} the escaped key.
+ */
 function escape(key) {
-  var escaperLookup = { "=": "=0", ":": "=2" };
-  return (
-    "$" +
-    key.replace(/[=:]/g, function (match) {
-      return escaperLookup[match];
-    })
-  );
-}
-var userProvidedKeyEscapeRegex = /\/+/g;
+  const escapeRegex = /[=:]/g;
+  const escaperLookup = {
+    '=': '=0',
+    ':': '=2'
+  };
+  const escapedString = key.replace(escapeRegex, function (match) {
+    // $FlowFixMe[invalid-computed-prop]
+    return escaperLookup[match];
+  });
+  return '$' + escapedString;
+}
+const userProvidedKeyEscapeRegex = /\/+/g;
+function escapeUserProvidedKey(text) {
+  return text.replace(userProvidedKeyEscapeRegex, '$&/');
+}
+
+/**
+ * Generate a key string that identifies a element within a set.
+ *
+ * @param {*} element A element that could contain a manual key.
+ * @param {number} index Index that is used if a manual key is not provided.
+ * @return {string}
+ */
 function getElementKey(element, index) {
-  return "object" === typeof element && null !== element && null != element.key
-    ? escape("" + element.key)
-    : index.toString(36);
+  // Do some typechecking here since we call this blindly. We want to ensure
+  // that we don't block potential future ES APIs.
+  if (typeof element === 'object' && element !== null && element.key != null) {
+    return escape('' + element.key);
+  }
+  // Implicit key determined by the index in the set
+  return index.toString(36);
 }
-function noop$1() {}
 function resolveThenable(thenable) {
   switch (thenable.status) {
-    case "fulfilled":
-      return thenable.value;
-    case "rejected":
-      throw thenable.reason;
+    case 'fulfilled':
+      {
+        const fulfilledValue = thenable.value;
+        return fulfilledValue;
+      }
+    case 'rejected':
+      {
+        const rejectedError = thenable.reason;
+        throw rejectedError;
+      }
     default:
-      switch (
-        ("string" === typeof thenable.status
-          ? thenable.then(noop$1, noop$1)
-          : ((thenable.status = "pending"),
-            thenable.then(
-              function (fulfilledValue) {
-                "pending" === thenable.status &&
-                  ((thenable.status = "fulfilled"),
-                  (thenable.value = fulfilledValue));
-              },
-              function (error) {
-                "pending" === thenable.status &&
-                  ((thenable.status = "rejected"), (thenable.reason = error));
-              }
-            )),
-        thenable.status)
-      ) {
-        case "fulfilled":
-          return thenable.value;
-        case "rejected":
-          throw thenable.reason;
+      {
+        if (typeof thenable.status === 'string') {
+          // Only instrument the thenable if the status if not defined. If
+          // it's defined, but an unknown value, assume it's been instrumented by
+          // some custom userspace implementation. We treat it as "pending".
+          // Attach a dummy listener, to ensure that any lazy initialization can
+          // happen. Flight lazily parses JSON when the value is actually awaited.
+          thenable.then(noop, noop);
+        } else {
+          // This is an uncached thenable that we haven't seen before.
+
+          // TODO: Detect infinite ping loops caused by uncached promises.
+
+          const pendingThenable = thenable;
+          pendingThenable.status = 'pending';
+          pendingThenable.then(fulfilledValue => {
+            if (thenable.status === 'pending') {
+              const fulfilledThenable = thenable;
+              fulfilledThenable.status = 'fulfilled';
+              fulfilledThenable.value = fulfilledValue;
+            }
+          }, error => {
+            if (thenable.status === 'pending') {
+              const rejectedThenable = thenable;
+              rejectedThenable.status = 'rejected';
+              rejectedThenable.reason = error;
+            }
+          });
+        }
+
+        // Check one more time in case the thenable resolved synchronously.
+        switch (thenable.status) {
+          case 'fulfilled':
+            {
+              const fulfilledThenable = thenable;
+              return fulfilledThenable.value;
+            }
+          case 'rejected':
+            {
+              const rejectedThenable = thenable;
+              const rejectedError = rejectedThenable.reason;
+              throw rejectedError;
+            }
+        }
       }
   }
   throw thenable;
 }
 function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
-  var type = typeof children;
-  if ("undefined" === type || "boolean" === type) children = null;
-  var invokeCallback = !1;
-  if (null === children) invokeCallback = !0;
-  else
+  const type = typeof children;
+  if (type === 'undefined' || type === 'boolean') {
+    // All of the above are perceived as null.
+    children = null;
+  }
+  let invokeCallback = false;
+  if (children === null) {
+    invokeCallback = true;
+  } else {
     switch (type) {
-      case "bigint":
-      case "string":
-      case "number":
-        invokeCallback = !0;
+      case 'bigint':
+      case 'string':
+      case 'number':
+        invokeCallback = true;
         break;
-      case "object":
+      case 'object':
         switch (children.$$typeof) {
           case REACT_ELEMENT_TYPE:
           case REACT_PORTAL_TYPE:
-            invokeCallback = !0;
+            invokeCallback = true;
             break;
           case REACT_LAZY_TYPE:
-            return (
-              (invokeCallback = children._init),
-              mapIntoArray(
-                invokeCallback(children._payload),
-                array,
-                escapedPrefix,
-                nameSoFar,
-                callback
-              )
-            );
+            const payload = children._payload;
+            const init = children._init;
+            return mapIntoArray(init(payload), array, escapedPrefix, nameSoFar, callback);
         }
     }
-  if (invokeCallback)
-    return (
-      (callback = callback(children)),
-      (invokeCallback =
-        "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),
-      isArrayImpl(callback)
-        ? ((escapedPrefix = ""),
-          null != invokeCallback &&
-            (escapedPrefix =
-              invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
-          mapIntoArray(callback, array, escapedPrefix, "", function (c) {
-            return c;
-          }))
-        : null != callback &&
-          (isValidElement(callback) &&
-            (callback = cloneAndReplaceKey(
-              callback,
-              escapedPrefix +
-                (null == callback.key ||
-                (children && children.key === callback.key)
-                  ? ""
-                  : ("" + callback.key).replace(
-                      userProvidedKeyEscapeRegex,
-                      "$&/"
-                    ) + "/") +
-                invokeCallback
-            )),
-          array.push(callback)),
-      1
-    );
-  invokeCallback = 0;
-  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
-  if (isArrayImpl(children))
-    for (var i = 0; i < children.length; i++)
-      (nameSoFar = children[i]),
-        (type = nextNamePrefix + getElementKey(nameSoFar, i)),
-        (invokeCallback += mapIntoArray(
-          nameSoFar,
-          array,
-          escapedPrefix,
-          type,
-          callback
-        ));
-  else if (((i = getIteratorFn(children)), "function" === typeof i))
-    for (
-      children = i.call(children), i = 0;
-      !(nameSoFar = children.next()).done;
-
-    )
-      (nameSoFar = nameSoFar.value),
-        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),
-        (invokeCallback += mapIntoArray(
-          nameSoFar,
-          array,
-          escapedPrefix,
-          type,
-          callback
-        ));
-  else if ("object" === type) {
-    if ("function" === typeof children.then)
-      return mapIntoArray(
-        resolveThenable(children),
-        array,
-        escapedPrefix,
-        nameSoFar,
-        callback
-      );
-    array = String(children);
-    throw Error(
-      "Objects are not valid as a React child (found: " +
-        ("[object Object]" === array
-          ? "object with keys {" + Object.keys(children).join(", ") + "}"
-          : array) +
-        "). If you meant to render a collection of children, use an array instead."
-    );
   }
-  return invokeCallback;
+  if (invokeCallback) {
+    const child = children;
+    let mappedChild = callback(child);
+    // If it's the only child, treat the name as if it was wrapped in an array
+    // so that it's consistent if the number of children grows:
+    const childKey = nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;
+    if (isArray(mappedChild)) {
+      let escapedChildKey = '';
+      if (childKey != null) {
+        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
+      }
+      mapIntoArray(mappedChild, array, escapedChildKey, '', c => c);
+    } else if (mappedChild != null) {
+      if (isValidElement(mappedChild)) {
+        const newChild = cloneAndReplaceKey(mappedChild,
+        // Keep both the (mapped) and old keys if they differ, just as
+        // traverseAllChildren used to do for objects as children
+        escapedPrefix + (
+        // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key
+        mappedChild.key != null && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(
+        // $FlowFixMe[unsafe-addition]
+        '' + mappedChild.key // eslint-disable-line react-internal/safe-string-coercion
+        ) + '/' : '') + childKey);
+        mappedChild = newChild;
+      }
+      array.push(mappedChild);
+    }
+    return 1;
+  }
+  let child;
+  let nextName;
+  let subtreeCount = 0; // Count of children found in the current subtree.
+  const nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
+  if (isArray(children)) {
+    for (let i = 0; i < children.length; i++) {
+      child = children[i];
+      nextName = nextNamePrefix + getElementKey(child, i);
+      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
+    }
+  } else {
+    const iteratorFn = getIteratorFn(children);
+    if (typeof iteratorFn === 'function') {
+      const iterableChildren = children;
+      const iterator = iteratorFn.call(iterableChildren);
+      let step;
+      let ii = 0;
+      // $FlowFixMe[incompatible-use] `iteratorFn` might return null according to typing.
+      while (!(step = iterator.next()).done) {
+        child = step.value;
+        nextName = nextNamePrefix + getElementKey(child, ii++);
+        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
+      }
+    } else if (type === 'object') {
+      if (typeof children.then === 'function') {
+        return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
+      }
+
+      // eslint-disable-next-line react-internal/safe-string-coercion
+      const childrenString = String(children);
+      throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
+    }
+  }
+  return subtreeCount;
 }
+
+/**
+ * Maps children that are typically specified as `props.children`.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrenmap
+ *
+ * The provided mapFunction(child, index) will be called for each
+ * leaf child.
+ *
+ * @param {?*} children Children tree container.
+ * @param {function(*, int)} func The map function.
+ * @param {*} context Context for mapFunction.
+ * @return {object} Object containing the ordered map of results.
+ */
 function mapChildren(children, func, context) {
-  if (null == children) return children;
-  var result = [],
-    count = 0;
-  mapIntoArray(children, result, "", "", function (child) {
+  if (children == null) {
+    // $FlowFixMe limitation refining abstract types in Flow
+    return children;
+  }
+  const result = [];
+  let count = 0;
+  mapIntoArray(children, result, '', '', function (child) {
     return func.call(context, child, count++);
   });
   return result;
 }
-function lazyInitializer(payload) {
-  if (-1 === payload._status) {
-    var ctor = payload._result;
-    ctor = ctor();
-    ctor.then(
-      function (moduleObject) {
-        if (0 === payload._status || -1 === payload._status)
-          (payload._status = 1), (payload._result = moduleObject);
-      },
-      function (error) {
-        if (0 === payload._status || -1 === payload._status)
-          (payload._status = 2), (payload._result = error);
-      }
-    );
-    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));
-  }
-  if (1 === payload._status) return payload._result.default;
-  throw payload._result;
-}
-var reportGlobalError =
-  "function" === typeof reportError
-    ? reportError
-    : function (error) {
-        if (
-          "object" === typeof window &&
-          "function" === typeof window.ErrorEvent
-        ) {
-          var event = new window.ErrorEvent("error", {
-            bubbles: !0,
-            cancelable: !0,
-            message:
-              "object" === typeof error &&
-              null !== error &&
-              "string" === typeof error.message
-                ? String(error.message)
-                : String(error),
-            error: error
-          });
-          if (!window.dispatchEvent(event)) return;
-        } else if (
-          "object" === typeof process &&
-          "function" === typeof process.emit
-        ) {
-          process.emit("uncaughtException", error);
-          return;
-        }
-        console.error(error);
-      };
-function noop() {}
-exports.Children = {
-  map: mapChildren,
-  forEach: function (children, forEachFunc, forEachContext) {
-    mapChildren(
-      children,
-      function () {
-        forEachFunc.apply(this, arguments);
-      },
-      forEachContext
-    );
-  },
-  count: function (children) {
-    var n = 0;
-    mapChildren(children, function () {
-      n++;
-    });
-    return n;
-  },
-  toArray: function (children) {
-    return (
-      mapChildren(children, function (child) {
-        return child;
-      }) || []
-    );
-  },
-  only: function (children) {
-    if (!isValidElement(children))
-      throw Error(
-        "React.Children.only expected to receive a single React element child."
-      );
-    return children;
-  }
-};
-exports.Component = Component;
-exports.Fragment = REACT_FRAGMENT_TYPE;
-exports.Profiler = REACT_PROFILER_TYPE;
-exports.PureComponent = PureComponent;
-exports.StrictMode = REACT_STRICT_MODE_TYPE;
-exports.Suspense = REACT_SUSPENSE_TYPE;
-exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
-  ReactSharedInternals;
-exports.__COMPILER_RUNTIME = {
-  __proto__: null,
-  c: function (size) {
-    return ReactSharedInternals.H.useMemoCache(size);
-  }
-};
-exports.cache = function (fn) {
-  return function () {
-    return fn.apply(null, arguments);
-  };
-};
-exports.cloneElement = function (element, config, children) {
-  if (null === element || void 0 === element)
-    throw Error(
-      "The argument must be a React element, but you passed " + element + "."
-    );
-  var props = assign({}, element.props),
-    key = element.key,
-    owner = void 0;
-  if (null != config)
-    for (propName in (void 0 !== config.ref && (owner = void 0),
-    void 0 !== config.key && (key = "" + config.key),
-    config))
-      !hasOwnProperty.call(config, propName) ||
-        "key" === propName ||
-        "__self" === propName ||
-        "__source" === propName ||
-        ("ref" === propName && void 0 === config.ref) ||
-        (props[propName] = config[propName]);
-  var propName = arguments.length - 2;
-  if (1 === propName) props.children = children;
-  else if (1 < propName) {
-    for (var childArray = Array(propName), i = 0; i < propName; i++)
-      childArray[i] = arguments[i + 2];
-    props.children = childArray;
+
+/**
+ * Count the number of children that are typically specified as
+ * `props.children`.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrencount
+ *
+ * @param {?*} children Children tree container.
+ * @return {number} The number of children.
+ */
+function countChildren(children) {
+  let n = 0;
+  mapChildren(children, () => {
+    n++;
+    // Don't return anything
+  });
+  return n;
+}
+
+/**
+ * Iterates through children that are typically specified as `props.children`.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
+ *
+ * The provided forEachFunc(child, index) will be called for each
+ * leaf child.
+ *
+ * @param {?*} children Children tree container.
+ * @param {function(*, int)} forEachFunc
+ * @param {*} forEachContext Context for forEachContext.
+ */
+function forEachChildren(children, forEachFunc, forEachContext) {
+  mapChildren(children,
+  // $FlowFixMe[missing-this-annot]
+  function () {
+    forEachFunc.apply(this, arguments);
+    // Don't return anything.
+  }, forEachContext);
+}
+
+/**
+ * Flatten a children object (typically specified as `props.children`) and
+ * return an array with appropriately re-keyed children.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
+ */
+function toArray(children) {
+  return mapChildren(children, child => child) || [];
+}
+
+/**
+ * Returns the first child in a collection of children and verifies that there
+ * is only one child in the collection.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrenonly
+ *
+ * The current implementation of this function assumes that a single child gets
+ * passed without a wrapper, but the purpose of this helper function is to
+ * abstract away the particular structure of children.
+ *
+ * @param {?object} children Child collection structure.
+ * @return {ReactElement} The first and only `ReactElement` contained in the
+ * structure.
+ */
+function onlyChild(children) {
+  if (!isValidElement(children)) {
+    throw new Error('React.Children.only expected to receive a single React element child.');
   }
-  return ReactElement(element.type, key, void 0, void 0, owner, props);
-};
-exports.createContext = function (defaultValue) {
-  defaultValue = {
+  return children;
+}
+
+function createContext(defaultValue) {
+  // TODO: Second argument used to be an optional `calculateChangedBits`
+  // function. Warn to reserve for future use?
+
+  const context = {
     $$typeof: REACT_CONTEXT_TYPE,
+    // As a workaround to support multiple concurrent renderers, we categorize
+    // some renderers as primary and others as secondary. We only expect
+    // there to be two concurrent renderers at most: React Native (primary) and
+    // Fabric (secondary); React DOM (primary) and React ART (secondary).
+    // Secondary renderers store their context values on separate fields.
     _currentValue: defaultValue,
     _currentValue2: defaultValue,
+    // Used to track how many concurrent renderers this context currently
+    // supports within in a single renderer. Such as parallel server rendering.
     _threadCount: 0,
+    // These are circular
     Provider: null,
     Consumer: null
   };
-  defaultValue.Provider = defaultValue;
-  defaultValue.Consumer = {
+  context.Provider = context;
+  context.Consumer = {
     $$typeof: REACT_CONSUMER_TYPE,
-    _context: defaultValue
+    _context: context
   };
-  return defaultValue;
-};
-exports.createElement = function (type, config, children) {
-  var propName,
-    props = {},
-    key = null;
-  if (null != config)
-    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
-      hasOwnProperty.call(config, propName) &&
-        "key" !== propName &&
-        "__self" !== propName &&
-        "__source" !== propName &&
-        (props[propName] = config[propName]);
-  var childrenLength = arguments.length - 2;
-  if (1 === childrenLength) props.children = children;
-  else if (1 < childrenLength) {
-    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
-      childArray[i] = arguments[i + 2];
-    props.children = childArray;
+  return context;
+}
+
+const Uninitialized = -1;
+const Pending = 0;
+const Resolved = 1;
+const Rejected = 2;
+function lazyInitializer(payload) {
+  if (payload._status === Uninitialized) {
+    const ctor = payload._result;
+    const thenable = ctor();
+    // Transition to the next state.
+    // This might throw either because it's missing or throws. If so, we treat it
+    // as still uninitialized and try again next time. Which is the same as what
+    // happens if the ctor or any wrappers processing the ctor throws. This might
+    // end up fixing it if the resolution was a concurrency bug.
+    thenable.then(moduleObject => {
+      if (payload._status === Pending || payload._status === Uninitialized) {
+        // Transition to the next state.
+        const resolved = payload;
+        resolved._status = Resolved;
+        resolved._result = moduleObject;
+      }
+    }, error => {
+      if (payload._status === Pending || payload._status === Uninitialized) {
+        // Transition to the next state.
+        const rejected = payload;
+        rejected._status = Rejected;
+        rejected._result = error;
+      }
+    });
+    if (payload._status === Uninitialized) {
+      // In case, we're still uninitialized, then we're waiting for the thenable
+      // to resolve. Set it as pending in the meantime.
+      const pending = payload;
+      pending._status = Pending;
+      pending._result = thenable;
+    }
   }
-  if (type && type.defaultProps)
-    for (propName in ((childrenLength = type.defaultProps), childrenLength))
-      void 0 === props[propName] &&
-        (props[propName] = childrenLength[propName]);
-  return ReactElement(type, key, void 0, void 0, null, props);
-};
-exports.createRef = function () {
-  return { current: null };
-};
-exports.forwardRef = function (render) {
-  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };
-};
-exports.isValidElement = isValidElement;
-exports.lazy = function (ctor) {
-  return {
+  if (payload._status === Resolved) {
+    const moduleObject = payload._result;
+    return moduleObject.default;
+  } else {
+    throw payload._result;
+  }
+}
+function lazy(ctor) {
+  const payload = {
+    // We use these fields to store the result.
+    _status: Uninitialized,
+    _result: ctor
+  };
+  const lazyType = {
     $$typeof: REACT_LAZY_TYPE,
-    _payload: { _status: -1, _result: ctor },
+    _payload: payload,
     _init: lazyInitializer
   };
-};
-exports.memo = function (type, compare) {
-  return {
+  return lazyType;
+}
+
+function forwardRef(render) {
+  const elementType = {
+    $$typeof: REACT_FORWARD_REF_TYPE,
+    render
+  };
+  return elementType;
+}
+
+function memo(type, compare) {
+  const elementType = {
     $$typeof: REACT_MEMO_TYPE,
-    type: type,
-    compare: void 0 === compare ? null : compare
+    type,
+    compare: compare === undefined ? null : compare
+  };
+  return elementType;
+}
+
+function noopCache(fn) {
+  // On the client (i.e. not a Server Components environment) `cache` has
+  // no caching behavior. We just return the function as-is.
+  //
+  // We intend to implement client caching in a future major release. In the
+  // meantime, it's only exposed as an API so that Shared Components can use
+  // per-request caching on the server without breaking on the client. But it
+  // does mean they need to be aware of the behavioral difference.
+  //
+  // The rest of the behavior is the same as the server implementation  it
+  // returns a new reference, extra properties like `displayName` are not
+  // preserved, the length of the new function is 0, etc. That way apps can't
+  // accidentally depend on those details.
+  return function () {
+    // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.
+    return fn.apply(null, arguments);
   };
+}
+const cache = noopCache ;
+function noopCacheSignal() {
+  return null;
+}
+const cacheSignal = noopCacheSignal ;
+
+function postpone(reason) {
+  // eslint-disable-next-line react-internal/prod-error-codes
+  const postponeInstance = new Error(reason);
+  postponeInstance.$$typeof = REACT_POSTPONE_TYPE;
+  throw postponeInstance;
+}
+
+function resolveDispatcher() {
+  const dispatcher = ReactSharedInternals.H;
+  // Will result in a null access error if accessed outside render phase. We
+  // intentionally don't throw our own error because this is in a hot path.
+  // Also helps ensure this is inlined.
+  return dispatcher;
+}
+function getCacheForType(resourceType) {
+  const dispatcher = ReactSharedInternals.A;
+  if (!dispatcher) {
+    // If there is no dispatcher, then we treat this as not being cached.
+    return resourceType();
+  }
+  return dispatcher.getCacheForType(resourceType);
+}
+function useContext(Context) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useContext(Context);
+}
+function useState(initialState) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useState(initialState);
+}
+function useReducer(reducer, initialArg, init) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useReducer(reducer, initialArg, init);
+}
+function useRef(initialValue) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useRef(initialValue);
+}
+function useEffect(create, deps) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useEffect(create, deps);
+}
+function useInsertionEffect(create, deps) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useInsertionEffect(create, deps);
+}
+function useLayoutEffect(create, deps) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useLayoutEffect(create, deps);
+}
+function useCallback(callback, deps) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useCallback(callback, deps);
+}
+function useMemo(create, deps) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useMemo(create, deps);
+}
+function useImperativeHandle(ref, create, deps) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useImperativeHandle(ref, create, deps);
+}
+function useDebugValue(value, formatterFn) {
+}
+function useTransition() {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useTransition();
+}
+function useDeferredValue(value, initialValue) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useDeferredValue(value, initialValue);
+}
+function useId() {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useId();
+}
+function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
+}
+function useCacheRefresh() {
+  const dispatcher = resolveDispatcher();
+  // $FlowFixMe[not-a-function] This is unstable, thus optional
+  return dispatcher.useCacheRefresh();
+}
+function use(usable) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.use(usable);
+}
+function useMemoCache(size) {
+  const dispatcher = resolveDispatcher();
+  // $FlowFixMe[not-a-function] This is unstable, thus optional
+  return dispatcher.useMemoCache(size);
+}
+function useEffectEvent(callback) {
+  const dispatcher = resolveDispatcher();
+  // $FlowFixMe[not-a-function] This is unstable, thus optional
+  return dispatcher.useEffectEvent(callback);
+}
+function useOptimistic(passthrough, reducer) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useOptimistic(passthrough, reducer);
+}
+function useActionState(action, initialState, permalink) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useActionState(action, initialState, permalink);
+}
+
+const reportGlobalError = typeof reportError === 'function' ?
+// In modern browsers, reportError will dispatch an error event,
+// emulating an uncaught JavaScript error.
+reportError : error => {
+  if (typeof window === 'object' && typeof window.ErrorEvent === 'function') {
+    // Browser Polyfill
+    const message = typeof error === 'object' && error !== null && typeof error.message === 'string' ?
+    // eslint-disable-next-line react-internal/safe-string-coercion
+    String(error.message) :
+    // eslint-disable-next-line react-internal/safe-string-coercion
+    String(error);
+    const event = new window.ErrorEvent('error', {
+      bubbles: true,
+      cancelable: true,
+      message: message,
+      error: error
+    });
+    const shouldLog = window.dispatchEvent(event);
+    if (!shouldLog) {
+      return;
+    }
+  } else if (typeof process === 'object' &&
+  // $FlowFixMe[method-unbinding]
+  typeof process.emit === 'function') {
+    // Node Polyfill
+    process.emit('uncaughtException', error);
+    return;
+  }
+  console['error'](error);
 };
-exports.startTransition = function (scope) {
-  var prevTransition = ReactSharedInternals.T,
-    currentTransition = {};
+
+function releaseAsyncTransition() {
+}
+function startTransition(scope, options) {
+  const prevTransition = ReactSharedInternals.T;
+  const currentTransition = {};
+  {
+    currentTransition.types = prevTransition !== null ?
+    // If we're a nested transition, we should use the same set as the parent
+    // since we're conceptually always joined into the same entangled transition.
+    // In practice, this only matters if we add transition types in the inner
+    // without setting state. In that case, the inner transition can finish
+    // without waiting for the outer.
+    prevTransition.types : null;
+  }
+  {
+    currentTransition.gesture = null;
+  }
   ReactSharedInternals.T = currentTransition;
   try {
-    var returnValue = scope(),
-      onStartTransitionFinish = ReactSharedInternals.S;
-    null !== onStartTransitionFinish &&
+    const returnValue = scope();
+    const onStartTransitionFinish = ReactSharedInternals.S;
+    if (onStartTransitionFinish !== null) {
       onStartTransitionFinish(currentTransition, returnValue);
-    "object" === typeof returnValue &&
-      null !== returnValue &&
-      "function" === typeof returnValue.then &&
+    }
+    if (typeof returnValue === 'object' && returnValue !== null && typeof returnValue.then === 'function') {
+      if (false) ;
       returnValue.then(noop, reportGlobalError);
+    }
   } catch (error) {
     reportGlobalError(error);
   } finally {
+    if (prevTransition !== null && currentTransition.types !== null) {
+      prevTransition.types = currentTransition.types;
+    }
     ReactSharedInternals.T = prevTransition;
   }
+}
+function startGestureTransition(provider, scope, options) {
+  if (provider == null) {
+    // We enforce this at runtime even though the type also enforces it since we
+    // use null as a signal internally so it would lead it to be treated as a
+    // regular transition otherwise.
+    throw new Error('A Timeline is required as the first argument to startGestureTransition.');
+  }
+  const prevTransition = ReactSharedInternals.T;
+  const currentTransition = {};
+  {
+    currentTransition.types = null;
+  }
+  {
+    currentTransition.gesture = provider;
+  }
+  ReactSharedInternals.T = currentTransition;
+  try {
+    const returnValue = scope();
+    if (false) ;
+    const onStartGestureTransitionFinish = ReactSharedInternals.G;
+    if (onStartGestureTransitionFinish !== null) {
+      return onStartGestureTransitionFinish(currentTransition, provider, options);
+    }
+  } catch (error) {
+    reportGlobalError(error);
+  } finally {
+    ReactSharedInternals.T = prevTransition;
+  }
+  return noop;
+}
+
+function addTransitionType(type) {
+  {
+    const transition = ReactSharedInternals.T;
+    if (transition !== null) {
+      const transitionTypes = transition.types;
+      if (transitionTypes === null) {
+        transition.types = [type];
+      } else if (transitionTypes.indexOf(type) === -1) {
+        transitionTypes.push(type);
+      }
+    } else {
+      startTransition(addTransitionType.bind(null, type));
+    }
+  }
+}
+
+var ReactCompilerRuntime = {
+  __proto__: null,
+  c: useMemoCache
 };
-exports.unstable_useCacheRefresh = function () {
-  return ReactSharedInternals.H.useCacheRefresh();
-};
-exports.use = function (usable) {
-  return ReactSharedInternals.H.use(usable);
-};
-exports.useActionState = function (action, initialState, permalink) {
-  return ReactSharedInternals.H.useActionState(action, initialState, permalink);
-};
-exports.useCallback = function (callback, deps) {
-  return ReactSharedInternals.H.useCallback(callback, deps);
-};
-exports.useContext = function (Context) {
-  return ReactSharedInternals.H.useContext(Context);
-};
-exports.useDebugValue = function () {};
-exports.useDeferredValue = function (value, initialValue) {
-  return ReactSharedInternals.H.useDeferredValue(value, initialValue);
-};
-exports.useEffect = function (create, createDeps, update) {
-  var dispatcher = ReactSharedInternals.H;
-  if ("function" === typeof update)
-    throw Error(
-      "useEffect CRUD overload is not enabled in this build of React."
-    );
-  return dispatcher.useEffect(create, createDeps);
-};
-exports.useId = function () {
-  return ReactSharedInternals.H.useId();
-};
-exports.useImperativeHandle = function (ref, create, deps) {
-  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
-};
-exports.useInsertionEffect = function (create, deps) {
-  return ReactSharedInternals.H.useInsertionEffect(create, deps);
-};
-exports.useLayoutEffect = function (create, deps) {
-  return ReactSharedInternals.H.useLayoutEffect(create, deps);
-};
-exports.useMemo = function (create, deps) {
-  return ReactSharedInternals.H.useMemo(create, deps);
-};
-exports.useOptimistic = function (passthrough, reducer) {
-  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
-};
-exports.useReducer = function (reducer, initialArg, init) {
-  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
-};
-exports.useRef = function (initialValue) {
-  return ReactSharedInternals.H.useRef(initialValue);
-};
-exports.useState = function (initialState) {
-  return ReactSharedInternals.H.useState(initialState);
-};
-exports.useSyncExternalStore = function (
-  subscribe,
-  getSnapshot,
-  getServerSnapshot
-) {
-  return ReactSharedInternals.H.useSyncExternalStore(
-    subscribe,
-    getSnapshot,
-    getServerSnapshot
-  );
-};
-exports.useTransition = function () {
-  return ReactSharedInternals.H.useTransition();
+
+const Children = {
+  map: mapChildren,
+  forEach: forEachChildren,
+  count: countChildren,
+  toArray,
+  only: onlyChild
 };
-exports.version = "19.1.0";
+
+function experimental_useOptimistic(passthrough, reducer) {
+  return useOptimistic(passthrough, reducer);
+}
+
+exports.Children = Children;
+exports.Component = Component;
+exports.Fragment = REACT_FRAGMENT_TYPE;
+exports.Profiler = REACT_PROFILER_TYPE;
+exports.PureComponent = PureComponent;
+exports.StrictMode = REACT_STRICT_MODE_TYPE;
+exports.Suspense = REACT_SUSPENSE_TYPE;
+exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
+exports.__COMPILER_RUNTIME = ReactCompilerRuntime;
+exports.cache = cache;
+exports.cacheSignal = cacheSignal;
+exports.cloneElement = cloneElement;
+exports.createContext = createContext;
+exports.createElement = createElement;
+exports.createRef = createRef;
+exports.experimental_useEffectEvent = useEffectEvent;
+exports.experimental_useOptimistic = experimental_useOptimistic;
+exports.forwardRef = forwardRef;
+exports.isValidElement = isValidElement;
+exports.lazy = lazy;
+exports.memo = memo;
+exports.startTransition = startTransition;
+exports.unstable_Activity = REACT_ACTIVITY_TYPE;
+exports.unstable_SuspenseList = REACT_SUSPENSE_LIST_TYPE;
+exports.unstable_ViewTransition = REACT_VIEW_TRANSITION_TYPE;
+exports.unstable_addTransitionType = addTransitionType;
+exports.unstable_getCacheForType = getCacheForType;
+exports.unstable_postpone = postpone;
+exports.unstable_startGestureTransition = startGestureTransition;
+exports.unstable_useCacheRefresh = useCacheRefresh;
+exports.use = use;
+exports.useActionState = useActionState;
+exports.useCallback = useCallback;
+exports.useContext = useContext;
+exports.useDebugValue = useDebugValue;
+exports.useDeferredValue = useDeferredValue;
+exports.useEffect = useEffect;
+exports.useId = useId;
+exports.useImperativeHandle = useImperativeHandle;
+exports.useInsertionEffect = useInsertionEffect;
+exports.useLayoutEffect = useLayoutEffect;
+exports.useMemo = useMemo;
+exports.useOptimistic = useOptimistic;
+exports.useReducer = useReducer;
+exports.useRef = useRef;
+exports.useState = useState;
+exports.useSyncExternalStore = useSyncExternalStore;
+exports.useTransition = useTransition;
+exports.version = ReactVersion;
+//# sourceMappingURL=react.production.js.map
diff --git a/cjs/react.production.js.map b/cjs/react.production.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..4b40b8193983961e33df71c098bc5f894074b0fe
--- /dev/null
+++ b/cjs/react.production.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react.production.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactVersion.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactNoopUpdateQueue.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/assign.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactBaseClasses.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactCreateRef.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/isArray.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/noop.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactSharedInternalsClient.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/hasOwnProperty.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXElement.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactChildren.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactContext.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactLazy.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactForwardRef.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactMemo.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactCacheClient.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactPostpone.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactHooks.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/reportGlobalError.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactStartTransition.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactTransitionType.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactClient.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/index.experimental.js"],"sourcesContent":["export default '19.2.0-canary-602917c8-20250701';\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  if (__DEV__) {\n    const constructor = publicInstance.constructor;\n    const componentName =\n      (constructor && (constructor.displayName || constructor.name)) ||\n      'ReactClass';\n    const warningKey = `${componentName}.${callerName}`;\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n    console.error(\n      \"Can't call %s on a component that is not yet mounted. \" +\n        'This is a no-op, but it might indicate a bug in your application. ' +\n        'Instead, assign to `this.state` directly or define a `state = {};` ' +\n        'class property with the desired state in the %s component.',\n      callerName,\n      componentName,\n    );\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nconst ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (\n    publicInstance,\n    completeState,\n    callback,\n    callerName,\n  ) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (\n    publicInstance,\n    partialState,\n    callback,\n    callerName,\n  ) {\n    warnNoop(publicInstance, 'setState');\n  },\n};\n\nexport default ReactNoopUpdateQueue;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst assign = Object.assign;\n\nexport default assign;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ReactNoopUpdateQueue from './ReactNoopUpdateQueue';\nimport assign from 'shared/assign';\n\nconst emptyObject = {};\nif (__DEV__) {\n  Object.freeze(emptyObject);\n}\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nComponent.prototype.setState = function (partialState, callback) {\n  if (\n    typeof partialState !== 'object' &&\n    typeof partialState !== 'function' &&\n    partialState != null\n  ) {\n    throw new Error(\n      'takes an object of state variables to update or a ' +\n        'function which returns an object of state variables.',\n    );\n  }\n\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\nif (__DEV__) {\n  const deprecatedAPIs = {\n    isMounted: [\n      'isMounted',\n      'Instead, make sure to clean up subscriptions and pending requests in ' +\n        'componentWillUnmount to prevent memory leaks.',\n    ],\n    replaceState: [\n      'replaceState',\n      'Refactor your code to use setState instead (see ' +\n        'https://github.com/facebook/react/issues/3236).',\n    ],\n  };\n  const defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        console.warn(\n          '%s(...) is deprecated in plain JavaScript React classes. %s',\n          info[0],\n          info[1],\n        );\n        return undefined;\n      },\n    });\n  };\n  for (const fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\n\n/**\n * Convenience component with default shallow equality check for sCU.\n */\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nconst pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());\npureComponentPrototype.constructor = PureComponent;\n// Avoid an extra prototype jump for these methods.\nassign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\nexport {Component, PureComponent};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n * @flow\n */\n\nimport type {RefObject} from 'shared/ReactTypes';\n\n// an immutable object with a single mutable value\nexport function createRef(): RefObject {\n  const refObject = {\n    current: null,\n  };\n  if (__DEV__) {\n    Object.seal(refObject);\n  }\n  return refObject;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\ndeclare function isArray(a: mixed): boolean %checks(Array.isArray(a));\n\nconst isArrayImpl = Array.isArray;\n\nfunction isArray(a: mixed): boolean {\n  return isArrayImpl(a);\n}\n\nexport default isArray;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport default function noop() {}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {AsyncDispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {Transition} from './ReactStartTransition';\nimport type {GestureProvider, GestureOptions} from 'shared/ReactTypes';\n\nimport {enableGestureTransition} from 'shared/ReactFeatureFlags';\n\ntype onStartTransitionFinish = (Transition, mixed) => void;\ntype onStartGestureTransitionFinish = (\n  Transition,\n  GestureProvider,\n  ?GestureOptions,\n) => () => void;\n\nexport type SharedStateClient = {\n  H: null | Dispatcher, // ReactCurrentDispatcher for Hooks\n  A: null | AsyncDispatcher, // ReactCurrentCache for Cache\n  T: null | Transition, // ReactCurrentBatchConfig for Transitions\n  S: null | onStartTransitionFinish,\n  G: null | onStartGestureTransitionFinish,\n\n  // DEV-only\n\n  // ReactCurrentActQueue\n  actQueue: null | Array<RendererTask>,\n\n  // When zero this means we're outside an async startTransition.\n  asyncTransitions: number,\n\n  // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n  isBatchingLegacy: boolean,\n  didScheduleLegacyUpdate: boolean,\n\n  // Tracks whether something called `use` during the current batch of work.\n  // Determines whether we should yield to microtasks to unwrap already resolved\n  // promises without suspending.\n  didUsePromise: boolean,\n\n  // Track first uncaught error within this act\n  thrownErrors: Array<mixed>,\n\n  // ReactDebugCurrentFrame\n  getCurrentStack: null | (() => string),\n\n  // ReactOwnerStackReset\n  recentlyCreatedOwnerStacks: 0,\n};\n\nexport type RendererTask = boolean => RendererTask | null;\n\nconst ReactSharedInternals: SharedStateClient = ({\n  H: null,\n  A: null,\n  T: null,\n  S: null,\n}: any);\nif (enableGestureTransition) {\n  ReactSharedInternals.G = null;\n}\n\nif (__DEV__) {\n  ReactSharedInternals.actQueue = null;\n  ReactSharedInternals.asyncTransitions = 0;\n  ReactSharedInternals.isBatchingLegacy = false;\n  ReactSharedInternals.didScheduleLegacyUpdate = false;\n  ReactSharedInternals.didUsePromise = false;\n  ReactSharedInternals.thrownErrors = [];\n  // Stack implementation injected by the current renderer.\n  ReactSharedInternals.getCurrentStack = (null: null | (() => string));\n  ReactSharedInternals.recentlyCreatedOwnerStacks = 0;\n}\n\nexport default ReactSharedInternals;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// $FlowFixMe[method-unbinding]\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport default hasOwnProperty;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport assign from 'shared/assign';\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\nimport isArray from 'shared/isArray';\nimport {ownerStackLimit} from 'shared/ReactFeatureFlags';\n\nconst createTask =\n  // eslint-disable-next-line react-internal/no-production-logging\n  __DEV__ && console.createTask\n    ? // eslint-disable-next-line react-internal/no-production-logging\n      console.createTask\n    : () => null;\n\nfunction getTaskName(type) {\n  if (type === REACT_FRAGMENT_TYPE) {\n    return '<>';\n  }\n  if (\n    typeof type === 'object' &&\n    type !== null &&\n    type.$$typeof === REACT_LAZY_TYPE\n  ) {\n    // We don't want to eagerly initialize the initializer in DEV mode so we can't\n    // call it to extract the type so we don't know the type of this component.\n    return '<...>';\n  }\n  try {\n    const name = getComponentNameFromType(type);\n    return name ? '<' + name + '>' : '<...>';\n  } catch (x) {\n    return '<...>';\n  }\n}\n\nfunction getOwner() {\n  if (__DEV__) {\n    const dispatcher = ReactSharedInternals.A;\n    if (dispatcher === null) {\n      return null;\n    }\n    return dispatcher.getOwner();\n  }\n  return null;\n}\n\n/** @noinline */\nfunction UnknownOwner() {\n  /** @noinline */\n  return (() => Error('react-stack-top-frame'))();\n}\nconst createFakeCallStack = {\n  react_stack_bottom_frame: function (callStackForError) {\n    return callStackForError();\n  },\n};\n\nlet specialPropKeyWarningShown;\nlet didWarnAboutElementRef;\nlet didWarnAboutOldJSXRuntime;\nlet unknownOwnerDebugStack;\nlet unknownOwnerDebugTask;\n\nif (__DEV__) {\n  didWarnAboutElementRef = {};\n\n  // We use this technique to trick minifiers to preserve the function name.\n  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(\n    createFakeCallStack,\n    UnknownOwner,\n  )();\n  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://react.dev/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction elementRefGetterWithDeprecationWarning() {\n  if (__DEV__) {\n    const componentName = getComponentNameFromType(this.type);\n    if (!didWarnAboutElementRef[componentName]) {\n      didWarnAboutElementRef[componentName] = true;\n      console.error(\n        'Accessing element.ref was removed in React 19. ref is now a ' +\n          'regular prop. It will be removed from the JSX Element ' +\n          'type in a future release.',\n      );\n    }\n\n    // An undefined `element.ref` is coerced to `null` for\n    // backwards compatibility.\n    const refProp = this.props.ref;\n    return refProp !== undefined ? refProp : null;\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nfunction ReactElement(\n  type,\n  key,\n  self,\n  source,\n  owner,\n  props,\n  debugStack,\n  debugTask,\n) {\n  // Ignore whatever was passed as the ref argument and treat `props.ref` as\n  // the source of truth. The only thing we use this for is `element.ref`,\n  // which will log a deprecation warning on access. In the next release, we\n  // can remove `element.ref` as well as the `ref` argument.\n  const refProp = props.ref;\n\n  // An undefined `element.ref` is coerced to `null` for\n  // backwards compatibility.\n  const ref = refProp !== undefined ? refProp : null;\n\n  let element;\n  if (__DEV__) {\n    // In dev, make `ref` a non-enumerable property with a warning. It's non-\n    // enumerable so that test matchers and serializers don't access it and\n    // trigger the warning.\n    //\n    // `ref` will be removed from the element completely in a future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n\n      props,\n\n      // Record the component responsible for creating this element.\n      _owner: owner,\n    };\n    if (ref !== null) {\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        get: elementRefGetterWithDeprecationWarning,\n      });\n    } else {\n      // Don't warn on access if a ref is not given. This reduces false\n      // positives in cases where a test serializer uses\n      // getOwnPropertyDescriptors to compare objects, like Jest does, which is\n      // a problem because it bypasses non-enumerability.\n      //\n      // So unfortunately this will trigger a false positive warning in Jest\n      // when the diff is printed:\n      //\n      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);\n      //\n      // A bit sketchy, but this is what we've done for the `props.key` and\n      // `props.ref` accessors for years, which implies it will be good enough\n      // for `element.ref`, too. Let's see if anyone complains.\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        value: null,\n      });\n    }\n  } else {\n    // In prod, `ref` is a regular property and _owner doesn't exist.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n      ref,\n\n      props,\n    };\n  }\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: 0,\n    });\n    // debugInfo contains Server Component debug information.\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null,\n    });\n    Object.defineProperty(element, '_debugStack', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugStack,\n    });\n    Object.defineProperty(element, '_debugTask', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugTask,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxProd(type, config, maybeKey) {\n  let key = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  let props;\n  if (!('key' in config)) {\n    // If key was not spread in, we can reuse the original props object. This\n    // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n    // target and the compiler always passes a new object. For `createElement`,\n    // we can't assume a new object is passed every time because it can be\n    // called manually.\n    //\n    // Spreading key is a warning in dev. In a future release, we will not\n    // remove a spread key from the props object. (But we'll still warn.) We'll\n    // always pass the object straight through.\n    props = config;\n  } else {\n    // We need to remove reserved props (key, prop, ref). Create a fresh props\n    // object and copy over all the non-reserved props. We don't use `delete`\n    // because in V8 it will deopt the object to dictionary mode.\n    props = {};\n    for (const propName in config) {\n      // Skip over reserved prop names\n      if (propName !== 'key') {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    undefined,\n    undefined,\n  );\n}\n\n// While `jsxDEV` should never be called when running in production, we do\n// support `jsx` and `jsxs` when running in development. This supports the case\n// where a third-party dependency ships code that was compiled for production;\n// we want to still provide warnings in development.\n//\n// So these functions are the _dev_ implementations of the _production_\n// API signatures.\n//\n// Since these functions are dev-only, it's ok to add an indirection here. They\n// only exist to provide different versions of `isStaticChildren`. (We shouldn't\n// use this pattern for the prod versions, though, because it will add an call\n// frame.)\nexport function jsxProdSignatureRunningInDevWithDynamicChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = false;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nexport function jsxProdSignatureRunningInDevWithStaticChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = true;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nconst didWarnAboutKeySpread = {};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return jsxDEVImpl(\n    type,\n    config,\n    maybeKey,\n    isStaticChildren,\n    source,\n    self,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nfunction jsxDEVImpl(\n  type,\n  config,\n  maybeKey,\n  isStaticChildren,\n  source,\n  self,\n  debugStack,\n  debugTask,\n) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    // With owner stacks, we no longer need the type here so this comment is\n    // no longer true. Which is why we can run this even for invalid types.\n    const children = config.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          console.error(\n            'React.jsx: Static children should always be an array. ' +\n              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n              'Use the Babel transform instead.',\n          );\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n\n    // Warn about key spread regardless of whether the type is valid.\n    if (hasOwnProperty.call(config, 'key')) {\n      const componentName = getComponentNameFromType(type);\n      const keys = Object.keys(config).filter(k => k !== 'key');\n      const beforeExample =\n        keys.length > 0\n          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'\n          : '{key: someKey}';\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        const afterExample =\n          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n        console.error(\n          'A props object containing a \"key\" prop is being spread into JSX:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s {...props} />\\n' +\n            'React keys must be passed directly to JSX without using spread:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s key={someKey} {...props} />',\n          beforeExample,\n          componentName,\n          afterExample,\n          componentName,\n        );\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    let key = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    let props;\n    if (!('key' in config)) {\n      // If key was not spread in, we can reuse the original props object. This\n      // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n      // target and the compiler always passes a new object. For `createElement`,\n      // we can't assume a new object is passed every time because it can be\n      // called manually.\n      //\n      // Spreading key is a warning in dev. In a future release, we will not\n      // remove a spread key from the props object. (But we'll still warn.) We'll\n      // always pass the object straight through.\n      props = config;\n    } else {\n      // We need to remove reserved props (key, prop, ref). Create a fresh props\n      // object and copy over all the non-reserved props. We don't use `delete`\n      // because in V8 it will deopt the object to dictionary mode.\n      props = {};\n      for (const propName in config) {\n        // Skip over reserved prop names\n        if (propName !== 'key') {\n          props[propName] = config[propName];\n        }\n      }\n    }\n\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    return ReactElement(\n      type,\n      key,\n      self,\n      source,\n      getOwner(),\n      props,\n      debugStack,\n      debugTask,\n    );\n  }\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n  }\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const clonedElement = ReactElement(\n    oldElement.type,\n    newKey,\n    undefined,\n    undefined,\n    !__DEV__ ? undefined : oldElement._owner,\n    oldElement.props,\n    __DEV__ && oldElement._debugStack,\n    __DEV__ && oldElement._debugTask,\n  );\n  if (__DEV__) {\n    // The cloned element should inherit the original element's key validation.\n    if (oldElement._store) {\n      clonedElement._store.validated = oldElement._store.validated;\n    }\n  }\n  return clonedElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = !__DEV__ ? undefined : element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      owner = __DEV__ ? getOwner() : undefined;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // ...and maybe these, too, though we currently rely on them for\n        // warnings and debug information in dev. Need to decide if we're OK\n        // with dropping them. In the jsx() runtime it's not an issue because\n        // the data gets passed as separate arguments instead of props, but\n        // it would be nice to stop relying on them entirely so we can drop\n        // them from the internal Fiber field.\n        propName !== '__self' &&\n        propName !== '__source' &&\n        // Undefined `ref` is ignored by cloneElement. We treat it the same as\n        // if the property were missing. This is mostly for\n        // backwards compatibility.\n        !(propName === 'ref' && config.ref === undefined)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  const clonedElement = ReactElement(\n    element.type,\n    key,\n    undefined,\n    undefined,\n    owner,\n    props,\n    __DEV__ && element._debugStack,\n    __DEV__ && element._debugTask,\n  );\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], clonedElement.type);\n  }\n\n  return clonedElement;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    // With owner stacks is, no warnings happens. All we do is\n    // mark elements as being in a valid static child position so they\n    // don't need keys.\n    if (isValidElement(node)) {\n      if (node._store) {\n        node._store.validated = 1;\n      }\n    }\n  }\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  ReactNodeList,\n  Thenable,\n  PendingThenable,\n  FulfilledThenable,\n  RejectedThenable,\n} from 'shared/ReactTypes';\n\nimport isArray from 'shared/isArray';\nimport noop from 'shared/noop';\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_PORTAL_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\n\nimport {isValidElement, cloneAndReplaceKey} from './jsx/ReactJSXElement';\n\nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key: string): string {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedString = key.replace(escapeRegex, function (match) {\n    // $FlowFixMe[invalid-computed-prop]\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nlet didWarnAboutMaps = false;\n\nconst userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text: string): string {\n  return text.replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\n/**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getElementKey(element: any, index: number): string {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    // Explicit key\n    if (__DEV__) {\n      checkKeyStringCoercion(element.key);\n    }\n    return escape('' + element.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction resolveThenable<T>(thenable: Thenable<T>): T {\n  switch (thenable.status) {\n    case 'fulfilled': {\n      const fulfilledValue: T = thenable.value;\n      return fulfilledValue;\n    }\n    case 'rejected': {\n      const rejectedError = thenable.reason;\n      throw rejectedError;\n    }\n    default: {\n      if (typeof thenable.status === 'string') {\n        // Only instrument the thenable if the status if not defined. If\n        // it's defined, but an unknown value, assume it's been instrumented by\n        // some custom userspace implementation. We treat it as \"pending\".\n        // Attach a dummy listener, to ensure that any lazy initialization can\n        // happen. Flight lazily parses JSON when the value is actually awaited.\n        thenable.then(noop, noop);\n      } else {\n        // This is an uncached thenable that we haven't seen before.\n\n        // TODO: Detect infinite ping loops caused by uncached promises.\n\n        const pendingThenable: PendingThenable<T> = (thenable: any);\n        pendingThenable.status = 'pending';\n        pendingThenable.then(\n          fulfilledValue => {\n            if (thenable.status === 'pending') {\n              const fulfilledThenable: FulfilledThenable<T> = (thenable: any);\n              fulfilledThenable.status = 'fulfilled';\n              fulfilledThenable.value = fulfilledValue;\n            }\n          },\n          (error: mixed) => {\n            if (thenable.status === 'pending') {\n              const rejectedThenable: RejectedThenable<T> = (thenable: any);\n              rejectedThenable.status = 'rejected';\n              rejectedThenable.reason = error;\n            }\n          },\n        );\n      }\n\n      // Check one more time in case the thenable resolved synchronously.\n      switch ((thenable: Thenable<T>).status) {\n        case 'fulfilled': {\n          const fulfilledThenable: FulfilledThenable<T> = (thenable: any);\n          return fulfilledThenable.value;\n        }\n        case 'rejected': {\n          const rejectedThenable: RejectedThenable<T> = (thenable: any);\n          const rejectedError = rejectedThenable.reason;\n          throw rejectedError;\n        }\n      }\n    }\n  }\n  throw thenable;\n}\n\nfunction mapIntoArray(\n  children: ?ReactNodeList,\n  array: Array<React$Node>,\n  escapedPrefix: string,\n  nameSoFar: string,\n  callback: (?React$Node) => ?ReactNodeList,\n): number {\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  let invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'bigint':\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch ((children: any).$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n            break;\n          case REACT_LAZY_TYPE:\n            const payload = (children: any)._payload;\n            const init = (children: any)._init;\n            return mapIntoArray(\n              init(payload),\n              array,\n              escapedPrefix,\n              nameSoFar,\n              callback,\n            );\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    const child = children;\n    let mappedChild = callback(child);\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows:\n    const childKey =\n      nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;\n    if (isArray(mappedChild)) {\n      let escapedChildKey = '';\n      if (childKey != null) {\n        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n      }\n      mapIntoArray(mappedChild, array, escapedChildKey, '', c => c);\n    } else if (mappedChild != null) {\n      if (isValidElement(mappedChild)) {\n        if (__DEV__) {\n          // The `if` statement here prevents auto-disabling of the safe\n          // coercion ESLint rule, so we must manually disable it below.\n          // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n          if (mappedChild.key != null) {\n            if (!child || child.key !== mappedChild.key) {\n              checkKeyStringCoercion(mappedChild.key);\n            }\n          }\n        }\n        const newChild = cloneAndReplaceKey(\n          mappedChild,\n          // Keep both the (mapped) and old keys if they differ, just as\n          // traverseAllChildren used to do for objects as children\n          escapedPrefix +\n            // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n            (mappedChild.key != null &&\n            (!child || child.key !== mappedChild.key)\n              ? escapeUserProvidedKey(\n                  // $FlowFixMe[unsafe-addition]\n                  '' + mappedChild.key, // eslint-disable-line react-internal/safe-string-coercion\n                ) + '/'\n              : '') +\n            childKey,\n        );\n        if (__DEV__) {\n          // If `child` was an element without a `key`, we need to validate if\n          // it should have had a `key`, before assigning one to `mappedChild`.\n          // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n          if (\n            nameSoFar !== '' &&\n            child != null &&\n            isValidElement(child) &&\n            child.key == null\n          ) {\n            // We check truthiness of `child._store.validated` instead of being\n            // inequal to `1` to provide a bit of backward compatibility for any\n            // libraries (like `fbt`) which may be hacking this property.\n            if (child._store && !child._store.validated) {\n              // Mark this child as having failed validation, but let the actual\n              // renderer print the warning later.\n              newChild._store.validated = 2;\n            }\n          }\n        }\n        mappedChild = newChild;\n      }\n      array.push(mappedChild);\n    }\n    return 1;\n  }\n\n  let child;\n  let nextName;\n  let subtreeCount = 0; // Count of children found in the current subtree.\n  const nextNamePrefix =\n    nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getElementKey(child, i);\n      subtreeCount += mapIntoArray(\n        child,\n        array,\n        escapedPrefix,\n        nextName,\n        callback,\n      );\n    }\n  } else {\n    const iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      const iterableChildren: Iterable<React$Node> & {\n        entries: any,\n      } = (children: any);\n\n      if (__DEV__) {\n        // Warn about using Maps as children\n        if (iteratorFn === iterableChildren.entries) {\n          if (!didWarnAboutMaps) {\n            console.warn(\n              'Using Maps as children is not supported. ' +\n                'Use an array of keyed ReactElements instead.',\n            );\n          }\n          didWarnAboutMaps = true;\n        }\n      }\n\n      const iterator = iteratorFn.call(iterableChildren);\n      let step;\n      let ii = 0;\n      // $FlowFixMe[incompatible-use] `iteratorFn` might return null according to typing.\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getElementKey(child, ii++);\n        subtreeCount += mapIntoArray(\n          child,\n          array,\n          escapedPrefix,\n          nextName,\n          callback,\n        );\n      }\n    } else if (type === 'object') {\n      if (typeof (children: any).then === 'function') {\n        return mapIntoArray(\n          resolveThenable((children: any)),\n          array,\n          escapedPrefix,\n          nameSoFar,\n          callback,\n        );\n      }\n\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      const childrenString = String((children: any));\n\n      throw new Error(\n        `Objects are not valid as a React child (found: ${\n          childrenString === '[object Object]'\n            ? 'object with keys {' +\n              Object.keys((children: any)).join(', ') +\n              '}'\n            : childrenString\n        }). ` +\n          'If you meant to render a collection of children, use an array ' +\n          'instead.',\n      );\n    }\n  }\n\n  return subtreeCount;\n}\n\ntype MapFunc = (child: ?React$Node, index: number) => ?ReactNodeList;\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(\n  children: ?ReactNodeList,\n  func: MapFunc,\n  context: mixed,\n): ?Array<React$Node> {\n  if (children == null) {\n    // $FlowFixMe limitation refining abstract types in Flow\n    return children;\n  }\n  const result: Array<React$Node> = [];\n  let count = 0;\n  mapIntoArray(children, result, '', '', function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children: ?ReactNodeList): number {\n  let n = 0;\n  mapChildren(children, () => {\n    n++;\n    // Don't return anything\n  });\n  return n;\n}\n\ntype ForEachFunc = (child: ?React$Node) => void;\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(\n  children: ?ReactNodeList,\n  forEachFunc: ForEachFunc,\n  forEachContext: mixed,\n): void {\n  mapChildren(\n    children,\n    // $FlowFixMe[missing-this-annot]\n    function () {\n      forEachFunc.apply(this, arguments);\n      // Don't return anything.\n    },\n    forEachContext,\n  );\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\nfunction toArray(children: ?ReactNodeList): Array<React$Node> {\n  return mapChildren(children, child => child) || [];\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild<T>(children: T): T {\n  if (!isValidElement(children)) {\n    throw new Error(\n      'React.Children.only expected to receive a single React element child.',\n    );\n  }\n\n  return children;\n}\n\nexport {\n  forEachChildren as forEach,\n  mapChildren as map,\n  countChildren as count,\n  onlyChild as only,\n  toArray,\n};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {REACT_CONSUMER_TYPE, REACT_CONTEXT_TYPE} from 'shared/ReactSymbols';\n\nimport type {ReactContext} from 'shared/ReactTypes';\n\nexport function createContext<T>(defaultValue: T): ReactContext<T> {\n  // TODO: Second argument used to be an optional `calculateChangedBits`\n  // function. Warn to reserve for future use?\n\n  const context: ReactContext<T> = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    // As a workaround to support multiple concurrent renderers, we categorize\n    // some renderers as primary and others as secondary. We only expect\n    // there to be two concurrent renderers at most: React Native (primary) and\n    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n    // Secondary renderers store their context values on separate fields.\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    // Used to track how many concurrent renderers this context currently\n    // supports within in a single renderer. Such as parallel server rendering.\n    _threadCount: 0,\n    // These are circular\n    Provider: (null: any),\n    Consumer: (null: any),\n  };\n\n  context.Provider = context;\n  context.Consumer = {\n    $$typeof: REACT_CONSUMER_TYPE,\n    _context: context,\n  };\n  if (__DEV__) {\n    context._currentRenderer = null;\n    context._currentRenderer2 = null;\n  }\n\n  return context;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Wakeable, Thenable, ReactDebugInfo} from 'shared/ReactTypes';\n\nimport {REACT_LAZY_TYPE} from 'shared/ReactSymbols';\n\nconst Uninitialized = -1;\nconst Pending = 0;\nconst Resolved = 1;\nconst Rejected = 2;\n\ntype UninitializedPayload<T> = {\n  _status: -1,\n  _result: () => Thenable<{default: T, ...}>,\n};\n\ntype PendingPayload = {\n  _status: 0,\n  _result: Wakeable,\n};\n\ntype ResolvedPayload<T> = {\n  _status: 1,\n  _result: {default: T, ...},\n};\n\ntype RejectedPayload = {\n  _status: 2,\n  _result: mixed,\n};\n\ntype Payload<T> =\n  | UninitializedPayload<T>\n  | PendingPayload\n  | ResolvedPayload<T>\n  | RejectedPayload;\n\nexport type LazyComponent<T, P> = {\n  $$typeof: symbol | number,\n  _payload: P,\n  _init: (payload: P) => T,\n  _debugInfo?: null | ReactDebugInfo,\n};\n\nfunction lazyInitializer<T>(payload: Payload<T>): T {\n  if (payload._status === Uninitialized) {\n    const ctor = payload._result;\n    const thenable = ctor();\n    // Transition to the next state.\n    // This might throw either because it's missing or throws. If so, we treat it\n    // as still uninitialized and try again next time. Which is the same as what\n    // happens if the ctor or any wrappers processing the ctor throws. This might\n    // end up fixing it if the resolution was a concurrency bug.\n    thenable.then(\n      moduleObject => {\n        if (\n          (payload: Payload<T>)._status === Pending ||\n          payload._status === Uninitialized\n        ) {\n          // Transition to the next state.\n          const resolved: ResolvedPayload<T> = (payload: any);\n          resolved._status = Resolved;\n          resolved._result = moduleObject;\n        }\n      },\n      error => {\n        if (\n          (payload: Payload<T>)._status === Pending ||\n          payload._status === Uninitialized\n        ) {\n          // Transition to the next state.\n          const rejected: RejectedPayload = (payload: any);\n          rejected._status = Rejected;\n          rejected._result = error;\n        }\n      },\n    );\n    if (payload._status === Uninitialized) {\n      // In case, we're still uninitialized, then we're waiting for the thenable\n      // to resolve. Set it as pending in the meantime.\n      const pending: PendingPayload = (payload: any);\n      pending._status = Pending;\n      pending._result = thenable;\n    }\n  }\n  if (payload._status === Resolved) {\n    const moduleObject = payload._result;\n    if (__DEV__) {\n      if (moduleObject === undefined) {\n        console.error(\n          'lazy: Expected the result of a dynamic imp' +\n            'ort() call. ' +\n            'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' +\n            \"ort('./MyComponent'))\\n\\n\" +\n            'Did you accidentally put curly braces around the import?',\n          moduleObject,\n        );\n      }\n    }\n    if (__DEV__) {\n      if (!('default' in moduleObject)) {\n        console.error(\n          'lazy: Expected the result of a dynamic imp' +\n            'ort() call. ' +\n            'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' +\n            \"ort('./MyComponent'))\",\n          moduleObject,\n        );\n      }\n    }\n    return moduleObject.default;\n  } else {\n    throw payload._result;\n  }\n}\n\nexport function lazy<T>(\n  ctor: () => Thenable<{default: T, ...}>,\n): LazyComponent<T, Payload<T>> {\n  const payload: Payload<T> = {\n    // We use these fields to store the result.\n    _status: Uninitialized,\n    _result: ctor,\n  };\n\n  const lazyType: LazyComponent<T, Payload<T>> = {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: payload,\n    _init: lazyInitializer,\n  };\n\n  return lazyType;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n */\n\nimport {REACT_FORWARD_REF_TYPE, REACT_MEMO_TYPE} from 'shared/ReactSymbols';\n\nexport function forwardRef<Props, ElementType: React$ElementType>(\n  render: (\n    props: Props,\n    ref: React$RefSetter<React$ElementRef<ElementType>>,\n  ) => React$Node,\n) {\n  if (__DEV__) {\n    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n      console.error(\n        'forwardRef requires a render function but received a `memo` ' +\n          'component. Instead of forwardRef(memo(...)), use ' +\n          'memo(forwardRef(...)).',\n      );\n    } else if (typeof render !== 'function') {\n      console.error(\n        'forwardRef requires a render function but was given %s.',\n        render === null ? 'null' : typeof render,\n      );\n    } else {\n      if (render.length !== 0 && render.length !== 2) {\n        console.error(\n          'forwardRef render functions accept exactly two parameters: props and ref. %s',\n          render.length === 1\n            ? 'Did you forget to use the ref parameter?'\n            : 'Any additional parameter will be undefined.',\n        );\n      }\n    }\n\n    if (render != null) {\n      if (render.defaultProps != null) {\n        console.error(\n          'forwardRef render functions do not support defaultProps. ' +\n            'Did you accidentally pass a React component?',\n        );\n      }\n    }\n  }\n\n  const elementType = {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render,\n  };\n  if (__DEV__) {\n    let ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name;\n\n        // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.forwardRef((props, ref) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n        if (!render.name && !render.displayName) {\n          Object.defineProperty(render, 'name', {\n            value: name,\n          });\n          render.displayName = name;\n        }\n      },\n    });\n  }\n  return elementType;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n */\n\nimport {REACT_MEMO_TYPE} from 'shared/ReactSymbols';\n\nexport function memo<Props>(\n  type: React$ElementType,\n  compare?: (oldProps: Props, newProps: Props) => boolean,\n) {\n  if (__DEV__) {\n    if (type == null) {\n      console.error(\n        'memo: The first argument must be a component. Instead ' +\n          'received: %s',\n        type === null ? 'null' : typeof type,\n      );\n    }\n  }\n  const elementType = {\n    $$typeof: REACT_MEMO_TYPE,\n    type,\n    compare: compare === undefined ? null : compare,\n  };\n  if (__DEV__) {\n    let ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name;\n\n        // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.memo((props) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n        if (!type.name && !type.displayName) {\n          Object.defineProperty(type, 'name', {\n            value: name,\n          });\n          type.displayName = name;\n        }\n      },\n    });\n  }\n  return elementType;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {disableClientCache} from 'shared/ReactFeatureFlags';\nimport {\n  cache as cacheImpl,\n  cacheSignal as cacheSignalImpl,\n} from './ReactCacheImpl';\n\nfunction noopCache<A: Iterable<mixed>, T>(fn: (...A) => T): (...A) => T {\n  // On the client (i.e. not a Server Components environment) `cache` has\n  // no caching behavior. We just return the function as-is.\n  //\n  // We intend to implement client caching in a future major release. In the\n  // meantime, it's only exposed as an API so that Shared Components can use\n  // per-request caching on the server without breaking on the client. But it\n  // does mean they need to be aware of the behavioral difference.\n  //\n  // The rest of the behavior is the same as the server implementation  it\n  // returns a new reference, extra properties like `displayName` are not\n  // preserved, the length of the new function is 0, etc. That way apps can't\n  // accidentally depend on those details.\n  return function () {\n    // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.\n    return fn.apply(null, arguments);\n  };\n}\n\nexport const cache: typeof noopCache = disableClientCache\n  ? noopCache\n  : cacheImpl;\n\nfunction noopCacheSignal(): null | AbortSignal {\n  return null;\n}\n\nexport const cacheSignal: () => null | AbortSignal = disableClientCache\n  ? noopCacheSignal\n  : cacheSignalImpl;\n","/**\n * Copyright (c) Meta Platforms, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {REACT_POSTPONE_TYPE} from 'shared/ReactSymbols';\n\ndeclare class Postpone extends Error {\n  $$typeof: symbol;\n}\n\nexport type {Postpone};\n\nexport function postpone(reason: string): void {\n  // eslint-disable-next-line react-internal/prod-error-codes\n  const postponeInstance: Postpone = (new Error(reason): any);\n  postponeInstance.$$typeof = REACT_POSTPONE_TYPE;\n  throw postponeInstance;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  ReactContext,\n  StartTransitionOptions,\n  Usable,\n  Awaited,\n} from 'shared/ReactTypes';\nimport {REACT_CONSUMER_TYPE} from 'shared/ReactSymbols';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\ntype BasicStateAction<S> = (S => S) | S;\ntype Dispatch<A> = A => void;\n\nfunction resolveDispatcher() {\n  const dispatcher = ReactSharedInternals.H;\n  if (__DEV__) {\n    if (dispatcher === null) {\n      console.error(\n        'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n          ' one of the following reasons:\\n' +\n          '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n          '2. You might be breaking the Rules of Hooks\\n' +\n          '3. You might have more than one copy of React in the same app\\n' +\n          'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.',\n      );\n    }\n  }\n  // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n  return ((dispatcher: any): Dispatcher);\n}\n\nexport function getCacheForType<T>(resourceType: () => T): T {\n  const dispatcher = ReactSharedInternals.A;\n  if (!dispatcher) {\n    // If there is no dispatcher, then we treat this as not being cached.\n    return resourceType();\n  }\n  return dispatcher.getCacheForType(resourceType);\n}\n\nexport function useContext<T>(Context: ReactContext<T>): T {\n  const dispatcher = resolveDispatcher();\n  if (__DEV__) {\n    if (Context.$$typeof === REACT_CONSUMER_TYPE) {\n      console.error(\n        'Calling useContext(Context.Consumer) is not supported and will cause bugs. ' +\n          'Did you mean to call useContext(Context) instead?',\n      );\n    }\n  }\n  return dispatcher.useContext(Context);\n}\n\nexport function useState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n\nexport function useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\n\nexport function useRef<T>(initialValue: T): {current: T} {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\n\nexport function useEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\n\nexport function useInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\n\nexport function useLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\n\nexport function useCallback<T>(\n  callback: T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\n\nexport function useMemo<T>(\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\n\nexport function useImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\n\nexport function useDebugValue<T>(\n  value: T,\n  formatterFn: ?(value: T) => mixed,\n): void {\n  if (__DEV__) {\n    const dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\n\nexport function useTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\n\nexport function useDeferredValue<T>(value: T, initialValue?: T): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value, initialValue);\n}\n\nexport function useId(): string {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\n\nexport function useSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n  );\n}\n\nexport function useCacheRefresh(): <T>(?() => T, ?T) => void {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useCacheRefresh();\n}\n\nexport function use<T>(usable: Usable<T>): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.use(usable);\n}\n\nexport function useMemoCache(size: number): Array<mixed> {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useMemoCache(size);\n}\n\nexport function useEffectEvent<Args, F: (...Array<Args>) => mixed>(\n  callback: F,\n): F {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useEffectEvent(callback);\n}\n\nexport function useOptimistic<S, A>(\n  passthrough: S,\n  reducer: ?(S, A) => S,\n): [S, (A) => void] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useOptimistic(passthrough, reducer);\n}\n\nexport function useActionState<S, P>(\n  action: (Awaited<S>, P) => S,\n  initialState: Awaited<S>,\n  permalink?: string,\n): [Awaited<S>, (P) => void, boolean] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useActionState(action, initialState, permalink);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst reportGlobalError: (error: mixed) => void =\n  typeof reportError === 'function'\n    ? // In modern browsers, reportError will dispatch an error event,\n      // emulating an uncaught JavaScript error.\n      reportError\n    : error => {\n        if (\n          typeof window === 'object' &&\n          typeof window.ErrorEvent === 'function'\n        ) {\n          // Browser Polyfill\n          const message =\n            typeof error === 'object' &&\n            error !== null &&\n            typeof error.message === 'string'\n              ? // eslint-disable-next-line react-internal/safe-string-coercion\n                String(error.message)\n              : // eslint-disable-next-line react-internal/safe-string-coercion\n                String(error);\n          const event = new window.ErrorEvent('error', {\n            bubbles: true,\n            cancelable: true,\n            message: message,\n            error: error,\n          });\n          const shouldLog = window.dispatchEvent(event);\n          if (!shouldLog) {\n            return;\n          }\n        } else if (\n          typeof process === 'object' &&\n          // $FlowFixMe[method-unbinding]\n          typeof process.emit === 'function'\n        ) {\n          // Node Polyfill\n          process.emit('uncaughtException', error);\n          return;\n        }\n        console['error'](error);\n      };\n\nexport default reportGlobalError;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  StartTransitionOptions,\n  GestureProvider,\n  GestureOptions,\n} from 'shared/ReactTypes';\nimport type {TransitionTypes} from './ReactTransitionType';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nimport {\n  enableTransitionTracing,\n  enableViewTransition,\n  enableGestureTransition,\n} from 'shared/ReactFeatureFlags';\n\nimport reportGlobalError from 'shared/reportGlobalError';\n\nimport noop from 'shared/noop';\n\nexport type Transition = {\n  types: null | TransitionTypes, // enableViewTransition\n  gesture: null | GestureProvider, // enableGestureTransition\n  name: null | string, // enableTransitionTracing only\n  startTime: number, // enableTransitionTracing only\n  _updatedFibers: Set<Fiber>, // DEV-only\n  ...\n};\n\nfunction releaseAsyncTransition() {\n  if (__DEV__) {\n    ReactSharedInternals.asyncTransitions--;\n  }\n}\n\nexport function startTransition(\n  scope: () => void,\n  options?: StartTransitionOptions,\n): void {\n  const prevTransition = ReactSharedInternals.T;\n  const currentTransition: Transition = ({}: any);\n  if (enableViewTransition) {\n    currentTransition.types =\n      prevTransition !== null\n        ? // If we're a nested transition, we should use the same set as the parent\n          // since we're conceptually always joined into the same entangled transition.\n          // In practice, this only matters if we add transition types in the inner\n          // without setting state. In that case, the inner transition can finish\n          // without waiting for the outer.\n          prevTransition.types\n        : null;\n  }\n  if (enableGestureTransition) {\n    currentTransition.gesture = null;\n  }\n  if (enableTransitionTracing) {\n    currentTransition.name =\n      options !== undefined && options.name !== undefined ? options.name : null;\n    currentTransition.startTime = -1; // TODO: This should read the timestamp.\n  }\n  if (__DEV__) {\n    currentTransition._updatedFibers = new Set();\n  }\n  ReactSharedInternals.T = currentTransition;\n\n  try {\n    const returnValue = scope();\n    const onStartTransitionFinish = ReactSharedInternals.S;\n    if (onStartTransitionFinish !== null) {\n      onStartTransitionFinish(currentTransition, returnValue);\n    }\n    if (\n      typeof returnValue === 'object' &&\n      returnValue !== null &&\n      typeof returnValue.then === 'function'\n    ) {\n      if (__DEV__) {\n        // Keep track of the number of async transitions still running so we can warn.\n        ReactSharedInternals.asyncTransitions++;\n        returnValue.then(releaseAsyncTransition, releaseAsyncTransition);\n      }\n      returnValue.then(noop, reportGlobalError);\n    }\n  } catch (error) {\n    reportGlobalError(error);\n  } finally {\n    warnAboutTransitionSubscriptions(prevTransition, currentTransition);\n    if (prevTransition !== null && currentTransition.types !== null) {\n      // If we created a new types set in the inner transition, we transfer it to the parent\n      // since they should share the same set. They're conceptually entangled.\n      if (__DEV__) {\n        if (\n          prevTransition.types !== null &&\n          prevTransition.types !== currentTransition.types\n        ) {\n          // Just assert that assumption holds that we're not overriding anything.\n          console.error(\n            'We expected inner Transitions to have transferred the outer types set and ' +\n              'that you cannot add to the outer Transition while inside the inner.' +\n              'This is a bug in React.',\n          );\n        }\n      }\n      prevTransition.types = currentTransition.types;\n    }\n    ReactSharedInternals.T = prevTransition;\n  }\n}\n\nexport function startGestureTransition(\n  provider: GestureProvider,\n  scope: () => void,\n  options?: GestureOptions & StartTransitionOptions,\n): () => void {\n  if (!enableGestureTransition) {\n    // eslint-disable-next-line react-internal/prod-error-codes\n    throw new Error(\n      'startGestureTransition should not be exported when the enableGestureTransition flag is off.',\n    );\n  }\n  if (provider == null) {\n    // We enforce this at runtime even though the type also enforces it since we\n    // use null as a signal internally so it would lead it to be treated as a\n    // regular transition otherwise.\n    throw new Error(\n      'A Timeline is required as the first argument to startGestureTransition.',\n    );\n  }\n  const prevTransition = ReactSharedInternals.T;\n  const currentTransition: Transition = ({}: any);\n  if (enableViewTransition) {\n    currentTransition.types = null;\n  }\n  if (enableGestureTransition) {\n    currentTransition.gesture = provider;\n  }\n  if (enableTransitionTracing) {\n    currentTransition.name =\n      options !== undefined && options.name !== undefined ? options.name : null;\n    currentTransition.startTime = -1; // TODO: This should read the timestamp.\n  }\n  if (__DEV__) {\n    currentTransition._updatedFibers = new Set();\n  }\n  ReactSharedInternals.T = currentTransition;\n\n  try {\n    const returnValue = scope();\n    if (__DEV__) {\n      if (\n        typeof returnValue === 'object' &&\n        returnValue !== null &&\n        typeof returnValue.then === 'function'\n      ) {\n        console.error(\n          'Cannot use an async function in startGestureTransition. It must be able to start immediately.',\n        );\n      }\n    }\n    const onStartGestureTransitionFinish = ReactSharedInternals.G;\n    if (onStartGestureTransitionFinish !== null) {\n      return onStartGestureTransitionFinish(\n        currentTransition,\n        provider,\n        options,\n      );\n    }\n  } catch (error) {\n    reportGlobalError(error);\n  } finally {\n    ReactSharedInternals.T = prevTransition;\n  }\n  return noop;\n}\n\nfunction warnAboutTransitionSubscriptions(\n  prevTransition: Transition | null,\n  currentTransition: Transition,\n) {\n  if (__DEV__) {\n    if (prevTransition === null && currentTransition._updatedFibers) {\n      const updatedFibersCount = currentTransition._updatedFibers.size;\n      currentTransition._updatedFibers.clear();\n      if (updatedFibersCount > 10) {\n        console.warn(\n          'Detected a large number of updates inside startTransition. ' +\n            'If this is due to a subscription please re-write it to use React provided hooks. ' +\n            'Otherwise concurrent mode guarantees are off the table.',\n        );\n      }\n    }\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport {\n  enableViewTransition,\n  enableGestureTransition,\n} from 'shared/ReactFeatureFlags';\nimport {startTransition} from './ReactStartTransition';\n\nexport type TransitionTypes = Array<string>;\n\nexport function addTransitionType(type: string): void {\n  if (enableViewTransition) {\n    const transition = ReactSharedInternals.T;\n    if (transition !== null) {\n      const transitionTypes = transition.types;\n      if (transitionTypes === null) {\n        transition.types = [type];\n      } else if (transitionTypes.indexOf(type) === -1) {\n        transitionTypes.push(type);\n      }\n    } else {\n      // We're in the async gap. Simulate an implicit startTransition around it.\n      if (__DEV__) {\n        if (ReactSharedInternals.asyncTransitions === 0) {\n          if (enableGestureTransition) {\n            console.error(\n              'addTransitionType can only be called inside a `startTransition()` ' +\n                'or `startGestureTransition()` callback. ' +\n                'It must be associated with a specific Transition.',\n            );\n          } else {\n            console.error(\n              'addTransitionType can only be called inside a `startTransition()` ' +\n                'callback. It must be associated with a specific Transition.',\n            );\n          }\n        }\n      }\n      startTransition(addTransitionType.bind(null, type));\n    }\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport ReactVersion from 'shared/ReactVersion';\nimport {\n  REACT_FRAGMENT_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_LEGACY_HIDDEN_TYPE,\n  REACT_ACTIVITY_TYPE,\n  REACT_SCOPE_TYPE,\n  REACT_TRACING_MARKER_TYPE,\n  REACT_VIEW_TRANSITION_TYPE,\n} from 'shared/ReactSymbols';\n\nimport {Component, PureComponent} from './ReactBaseClasses';\nimport {createRef} from './ReactCreateRef';\nimport {forEach, map, count, toArray, only} from './ReactChildren';\nimport {\n  createElement,\n  cloneElement,\n  isValidElement,\n} from './jsx/ReactJSXElement';\nimport {createContext} from './ReactContext';\nimport {lazy} from './ReactLazy';\nimport {forwardRef} from './ReactForwardRef';\nimport {memo} from './ReactMemo';\nimport {cache, cacheSignal} from './ReactCacheClient';\nimport {postpone} from './ReactPostpone';\nimport {\n  getCacheForType,\n  useCallback,\n  useContext,\n  useEffect,\n  useEffectEvent,\n  useImperativeHandle,\n  useDebugValue,\n  useInsertionEffect,\n  useLayoutEffect,\n  useMemo,\n  useSyncExternalStore,\n  useReducer,\n  useRef,\n  useState,\n  useTransition,\n  useDeferredValue,\n  useId,\n  useCacheRefresh,\n  use,\n  useOptimistic,\n  useActionState,\n} from './ReactHooks';\nimport ReactSharedInternals from './ReactSharedInternalsClient';\nimport {startTransition, startGestureTransition} from './ReactStartTransition';\nimport {addTransitionType} from './ReactTransitionType';\nimport {act} from './ReactAct';\nimport {captureOwnerStack} from './ReactOwnerStack';\nimport * as ReactCompilerRuntime from './ReactCompilerRuntime';\n\nconst Children = {\n  map,\n  forEach,\n  count,\n  toArray,\n  only,\n};\n\nexport {\n  Children,\n  createRef,\n  Component,\n  PureComponent,\n  createContext,\n  forwardRef,\n  lazy,\n  memo,\n  cache,\n  cacheSignal,\n  postpone as unstable_postpone,\n  useCallback,\n  useContext,\n  useEffect,\n  useEffectEvent as experimental_useEffectEvent,\n  useImperativeHandle,\n  useDebugValue,\n  useInsertionEffect,\n  useLayoutEffect,\n  useMemo,\n  useOptimistic,\n  useActionState,\n  useSyncExternalStore,\n  useReducer,\n  useRef,\n  useState,\n  REACT_FRAGMENT_TYPE as Fragment,\n  REACT_PROFILER_TYPE as Profiler,\n  REACT_STRICT_MODE_TYPE as StrictMode,\n  REACT_SUSPENSE_TYPE as Suspense,\n  createElement,\n  cloneElement,\n  isValidElement,\n  ReactVersion as version,\n  ReactSharedInternals as __CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  ReactCompilerRuntime as __COMPILER_RUNTIME,\n  // Concurrent Mode\n  useTransition,\n  startTransition,\n  useDeferredValue,\n  REACT_SUSPENSE_LIST_TYPE as unstable_SuspenseList,\n  REACT_LEGACY_HIDDEN_TYPE as unstable_LegacyHidden,\n  REACT_ACTIVITY_TYPE as unstable_Activity,\n  getCacheForType as unstable_getCacheForType,\n  useCacheRefresh as unstable_useCacheRefresh,\n  use,\n  // enableScopeAPI\n  REACT_SCOPE_TYPE as unstable_Scope,\n  // enableTransitionTracing\n  REACT_TRACING_MARKER_TYPE as unstable_TracingMarker,\n  // enableViewTransition\n  REACT_VIEW_TRANSITION_TYPE as unstable_ViewTransition,\n  addTransitionType as unstable_addTransitionType,\n  // enableGestureTransition\n  startGestureTransition as unstable_startGestureTransition,\n  // DEV-only\n  useId,\n  act,\n  captureOwnerStack,\n};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport {\n  __CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  __COMPILER_RUNTIME,\n  Children,\n  Component,\n  Fragment,\n  Profiler,\n  PureComponent,\n  StrictMode,\n  Suspense,\n  cloneElement,\n  createContext,\n  createElement,\n  createRef,\n  use,\n  forwardRef,\n  isValidElement,\n  lazy,\n  memo,\n  cache,\n  cacheSignal,\n  startTransition,\n  unstable_Activity,\n  unstable_postpone,\n  unstable_getCacheForType,\n  unstable_SuspenseList,\n  unstable_ViewTransition,\n  unstable_startGestureTransition,\n  unstable_addTransitionType,\n  unstable_useCacheRefresh,\n  useId,\n  useCallback,\n  useContext,\n  useDebugValue,\n  useDeferredValue,\n  useEffect,\n  experimental_useEffectEvent,\n  useImperativeHandle,\n  useInsertionEffect,\n  useLayoutEffect,\n  useMemo,\n  useOptimistic,\n  useReducer,\n  useRef,\n  useState,\n  useSyncExternalStore,\n  useTransition,\n  useActionState,\n  version,\n} from './src/ReactClient';\n\nimport {useOptimistic} from './src/ReactClient';\n\nexport function experimental_useOptimistic<S, A>(\n  passthrough: S,\n  reducer: ?(S, A) => S,\n): [S, (A) => void] {\n  if (__DEV__) {\n    console.error(\n      'useOptimistic is now in canary. Remove the experimental_ prefix. ' +\n        'The prefixed alias will be removed in an upcoming release.',\n    );\n  }\n  return useOptimistic(passthrough, reducer);\n}\n"],"names":["REACT_ELEMENT_TYPE","Symbol","for","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_CONSUMER_TYPE","REACT_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_ACTIVITY_TYPE","REACT_POSTPONE_TYPE","REACT_VIEW_TRANSITION_TYPE","MAYBE_ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","ReactNoopUpdateQueue","isMounted","publicInstance","enqueueForceUpdate","callback","callerName","enqueueReplaceState","completeState","enqueueSetState","partialState","assign","Object","emptyObject","Component","props","context","updater","refs","prototype","isReactComponent","setState","Error","forceUpdate","ComponentDummy","PureComponent","pureComponentPrototype","constructor","isPureReactComponent","createRef","refObject","current","isArrayImpl","Array","isArray","a","noop","ReactSharedInternals","H","A","T","S","G","hasOwnProperty","getOwner","hasValidRef","config","ref","undefined","hasValidKey","key","ReactElement","type","self","source","owner","debugStack","debugTask","refProp","element","$$typeof","createElement","children","propName","call","childrenLength","arguments","length","childArray","i","defaultProps","cloneAndReplaceKey","oldElement","newKey","clonedElement","cloneElement","isValidElement","object","SEPARATOR","SUBSEPARATOR","escape","escapeRegex","escaperLookup","escapedString","replace","match","userProvidedKeyEscapeRegex","escapeUserProvidedKey","text","getElementKey","index","toString","resolveThenable","thenable","status","fulfilledValue","value","rejectedError","reason","then","pendingThenable","fulfilledThenable","error","rejectedThenable","mapIntoArray","array","escapedPrefix","nameSoFar","invokeCallback","payload","_payload","init","_init","child","mappedChild","childKey","escapedChildKey","c","newChild","push","nextName","subtreeCount","nextNamePrefix","iteratorFn","iterableChildren","step","ii","next","done","childrenString","String","keys","join","mapChildren","func","result","count","countChildren","n","forEachChildren","forEachFunc","forEachContext","apply","toArray","onlyChild","createContext","defaultValue","_currentValue","_currentValue2","_threadCount","Provider","Consumer","_context","Uninitialized","Pending","Resolved","Rejected","lazyInitializer","_status","ctor","_result","moduleObject","resolved","rejected","pending","default","lazy","lazyType","forwardRef","render","elementType","memo","compare","noopCache","fn","cache","noopCacheSignal","cacheSignal","postpone","postponeInstance","resolveDispatcher","dispatcher","getCacheForType","resourceType","useContext","Context","useState","initialState","useReducer","reducer","initialArg","useRef","initialValue","useEffect","create","deps","useInsertionEffect","useLayoutEffect","useCallback","useMemo","useImperativeHandle","useDebugValue","formatterFn","useTransition","useDeferredValue","useId","useSyncExternalStore","subscribe","getSnapshot","getServerSnapshot","useCacheRefresh","use","usable","useMemoCache","size","useEffectEvent","useOptimistic","passthrough","useActionState","action","permalink","reportGlobalError","reportError","window","ErrorEvent","message","event","bubbles","cancelable","shouldLog","dispatchEvent","process","emit","console","releaseAsyncTransition","startTransition","scope","options","prevTransition","currentTransition","types","gesture","returnValue","onStartTransitionFinish","__DEV__","startGestureTransition","provider","onStartGestureTransitionFinish","addTransitionType","transition","transitionTypes","indexOf","bind","Children","map","forEach","only","experimental_useOptimistic"],"mappings":"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"}
\ No newline at end of file
diff --git a/cjs/react.react-server.development.js b/cjs/react.react-server.development.js
index 0adf5aa1f2a2719cc80c4a964aa9b24fa3f223da..ec8add2b093647e19656e4543c23e1cac28af4a0 100644
--- a/cjs/react.react-server.development.js
+++ b/cjs/react.react-server.development.js
@@ -1,815 +1,1566 @@
-/**
- * @license React
- * react.react-server.development.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
+'use strict';
+
+var TaintRegistryObjects$1 = new WeakMap();
+var TaintRegistryValues$1 = new Map();
+// Byte lengths of all binary values we've ever seen. We don't both refcounting this.
+// We expect to see only a few lengths here such as the length of token.
+var TaintRegistryByteLengths$1 = new Set();
+
+// When a value is finalized, it means that it has been removed from any global caches.
+// No future requests can get a handle on it but any ongoing requests can still have
+// a handle on it. It's still tainted until that happens.
+
+var TaintRegistryPendingRequests$1 = new Set();
+
+// -----------------------------------------------------------------------------
+// Land or remove (zero effort)
+//
+// Flags that can likely be deleted or landed without consequences
+// -----------------------------------------------------------------------------
+
+var ownerStackLimit = 1e4;
+
+var ReactSharedInternals = {
+  H: null,
+  A: null
+};
+{
+  ReactSharedInternals.TaintRegistryObjects = TaintRegistryObjects$1;
+  ReactSharedInternals.TaintRegistryValues = TaintRegistryValues$1;
+  ReactSharedInternals.TaintRegistryByteLengths = TaintRegistryByteLengths$1;
+  ReactSharedInternals.TaintRegistryPendingRequests = TaintRegistryPendingRequests$1;
+}
+{
+  // Stack implementation injected by the current renderer.
+  ReactSharedInternals.getCurrentStack = null;
+  ReactSharedInternals.recentlyCreatedOwnerStacks = 0;
+}
+
+var isArrayImpl = Array.isArray;
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+function noop() {}
+
+var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+var REACT_PORTAL_TYPE = Symbol.for('react.portal');
+var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
+var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
+var REACT_CONSUMER_TYPE = Symbol.for('react.consumer');
+var REACT_CONTEXT_TYPE = Symbol.for('react.context');
+var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
+var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
+var REACT_MEMO_TYPE = Symbol.for('react.memo');
+var REACT_LAZY_TYPE = Symbol.for('react.lazy');
+var REACT_ACTIVITY_TYPE = Symbol.for('react.activity');
+var REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
+var REACT_VIEW_TRANSITION_TYPE = Symbol.for('react.view_transition');
+var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+var FAUX_ITERATOR_SYMBOL = '@@iterator';
+function getIteratorFn(maybeIterable) {
+  if (maybeIterable === null || typeof maybeIterable !== 'object') {
+    return null;
+  }
+  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
+  if (typeof maybeIterator === 'function') {
+    return maybeIterator;
+  }
+  return null;
+}
+
+/*
+ * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol
+ * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
  *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
+ * The functions in this module will throw an easier-to-understand,
+ * easier-to-debug exception with a clear errors message message explaining the
+ * problem. (Instead of a confusing exception thrown inside the implementation
+ * of the `value` object).
  */
 
-"use strict";
-"production" !== process.env.NODE_ENV &&
-  (function () {
-    function getIteratorFn(maybeIterable) {
-      if (null === maybeIterable || "object" !== typeof maybeIterable)
-        return null;
-      maybeIterable =
-        (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-        maybeIterable["@@iterator"];
-      return "function" === typeof maybeIterable ? maybeIterable : null;
-    }
-    function testStringCoercion(value) {
-      return "" + value;
-    }
-    function checkKeyStringCoercion(value) {
-      try {
-        testStringCoercion(value);
-        var JSCompiler_inline_result = !1;
-      } catch (e) {
-        JSCompiler_inline_result = !0;
-      }
-      if (JSCompiler_inline_result) {
-        JSCompiler_inline_result = console;
-        var JSCompiler_temp_const = JSCompiler_inline_result.error;
-        var JSCompiler_inline_result$jscomp$0 =
-          ("function" === typeof Symbol &&
-            Symbol.toStringTag &&
-            value[Symbol.toStringTag]) ||
-          value.constructor.name ||
-          "Object";
-        JSCompiler_temp_const.call(
-          JSCompiler_inline_result,
-          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
-          JSCompiler_inline_result$jscomp$0
-        );
-        return testStringCoercion(value);
-      }
-    }
-    function getComponentNameFromType(type) {
-      if (null == type) return null;
-      if ("function" === typeof type)
-        return type.$$typeof === REACT_CLIENT_REFERENCE
-          ? null
-          : type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
-      switch (type) {
-        case REACT_FRAGMENT_TYPE:
-          return "Fragment";
-        case REACT_PROFILER_TYPE:
-          return "Profiler";
-        case REACT_STRICT_MODE_TYPE:
-          return "StrictMode";
-        case REACT_SUSPENSE_TYPE:
-          return "Suspense";
-        case REACT_SUSPENSE_LIST_TYPE:
-          return "SuspenseList";
-        case REACT_ACTIVITY_TYPE:
-          return "Activity";
-      }
-      if ("object" === typeof type)
-        switch (
-          ("number" === typeof type.tag &&
-            console.error(
-              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
-            ),
-          type.$$typeof)
-        ) {
-          case REACT_PORTAL_TYPE:
-            return "Portal";
-          case REACT_CONTEXT_TYPE:
-            return (type.displayName || "Context") + ".Provider";
-          case REACT_CONSUMER_TYPE:
-            return (type._context.displayName || "Context") + ".Consumer";
-          case REACT_FORWARD_REF_TYPE:
-            var innerType = type.render;
-            type = type.displayName;
-            type ||
-              ((type = innerType.displayName || innerType.name || ""),
-              (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
-            return type;
-          case REACT_MEMO_TYPE:
-            return (
-              (innerType = type.displayName || null),
-              null !== innerType
-                ? innerType
-                : getComponentNameFromType(type.type) || "Memo"
-            );
-          case REACT_LAZY_TYPE:
-            innerType = type._payload;
-            type = type._init;
-            try {
-              return getComponentNameFromType(type(innerType));
-            } catch (x) {}
+// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
+function typeName(value) {
+  {
+    // toStringTag is needed for namespaced types like Temporal.Instant
+    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
+    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
+    // $FlowFixMe[incompatible-return]
+    return type;
+  }
+}
+
+// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.
+function willCoercionThrow(value) {
+  {
+    try {
+      testStringCoercion(value);
+      return false;
+    } catch (e) {
+      return true;
+    }
+  }
+}
+
+/** @noinline */
+function testStringCoercion(value) {
+  // If you ended up here by following an exception call stack, here's what's
+  // happened: you supplied an object or symbol value to React (as a prop, key,
+  // DOM attribute, CSS property, string ref, etc.) and when React tried to
+  // coerce it to a string using `'' + value`, an exception was thrown.
+  //
+  // The most common types that will cause this exception are `Symbol` instances
+  // and Temporal objects like `Temporal.Instant`. But any object that has a
+  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
+  // exception. (Library authors do this to prevent users from using built-in
+  // numeric operators like `+` or comparison operators like `>=` because custom
+  // methods are needed to perform accurate arithmetic or comparison.)
+  //
+  // To fix the problem, coerce this object or symbol value to a string before
+  // passing it to React. The most reliable way is usually `String(value)`.
+  //
+  // To find which value is throwing, check the browser or debugger console.
+  // Before this exception was thrown, there should be `console.error` output
+  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
+  // problem and how that type was used: key, atrribute, input value prop, etc.
+  // In most cases, this console output also shows the component and its
+  // ancestor components where the exception happened.
+  //
+  // eslint-disable-next-line react-internal/safe-string-coercion
+  return '' + value;
+}
+function checkKeyStringCoercion(value) {
+  {
+    if (willCoercionThrow(value)) {
+      console.error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));
+      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
+    }
+  }
+}
+
+// Keep in sync with react-reconciler/getComponentNameFromFiber
+function getWrappedName(outerType, innerType, wrapperName) {
+  var displayName = outerType.displayName;
+  if (displayName) {
+    return displayName;
+  }
+  var functionName = innerType.displayName || innerType.name || '';
+  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
+}
+
+// Keep in sync with react-reconciler/getComponentNameFromFiber
+function getContextName(type) {
+  return type.displayName || 'Context';
+}
+var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');
+
+// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
+function getComponentNameFromType(type) {
+  if (type == null) {
+    // Host root, text node or just invalid type.
+    return null;
+  }
+  if (typeof type === 'function') {
+    if (type.$$typeof === REACT_CLIENT_REFERENCE) {
+      // TODO: Create a convention for naming client references with debug info.
+      return null;
+    }
+    return type.displayName || type.name || null;
+  }
+  if (typeof type === 'string') {
+    return type;
+  }
+  switch (type) {
+    case REACT_FRAGMENT_TYPE:
+      return 'Fragment';
+    case REACT_PROFILER_TYPE:
+      return 'Profiler';
+    case REACT_STRICT_MODE_TYPE:
+      return 'StrictMode';
+    case REACT_SUSPENSE_TYPE:
+      return 'Suspense';
+    case REACT_SUSPENSE_LIST_TYPE:
+      return 'SuspenseList';
+    case REACT_ACTIVITY_TYPE:
+      return 'Activity';
+    case REACT_VIEW_TRANSITION_TYPE:
+      {
+        return 'ViewTransition';
+      }
+  }
+  if (typeof type === 'object') {
+    {
+      if (typeof type.tag === 'number') {
+        console.error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
+      }
+    }
+    switch (type.$$typeof) {
+      case REACT_PORTAL_TYPE:
+        return 'Portal';
+      case REACT_CONTEXT_TYPE:
+        var context = type;
+        return getContextName(context);
+      case REACT_CONSUMER_TYPE:
+        var consumer = type;
+        return getContextName(consumer._context) + '.Consumer';
+      case REACT_FORWARD_REF_TYPE:
+        return getWrappedName(type, type.render, 'ForwardRef');
+      case REACT_MEMO_TYPE:
+        var outerName = type.displayName || null;
+        if (outerName !== null) {
+          return outerName;
         }
+        return getComponentNameFromType(type.type) || 'Memo';
+      case REACT_LAZY_TYPE:
+        {
+          var lazyComponent = type;
+          var payload = lazyComponent._payload;
+          var init = lazyComponent._init;
+          try {
+            return getComponentNameFromType(init(payload));
+          } catch (x) {
+            return null;
+          }
+        }
+    }
+  }
+  return null;
+}
+
+// $FlowFixMe[method-unbinding]
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+
+var assign = Object.assign;
+
+var createTask =
+// eslint-disable-next-line react-internal/no-production-logging
+console.createTask ?
+// eslint-disable-next-line react-internal/no-production-logging
+console.createTask : function () {
+  return null;
+};
+function getTaskName(type) {
+  if (type === REACT_FRAGMENT_TYPE) {
+    return '<>';
+  }
+  if (typeof type === 'object' && type !== null && type.$$typeof === REACT_LAZY_TYPE) {
+    // We don't want to eagerly initialize the initializer in DEV mode so we can't
+    // call it to extract the type so we don't know the type of this component.
+    return '<...>';
+  }
+  try {
+    var name = getComponentNameFromType(type);
+    return name ? '<' + name + '>' : '<...>';
+  } catch (x) {
+    return '<...>';
+  }
+}
+function getOwner() {
+  {
+    var dispatcher = ReactSharedInternals.A;
+    if (dispatcher === null) {
       return null;
     }
-    function getTaskName(type) {
-      if (type === REACT_FRAGMENT_TYPE) return "<>";
-      if (
-        "object" === typeof type &&
-        null !== type &&
-        type.$$typeof === REACT_LAZY_TYPE
-      )
-        return "<...>";
-      try {
-        var name = getComponentNameFromType(type);
-        return name ? "<" + name + ">" : "<...>";
-      } catch (x) {
-        return "<...>";
-      }
-    }
-    function getOwner() {
-      var dispatcher = ReactSharedInternals.A;
-      return null === dispatcher ? null : dispatcher.getOwner();
-    }
-    function UnknownOwner() {
-      return Error("react-stack-top-frame");
-    }
-    function hasValidKey(config) {
-      if (hasOwnProperty.call(config, "key")) {
-        var getter = Object.getOwnPropertyDescriptor(config, "key").get;
-        if (getter && getter.isReactWarning) return !1;
-      }
-      return void 0 !== config.key;
-    }
-    function defineKeyPropWarningGetter(props, displayName) {
-      function warnAboutAccessingKey() {
-        specialPropKeyWarningShown ||
-          ((specialPropKeyWarningShown = !0),
-          console.error(
-            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
-            displayName
-          ));
-      }
-      warnAboutAccessingKey.isReactWarning = !0;
-      Object.defineProperty(props, "key", {
-        get: warnAboutAccessingKey,
-        configurable: !0
-      });
+    return dispatcher.getOwner();
+  }
+}
+
+/** @noinline */
+function UnknownOwner() {
+  /** @noinline */
+  return function () {
+    return Error('react-stack-top-frame');
+  }();
+}
+var createFakeCallStack = {
+  react_stack_bottom_frame: function (callStackForError) {
+    return callStackForError();
+  }
+};
+var specialPropKeyWarningShown;
+var didWarnAboutElementRef;
+var didWarnAboutOldJSXRuntime;
+var unknownOwnerDebugStack;
+var unknownOwnerDebugTask;
+{
+  didWarnAboutElementRef = {};
+
+  // We use this technique to trick minifiers to preserve the function name.
+  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(createFakeCallStack, UnknownOwner)();
+  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
+}
+function hasValidRef(config) {
+  {
+    if (hasOwnProperty.call(config, 'ref')) {
+      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
+      if (getter && getter.isReactWarning) {
+        return false;
+      }
+    }
+  }
+  return config.ref !== undefined;
+}
+function hasValidKey(config) {
+  {
+    if (hasOwnProperty.call(config, 'key')) {
+      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
+      if (getter && getter.isReactWarning) {
+        return false;
+      }
     }
-    function elementRefGetterWithDeprecationWarning() {
-      var componentName = getComponentNameFromType(this.type);
-      didWarnAboutElementRef[componentName] ||
-        ((didWarnAboutElementRef[componentName] = !0),
-        console.error(
-          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
-        ));
-      componentName = this.props.ref;
-      return void 0 !== componentName ? componentName : null;
-    }
-    function ReactElement(
-      type,
-      key,
-      self,
-      source,
-      owner,
-      props,
-      debugStack,
-      debugTask
-    ) {
-      self = props.ref;
-      type = {
-        $$typeof: REACT_ELEMENT_TYPE,
-        type: type,
-        key: key,
-        props: props,
-        _owner: owner
-      };
-      null !== (void 0 !== self ? self : null)
-        ? Object.defineProperty(type, "ref", {
-            enumerable: !1,
-            get: elementRefGetterWithDeprecationWarning
-          })
-        : Object.defineProperty(type, "ref", { enumerable: !1, value: null });
-      type._store = {};
-      Object.defineProperty(type._store, "validated", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: 0
+  }
+  return config.key !== undefined;
+}
+function defineKeyPropWarningGetter(props, displayName) {
+  {
+    var warnAboutAccessingKey = function () {
+      if (!specialPropKeyWarningShown) {
+        specialPropKeyWarningShown = true;
+        console.error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://react.dev/link/special-props)', displayName);
+      }
+    };
+    warnAboutAccessingKey.isReactWarning = true;
+    Object.defineProperty(props, 'key', {
+      get: warnAboutAccessingKey,
+      configurable: true
+    });
+  }
+}
+function elementRefGetterWithDeprecationWarning() {
+  {
+    var componentName = getComponentNameFromType(this.type);
+    if (!didWarnAboutElementRef[componentName]) {
+      didWarnAboutElementRef[componentName] = true;
+      console.error('Accessing element.ref was removed in React 19. ref is now a ' + 'regular prop. It will be removed from the JSX Element ' + 'type in a future release.');
+    }
+
+    // An undefined `element.ref` is coerced to `null` for
+    // backwards compatibility.
+    var refProp = this.props.ref;
+    return refProp !== undefined ? refProp : null;
+  }
+}
+
+/**
+ * Factory method to create a new React element. This no longer adheres to
+ * the class pattern, so do not use new to call it. Also, instanceof check
+ * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check
+ * if something is a React Element.
+ *
+ * @param {*} type
+ * @param {*} props
+ * @param {*} key
+ * @param {string|object} ref
+ * @param {*} owner
+ * @param {*} self A *temporary* helper to detect places where `this` is
+ * different from the `owner` when React.createElement is called, so that we
+ * can warn. We want to get rid of owner and replace string `ref`s with arrow
+ * functions, and as long as `this` and owner are the same, there will be no
+ * change in behavior.
+ * @param {*} source An annotation object (added by a transpiler or otherwise)
+ * indicating filename, line number, and/or other information.
+ * @internal
+ */
+function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
+  // Ignore whatever was passed as the ref argument and treat `props.ref` as
+  // the source of truth. The only thing we use this for is `element.ref`,
+  // which will log a deprecation warning on access. In the next release, we
+  // can remove `element.ref` as well as the `ref` argument.
+  var refProp = props.ref;
+
+  // An undefined `element.ref` is coerced to `null` for
+  // backwards compatibility.
+  var ref = refProp !== undefined ? refProp : null;
+  var element;
+  {
+    // In dev, make `ref` a non-enumerable property with a warning. It's non-
+    // enumerable so that test matchers and serializers don't access it and
+    // trigger the warning.
+    //
+    // `ref` will be removed from the element completely in a future release.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      // Built-in properties that belong on the element
+      type: type,
+      key: key,
+      props: props,
+      // Record the component responsible for creating this element.
+      _owner: owner
+    };
+    if (ref !== null) {
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
+        get: elementRefGetterWithDeprecationWarning
       });
-      Object.defineProperty(type, "_debugInfo", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
+    } else {
+      // Don't warn on access if a ref is not given. This reduces false
+      // positives in cases where a test serializer uses
+      // getOwnPropertyDescriptors to compare objects, like Jest does, which is
+      // a problem because it bypasses non-enumerability.
+      //
+      // So unfortunately this will trigger a false positive warning in Jest
+      // when the diff is printed:
+      //
+      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);
+      //
+      // A bit sketchy, but this is what we've done for the `props.key` and
+      // `props.ref` accessors for years, which implies it will be good enough
+      // for `element.ref`, too. Let's see if anyone complains.
+      Object.defineProperty(element, 'ref', {
+        enumerable: false,
         value: null
       });
-      Object.defineProperty(type, "_debugStack", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: debugStack
-      });
-      Object.defineProperty(type, "_debugTask", {
-        configurable: !1,
-        enumerable: !1,
-        writable: !0,
-        value: debugTask
-      });
-      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
-      return type;
-    }
-    function cloneAndReplaceKey(oldElement, newKey) {
-      newKey = ReactElement(
-        oldElement.type,
-        newKey,
-        void 0,
-        void 0,
-        oldElement._owner,
-        oldElement.props,
-        oldElement._debugStack,
-        oldElement._debugTask
-      );
-      oldElement._store &&
-        (newKey._store.validated = oldElement._store.validated);
-      return newKey;
-    }
-    function isValidElement(object) {
-      return (
-        "object" === typeof object &&
-        null !== object &&
-        object.$$typeof === REACT_ELEMENT_TYPE
-      );
-    }
-    function escape(key) {
-      var escaperLookup = { "=": "=0", ":": "=2" };
-      return (
-        "$" +
-        key.replace(/[=:]/g, function (match) {
-          return escaperLookup[match];
-        })
-      );
-    }
-    function getElementKey(element, index) {
-      return "object" === typeof element &&
-        null !== element &&
-        null != element.key
-        ? (checkKeyStringCoercion(element.key), escape("" + element.key))
-        : index.toString(36);
-    }
-    function noop() {}
-    function resolveThenable(thenable) {
-      switch (thenable.status) {
-        case "fulfilled":
-          return thenable.value;
-        case "rejected":
-          throw thenable.reason;
-        default:
-          switch (
-            ("string" === typeof thenable.status
-              ? thenable.then(noop, noop)
-              : ((thenable.status = "pending"),
-                thenable.then(
-                  function (fulfilledValue) {
-                    "pending" === thenable.status &&
-                      ((thenable.status = "fulfilled"),
-                      (thenable.value = fulfilledValue));
-                  },
-                  function (error) {
-                    "pending" === thenable.status &&
-                      ((thenable.status = "rejected"),
-                      (thenable.reason = error));
-                  }
-                )),
-            thenable.status)
-          ) {
-            case "fulfilled":
-              return thenable.value;
-            case "rejected":
-              throw thenable.reason;
-          }
+    }
+  }
+  {
+    // The validation flag is currently mutative. We put it on
+    // an external backing store so that we can freeze the whole object.
+    // This can be replaced with a WeakMap once they are implemented in
+    // commonly used development environments.
+    element._store = {};
+
+    // To make comparing ReactElements easier for testing purposes, we make
+    // the validation flag non-enumerable (where possible, which should
+    // include every environment we run tests in), so the test framework
+    // ignores it.
+    Object.defineProperty(element._store, 'validated', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: 0
+    });
+    // debugInfo contains Server Component debug information.
+    Object.defineProperty(element, '_debugInfo', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: null
+    });
+    Object.defineProperty(element, '_debugStack', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugStack
+    });
+    Object.defineProperty(element, '_debugTask', {
+      configurable: false,
+      enumerable: false,
+      writable: true,
+      value: debugTask
+    });
+    if (Object.freeze) {
+      Object.freeze(element.props);
+      Object.freeze(element);
+    }
+  }
+  return element;
+}
+
+/**
+ * Create and return a new ReactElement of the given type.
+ * See https://reactjs.org/docs/react-api.html#createelement
+ */
+function createElement(type, config, children) {
+  {
+    // We don't warn for invalid element type here because with owner stacks,
+    // we error in the renderer. The renderer is the only one that knows what
+    // types are valid for this particular renderer so we let it error there.
+
+    // Skip key warning if the type isn't valid since our key validation logic
+    // doesn't expect a non-string/function type and can throw confusing
+    // errors. We don't want exception behavior to differ between dev and
+    // prod. (Rendering will throw with a helpful message and as soon as the
+    // type is fixed, the key warnings will appear.)
+    for (var i = 2; i < arguments.length; i++) {
+      validateChildKeys(arguments[i]);
+    }
+
+    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.
+  }
+  var propName;
+
+  // Reserved names are extracted
+  var props = {};
+  var key = null;
+  if (config != null) {
+    {
+      if (!didWarnAboutOldJSXRuntime && '__self' in config &&
+      // Do not assume this is the result of an oudated JSX transform if key
+      // is present, because the modern JSX transform sometimes outputs
+      // createElement to preserve precedence between a static key and a
+      // spread key. To avoid false positive warnings, we never warn if
+      // there's a key.
+      !('key' in config)) {
+        didWarnAboutOldJSXRuntime = true;
+        console.warn('Your app (or one of its dependencies) is using an outdated JSX ' + 'transform. Update to the modern JSX transform for ' + 'faster performance: https://react.dev/link/new-jsx-transform');
       }
-      throw thenable;
-    }
-    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
-      var type = typeof children;
-      if ("undefined" === type || "boolean" === type) children = null;
-      var invokeCallback = !1;
-      if (null === children) invokeCallback = !0;
-      else
-        switch (type) {
-          case "bigint":
-          case "string":
-          case "number":
-            invokeCallback = !0;
-            break;
-          case "object":
-            switch (children.$$typeof) {
-              case REACT_ELEMENT_TYPE:
-              case REACT_PORTAL_TYPE:
-                invokeCallback = !0;
-                break;
-              case REACT_LAZY_TYPE:
-                return (
-                  (invokeCallback = children._init),
-                  mapIntoArray(
-                    invokeCallback(children._payload),
-                    array,
-                    escapedPrefix,
-                    nameSoFar,
-                    callback
-                  )
-                );
+    }
+    if (hasValidKey(config)) {
+      {
+        checkKeyStringCoercion(config.key);
+      }
+      key = '' + config.key;
+    }
+
+    // Remaining properties are added to a new props object
+    for (propName in config) {
+      if (hasOwnProperty.call(config, propName) &&
+      // Skip over reserved prop names
+      propName !== 'key' &&
+      // Even though we don't use these anymore in the runtime, we don't want
+      // them to appear as props, so in createElement we filter them out.
+      // We don't have to do this in the jsx() runtime because the jsx()
+      // transform never passed these as props; it used separate arguments.
+      propName !== '__self' && propName !== '__source') {
+        props[propName] = config[propName];
+      }
+    }
+  }
+
+  // Children can be more than one argument, and those are transferred onto
+  // the newly allocated props object.
+  var childrenLength = arguments.length - 2;
+  if (childrenLength === 1) {
+    props.children = children;
+  } else if (childrenLength > 1) {
+    var childArray = Array(childrenLength);
+    for (var _i = 0; _i < childrenLength; _i++) {
+      childArray[_i] = arguments[_i + 2];
+    }
+    {
+      if (Object.freeze) {
+        Object.freeze(childArray);
+      }
+    }
+    props.children = childArray;
+  }
+
+  // Resolve default props
+  if (type && type.defaultProps) {
+    var defaultProps = type.defaultProps;
+    for (propName in defaultProps) {
+      if (props[propName] === undefined) {
+        props[propName] = defaultProps[propName];
+      }
+    }
+  }
+  {
+    if (key) {
+      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
+      defineKeyPropWarningGetter(props, displayName);
+    }
+  }
+  var trackActualOwner = ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;
+  return ReactElement(type, key, undefined, undefined, getOwner(), props, (trackActualOwner ? Error('react-stack-top-frame') : unknownOwnerDebugStack), (trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask));
+}
+function cloneAndReplaceKey(oldElement, newKey) {
+  var clonedElement = ReactElement(oldElement.type, newKey, undefined, undefined, oldElement._owner, oldElement.props, oldElement._debugStack, oldElement._debugTask);
+  {
+    // The cloned element should inherit the original element's key validation.
+    if (oldElement._store) {
+      clonedElement._store.validated = oldElement._store.validated;
+    }
+  }
+  return clonedElement;
+}
+
+/**
+ * Clone and return a new ReactElement using element as the starting point.
+ * See https://reactjs.org/docs/react-api.html#cloneelement
+ */
+function cloneElement(element, config, children) {
+  if (element === null || element === undefined) {
+    throw new Error("The argument must be a React element, but you passed " + element + ".");
+  }
+  var propName;
+
+  // Original props are copied
+  var props = assign({}, element.props);
+
+  // Reserved names are extracted
+  var key = element.key;
+
+  // Owner will be preserved, unless ref is overridden
+  var owner = element._owner;
+  if (config != null) {
+    if (hasValidRef(config)) {
+      owner = getOwner() ;
+    }
+    if (hasValidKey(config)) {
+      {
+        checkKeyStringCoercion(config.key);
+      }
+      key = '' + config.key;
+    }
+
+    // Remaining properties override existing props
+    for (propName in config) {
+      if (hasOwnProperty.call(config, propName) &&
+      // Skip over reserved prop names
+      propName !== 'key' &&
+      // ...and maybe these, too, though we currently rely on them for
+      // warnings and debug information in dev. Need to decide if we're OK
+      // with dropping them. In the jsx() runtime it's not an issue because
+      // the data gets passed as separate arguments instead of props, but
+      // it would be nice to stop relying on them entirely so we can drop
+      // them from the internal Fiber field.
+      propName !== '__self' && propName !== '__source' &&
+      // Undefined `ref` is ignored by cloneElement. We treat it the same as
+      // if the property were missing. This is mostly for
+      // backwards compatibility.
+      !(propName === 'ref' && config.ref === undefined)) {
+        props[propName] = config[propName];
+      }
+    }
+  }
+
+  // Children can be more than one argument, and those are transferred onto
+  // the newly allocated props object.
+  var childrenLength = arguments.length - 2;
+  if (childrenLength === 1) {
+    props.children = children;
+  } else if (childrenLength > 1) {
+    var childArray = Array(childrenLength);
+    for (var i = 0; i < childrenLength; i++) {
+      childArray[i] = arguments[i + 2];
+    }
+    props.children = childArray;
+  }
+  var clonedElement = ReactElement(element.type, key, undefined, undefined, owner, props, element._debugStack, element._debugTask);
+  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
+    validateChildKeys(arguments[_i2]);
+  }
+  return clonedElement;
+}
+
+/**
+ * Ensure that every element either is passed in a static location, in an
+ * array with an explicit keys property defined, or in an object literal
+ * with valid key property.
+ *
+ * @internal
+ * @param {ReactNode} node Statically passed child of any type.
+ * @param {*} parentType node's parent's type.
+ */
+function validateChildKeys(node, parentType) {
+  {
+    // With owner stacks is, no warnings happens. All we do is
+    // mark elements as being in a valid static child position so they
+    // don't need keys.
+    if (isValidElement(node)) {
+      if (node._store) {
+        node._store.validated = 1;
+      }
+    }
+  }
+}
+
+/**
+ * Verifies the object is a ReactElement.
+ * See https://reactjs.org/docs/react-api.html#isvalidelement
+ * @param {?object} object
+ * @return {boolean} True if `object` is a ReactElement.
+ * @final
+ */
+function isValidElement(object) {
+  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
+}
+
+var SEPARATOR = '.';
+var SUBSEPARATOR = ':';
+
+/**
+ * Escape and wrap key so it is safe to use as a reactid
+ *
+ * @param {string} key to be escaped.
+ * @return {string} the escaped key.
+ */
+function escape(key) {
+  var escapeRegex = /[=:]/g;
+  var escaperLookup = {
+    '=': '=0',
+    ':': '=2'
+  };
+  var escapedString = key.replace(escapeRegex, function (match) {
+    // $FlowFixMe[invalid-computed-prop]
+    return escaperLookup[match];
+  });
+  return '$' + escapedString;
+}
+
+/**
+ * TODO: Test that a single child and an array with one item have the same key
+ * pattern.
+ */
+
+var didWarnAboutMaps = false;
+var userProvidedKeyEscapeRegex = /\/+/g;
+function escapeUserProvidedKey(text) {
+  return text.replace(userProvidedKeyEscapeRegex, '$&/');
+}
+
+/**
+ * Generate a key string that identifies a element within a set.
+ *
+ * @param {*} element A element that could contain a manual key.
+ * @param {number} index Index that is used if a manual key is not provided.
+ * @return {string}
+ */
+function getElementKey(element, index) {
+  // Do some typechecking here since we call this blindly. We want to ensure
+  // that we don't block potential future ES APIs.
+  if (typeof element === 'object' && element !== null && element.key != null) {
+    // Explicit key
+    {
+      checkKeyStringCoercion(element.key);
+    }
+    return escape('' + element.key);
+  }
+  // Implicit key determined by the index in the set
+  return index.toString(36);
+}
+function resolveThenable(thenable) {
+  switch (thenable.status) {
+    case 'fulfilled':
+      {
+        var fulfilledValue = thenable.value;
+        return fulfilledValue;
+      }
+    case 'rejected':
+      {
+        var rejectedError = thenable.reason;
+        throw rejectedError;
+      }
+    default:
+      {
+        if (typeof thenable.status === 'string') {
+          // Only instrument the thenable if the status if not defined. If
+          // it's defined, but an unknown value, assume it's been instrumented by
+          // some custom userspace implementation. We treat it as "pending".
+          // Attach a dummy listener, to ensure that any lazy initialization can
+          // happen. Flight lazily parses JSON when the value is actually awaited.
+          thenable.then(noop, noop);
+        } else {
+          // This is an uncached thenable that we haven't seen before.
+
+          // TODO: Detect infinite ping loops caused by uncached promises.
+
+          var pendingThenable = thenable;
+          pendingThenable.status = 'pending';
+          pendingThenable.then(function (fulfilledValue) {
+            if (thenable.status === 'pending') {
+              var fulfilledThenable = thenable;
+              fulfilledThenable.status = 'fulfilled';
+              fulfilledThenable.value = fulfilledValue;
+            }
+          }, function (error) {
+            if (thenable.status === 'pending') {
+              var rejectedThenable = thenable;
+              rejectedThenable.status = 'rejected';
+              rejectedThenable.reason = error;
+            }
+          });
+        }
+
+        // Check one more time in case the thenable resolved synchronously.
+        switch (thenable.status) {
+          case 'fulfilled':
+            {
+              var fulfilledThenable = thenable;
+              return fulfilledThenable.value;
+            }
+          case 'rejected':
+            {
+              var rejectedThenable = thenable;
+              var _rejectedError = rejectedThenable.reason;
+              throw _rejectedError;
             }
         }
-      if (invokeCallback) {
-        invokeCallback = children;
-        callback = callback(invokeCallback);
-        var childKey =
-          "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
-        isArrayImpl(callback)
-          ? ((escapedPrefix = ""),
-            null != childKey &&
-              (escapedPrefix =
-                childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
-            mapIntoArray(callback, array, escapedPrefix, "", function (c) {
-              return c;
-            }))
-          : null != callback &&
-            (isValidElement(callback) &&
-              (null != callback.key &&
-                ((invokeCallback && invokeCallback.key === callback.key) ||
-                  checkKeyStringCoercion(callback.key)),
-              (escapedPrefix = cloneAndReplaceKey(
-                callback,
-                escapedPrefix +
-                  (null == callback.key ||
-                  (invokeCallback && invokeCallback.key === callback.key)
-                    ? ""
-                    : ("" + callback.key).replace(
-                        userProvidedKeyEscapeRegex,
-                        "$&/"
-                      ) + "/") +
-                  childKey
-              )),
-              "" !== nameSoFar &&
-                null != invokeCallback &&
-                isValidElement(invokeCallback) &&
-                null == invokeCallback.key &&
-                invokeCallback._store &&
-                !invokeCallback._store.validated &&
-                (escapedPrefix._store.validated = 2),
-              (callback = escapedPrefix)),
-            array.push(callback));
-        return 1;
-      }
-      invokeCallback = 0;
-      childKey = "" === nameSoFar ? "." : nameSoFar + ":";
-      if (isArrayImpl(children))
-        for (var i = 0; i < children.length; i++)
-          (nameSoFar = children[i]),
-            (type = childKey + getElementKey(nameSoFar, i)),
-            (invokeCallback += mapIntoArray(
-              nameSoFar,
-              array,
-              escapedPrefix,
-              type,
-              callback
-            ));
-      else if (((i = getIteratorFn(children)), "function" === typeof i))
-        for (
-          i === children.entries &&
-            (didWarnAboutMaps ||
-              console.warn(
-                "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
-              ),
-            (didWarnAboutMaps = !0)),
-            children = i.call(children),
-            i = 0;
-          !(nameSoFar = children.next()).done;
-
-        )
-          (nameSoFar = nameSoFar.value),
-            (type = childKey + getElementKey(nameSoFar, i++)),
-            (invokeCallback += mapIntoArray(
-              nameSoFar,
-              array,
-              escapedPrefix,
-              type,
-              callback
-            ));
-      else if ("object" === type) {
-        if ("function" === typeof children.then)
-          return mapIntoArray(
-            resolveThenable(children),
-            array,
-            escapedPrefix,
-            nameSoFar,
-            callback
-          );
-        array = String(children);
-        throw Error(
-          "Objects are not valid as a React child (found: " +
-            ("[object Object]" === array
-              ? "object with keys {" + Object.keys(children).join(", ") + "}"
-              : array) +
-            "). If you meant to render a collection of children, use an array instead."
-        );
-      }
-      return invokeCallback;
-    }
-    function mapChildren(children, func, context) {
-      if (null == children) return children;
-      var result = [],
-        count = 0;
-      mapIntoArray(children, result, "", "", function (child) {
-        return func.call(context, child, count++);
+      }
+  }
+  throw thenable;
+}
+function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
+  var type = typeof children;
+  if (type === 'undefined' || type === 'boolean') {
+    // All of the above are perceived as null.
+    children = null;
+  }
+  var invokeCallback = false;
+  if (children === null) {
+    invokeCallback = true;
+  } else {
+    switch (type) {
+      case 'bigint':
+      case 'string':
+      case 'number':
+        invokeCallback = true;
+        break;
+      case 'object':
+        switch (children.$$typeof) {
+          case REACT_ELEMENT_TYPE:
+          case REACT_PORTAL_TYPE:
+            invokeCallback = true;
+            break;
+          case REACT_LAZY_TYPE:
+            var payload = children._payload;
+            var init = children._init;
+            return mapIntoArray(init(payload), array, escapedPrefix, nameSoFar, callback);
+        }
+    }
+  }
+  if (invokeCallback) {
+    var _child = children;
+    var mappedChild = callback(_child);
+    // If it's the only child, treat the name as if it was wrapped in an array
+    // so that it's consistent if the number of children grows:
+    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
+    if (isArray(mappedChild)) {
+      var escapedChildKey = '';
+      if (childKey != null) {
+        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
+      }
+      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
+        return c;
       });
-      return result;
+    } else if (mappedChild != null) {
+      if (isValidElement(mappedChild)) {
+        {
+          // The `if` statement here prevents auto-disabling of the safe
+          // coercion ESLint rule, so we must manually disable it below.
+          // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key
+          if (mappedChild.key != null) {
+            if (!_child || _child.key !== mappedChild.key) {
+              checkKeyStringCoercion(mappedChild.key);
+            }
+          }
+        }
+        var newChild = cloneAndReplaceKey(mappedChild,
+        // Keep both the (mapped) and old keys if they differ, just as
+        // traverseAllChildren used to do for objects as children
+        escapedPrefix + (
+        // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key
+        mappedChild.key != null && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey(
+        // $FlowFixMe[unsafe-addition]
+        '' + mappedChild.key // eslint-disable-line react-internal/safe-string-coercion
+        ) + '/' : '') + childKey);
+        {
+          // If `child` was an element without a `key`, we need to validate if
+          // it should have had a `key`, before assigning one to `mappedChild`.
+          // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key
+          if (nameSoFar !== '' && _child != null && isValidElement(_child) && _child.key == null) {
+            // We check truthiness of `child._store.validated` instead of being
+            // inequal to `1` to provide a bit of backward compatibility for any
+            // libraries (like `fbt`) which may be hacking this property.
+            if (_child._store && !_child._store.validated) {
+              // Mark this child as having failed validation, but let the actual
+              // renderer print the warning later.
+              newChild._store.validated = 2;
+            }
+          }
+        }
+        mappedChild = newChild;
+      }
+      array.push(mappedChild);
+    }
+    return 1;
+  }
+  var child;
+  var nextName;
+  var subtreeCount = 0; // Count of children found in the current subtree.
+  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
+  if (isArray(children)) {
+    for (var i = 0; i < children.length; i++) {
+      child = children[i];
+      nextName = nextNamePrefix + getElementKey(child, i);
+      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
     }
-    function resolveDispatcher() {
-      var dispatcher = ReactSharedInternals.H;
-      null === dispatcher &&
-        console.error(
-          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
-        );
-      return dispatcher;
-    }
-    function lazyInitializer(payload) {
-      if (-1 === payload._status) {
-        var ctor = payload._result;
-        ctor = ctor();
-        ctor.then(
-          function (moduleObject) {
-            if (0 === payload._status || -1 === payload._status)
-              (payload._status = 1), (payload._result = moduleObject);
-          },
-          function (error) {
-            if (0 === payload._status || -1 === payload._status)
-              (payload._status = 2), (payload._result = error);
+  } else {
+    var iteratorFn = getIteratorFn(children);
+    if (typeof iteratorFn === 'function') {
+      var iterableChildren = children;
+      {
+        // Warn about using Maps as children
+        if (iteratorFn === iterableChildren.entries) {
+          if (!didWarnAboutMaps) {
+            console.warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
           }
-        );
-        -1 === payload._status &&
-          ((payload._status = 0), (payload._result = ctor));
-      }
-      if (1 === payload._status)
-        return (
-          (ctor = payload._result),
-          void 0 === ctor &&
-            console.error(
-              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
-              ctor
-            ),
-          "default" in ctor ||
-            console.error(
-              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
-              ctor
-            ),
-          ctor.default
-        );
-      throw payload._result;
-    }
-    function createCacheRoot() {
-      return new WeakMap();
-    }
-    function createCacheNode() {
-      return { s: 0, v: void 0, o: null, p: null };
-    }
-    var ReactSharedInternals = {
-        H: null,
-        A: null,
-        getCurrentStack: null,
-        recentlyCreatedOwnerStacks: 0
-      },
-      isArrayImpl = Array.isArray,
-      REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-      REACT_PORTAL_TYPE = Symbol.for("react.portal"),
-      REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-      REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
-      REACT_PROFILER_TYPE = Symbol.for("react.profiler");
-    Symbol.for("react.provider");
-    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
-      REACT_CONTEXT_TYPE = Symbol.for("react.context"),
-      REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-      REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-      REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
-      REACT_MEMO_TYPE = Symbol.for("react.memo"),
-      REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-      REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
-      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
-      REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
-      hasOwnProperty = Object.prototype.hasOwnProperty,
-      assign = Object.assign,
-      createTask = console.createTask
-        ? console.createTask
-        : function () {
-            return null;
-          },
-      createFakeCallStack = {
-        "react-stack-bottom-frame": function (callStackForError) {
-          return callStackForError();
+          didWarnAboutMaps = true;
         }
+      }
+      var iterator = iteratorFn.call(iterableChildren);
+      var step;
+      var ii = 0;
+      // $FlowFixMe[incompatible-use] `iteratorFn` might return null according to typing.
+      while (!(step = iterator.next()).done) {
+        child = step.value;
+        nextName = nextNamePrefix + getElementKey(child, ii++);
+        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
+      }
+    } else if (type === 'object') {
+      if (typeof children.then === 'function') {
+        return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
+      }
+
+      // eslint-disable-next-line react-internal/safe-string-coercion
+      var childrenString = String(children);
+      throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
+    }
+  }
+  return subtreeCount;
+}
+
+/**
+ * Maps children that are typically specified as `props.children`.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrenmap
+ *
+ * The provided mapFunction(child, index) will be called for each
+ * leaf child.
+ *
+ * @param {?*} children Children tree container.
+ * @param {function(*, int)} func The map function.
+ * @param {*} context Context for mapFunction.
+ * @return {object} Object containing the ordered map of results.
+ */
+function mapChildren(children, func, context) {
+  if (children == null) {
+    // $FlowFixMe limitation refining abstract types in Flow
+    return children;
+  }
+  var result = [];
+  var count = 0;
+  mapIntoArray(children, result, '', '', function (child) {
+    return func.call(context, child, count++);
+  });
+  return result;
+}
+
+/**
+ * Count the number of children that are typically specified as
+ * `props.children`.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrencount
+ *
+ * @param {?*} children Children tree container.
+ * @return {number} The number of children.
+ */
+function countChildren(children) {
+  var n = 0;
+  mapChildren(children, function () {
+    n++;
+    // Don't return anything
+  });
+  return n;
+}
+
+/**
+ * Iterates through children that are typically specified as `props.children`.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
+ *
+ * The provided forEachFunc(child, index) will be called for each
+ * leaf child.
+ *
+ * @param {?*} children Children tree container.
+ * @param {function(*, int)} forEachFunc
+ * @param {*} forEachContext Context for forEachContext.
+ */
+function forEachChildren(children, forEachFunc, forEachContext) {
+  mapChildren(children,
+  // $FlowFixMe[missing-this-annot]
+  function () {
+    forEachFunc.apply(this, arguments);
+    // Don't return anything.
+  }, forEachContext);
+}
+
+/**
+ * Flatten a children object (typically specified as `props.children`) and
+ * return an array with appropriately re-keyed children.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
+ */
+function toArray(children) {
+  return mapChildren(children, function (child) {
+    return child;
+  }) || [];
+}
+
+/**
+ * Returns the first child in a collection of children and verifies that there
+ * is only one child in the collection.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrenonly
+ *
+ * The current implementation of this function assumes that a single child gets
+ * passed without a wrapper, but the purpose of this helper function is to
+ * abstract away the particular structure of children.
+ *
+ * @param {?object} children Child collection structure.
+ * @return {ReactElement} The first and only `ReactElement` contained in the
+ * structure.
+ */
+function onlyChild(children) {
+  if (!isValidElement(children)) {
+    throw new Error('React.Children.only expected to receive a single React element child.');
+  }
+  return children;
+}
+
+// an immutable object with a single mutable value
+function createRef() {
+  var refObject = {
+    current: null
+  };
+  {
+    Object.seal(refObject);
+  }
+  return refObject;
+}
+
+function resolveDispatcher() {
+  var dispatcher = ReactSharedInternals.H;
+  {
+    if (dispatcher === null) {
+      console.error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.');
+    }
+  }
+  // Will result in a null access error if accessed outside render phase. We
+  // intentionally don't throw our own error because this is in a hot path.
+  // Also helps ensure this is inlined.
+  return dispatcher;
+}
+function getCacheForType(resourceType) {
+  var dispatcher = ReactSharedInternals.A;
+  if (!dispatcher) {
+    // If there is no dispatcher, then we treat this as not being cached.
+    return resourceType();
+  }
+  return dispatcher.getCacheForType(resourceType);
+}
+function useCallback(callback, deps) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useCallback(callback, deps);
+}
+function useMemo(create, deps) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useMemo(create, deps);
+}
+function useDebugValue(value, formatterFn) {
+  {
+    var dispatcher = resolveDispatcher();
+    return dispatcher.useDebugValue(value, formatterFn);
+  }
+}
+function useId() {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.useId();
+}
+function use(usable) {
+  var dispatcher = resolveDispatcher();
+  return dispatcher.use(usable);
+}
+
+function forwardRef(render) {
+  {
+    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
+      console.error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
+    } else if (typeof render !== 'function') {
+      console.error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
+    } else {
+      if (render.length !== 0 && render.length !== 2) {
+        console.error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
+      }
+    }
+    if (render != null) {
+      if (render.defaultProps != null) {
+        console.error('forwardRef render functions do not support defaultProps. ' + 'Did you accidentally pass a React component?');
+      }
+    }
+  }
+  var elementType = {
+    $$typeof: REACT_FORWARD_REF_TYPE,
+    render: render
+  };
+  {
+    var ownName;
+    Object.defineProperty(elementType, 'displayName', {
+      enumerable: false,
+      configurable: true,
+      get: function () {
+        return ownName;
       },
-      specialPropKeyWarningShown,
-      didWarnAboutOldJSXRuntime;
-    var didWarnAboutElementRef = {};
-    var unknownOwnerDebugStack = createFakeCallStack[
-      "react-stack-bottom-frame"
-    ].bind(createFakeCallStack, UnknownOwner)();
-    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
-    var didWarnAboutMaps = !1,
-      userProvidedKeyEscapeRegex = /\/+/g;
-    exports.Children = {
-      map: mapChildren,
-      forEach: function (children, forEachFunc, forEachContext) {
-        mapChildren(
-          children,
-          function () {
-            forEachFunc.apply(this, arguments);
-          },
-          forEachContext
-        );
-      },
-      count: function (children) {
-        var n = 0;
-        mapChildren(children, function () {
-          n++;
-        });
-        return n;
-      },
-      toArray: function (children) {
-        return (
-          mapChildren(children, function (child) {
-            return child;
-          }) || []
-        );
+      set: function (name) {
+        ownName = name;
+
+        // The inner component shouldn't inherit this display name in most cases,
+        // because the component may be used elsewhere.
+        // But it's nice for anonymous functions to inherit the name,
+        // so that our component-stack generation logic will display their frames.
+        // An anonymous function generally suggests a pattern like:
+        //   React.forwardRef((props, ref) => {...});
+        // This kind of inner function is not used elsewhere so the side effect is okay.
+        if (!render.name && !render.displayName) {
+          Object.defineProperty(render, 'name', {
+            value: name
+          });
+          render.displayName = name;
+        }
+      }
+    });
+  }
+  return elementType;
+}
+
+var Uninitialized = -1;
+var Pending = 0;
+var Resolved = 1;
+var Rejected = 2;
+function lazyInitializer(payload) {
+  if (payload._status === Uninitialized) {
+    var ctor = payload._result;
+    var thenable = ctor();
+    // Transition to the next state.
+    // This might throw either because it's missing or throws. If so, we treat it
+    // as still uninitialized and try again next time. Which is the same as what
+    // happens if the ctor or any wrappers processing the ctor throws. This might
+    // end up fixing it if the resolution was a concurrency bug.
+    thenable.then(function (moduleObject) {
+      if (payload._status === Pending || payload._status === Uninitialized) {
+        // Transition to the next state.
+        var resolved = payload;
+        resolved._status = Resolved;
+        resolved._result = moduleObject;
+      }
+    }, function (error) {
+      if (payload._status === Pending || payload._status === Uninitialized) {
+        // Transition to the next state.
+        var rejected = payload;
+        rejected._status = Rejected;
+        rejected._result = error;
+      }
+    });
+    if (payload._status === Uninitialized) {
+      // In case, we're still uninitialized, then we're waiting for the thenable
+      // to resolve. Set it as pending in the meantime.
+      var pending = payload;
+      pending._status = Pending;
+      pending._result = thenable;
+    }
+  }
+  if (payload._status === Resolved) {
+    var moduleObject = payload._result;
+    {
+      if (moduleObject === undefined) {
+        console.error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' +
+        // Break up imports to avoid accidentally parsing them as dependencies.
+        'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
+      }
+    }
+    {
+      if (!('default' in moduleObject)) {
+        console.error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' +
+        // Break up imports to avoid accidentally parsing them as dependencies.
+        'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
+      }
+    }
+    return moduleObject.default;
+  } else {
+    throw payload._result;
+  }
+}
+function lazy(ctor) {
+  var payload = {
+    // We use these fields to store the result.
+    _status: Uninitialized,
+    _result: ctor
+  };
+  var lazyType = {
+    $$typeof: REACT_LAZY_TYPE,
+    _payload: payload,
+    _init: lazyInitializer
+  };
+  return lazyType;
+}
+
+function memo(type, compare) {
+  {
+    if (type == null) {
+      console.error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
+    }
+  }
+  var elementType = {
+    $$typeof: REACT_MEMO_TYPE,
+    type: type,
+    compare: compare === undefined ? null : compare
+  };
+  {
+    var ownName;
+    Object.defineProperty(elementType, 'displayName', {
+      enumerable: false,
+      configurable: true,
+      get: function () {
+        return ownName;
       },
-      only: function (children) {
-        if (!isValidElement(children))
-          throw Error(
-            "React.Children.only expected to receive a single React element child."
-          );
-        return children;
+      set: function (name) {
+        ownName = name;
+
+        // The inner component shouldn't inherit this display name in most cases,
+        // because the component may be used elsewhere.
+        // But it's nice for anonymous functions to inherit the name,
+        // so that our component-stack generation logic will display their frames.
+        // An anonymous function generally suggests a pattern like:
+        //   React.memo((props) => {...});
+        // This kind of inner function is not used elsewhere so the side effect is okay.
+        if (!type.name && !type.displayName) {
+          Object.defineProperty(type, 'name', {
+            value: name
+          });
+          type.displayName = name;
+        }
       }
-    };
-    exports.Fragment = REACT_FRAGMENT_TYPE;
-    exports.Profiler = REACT_PROFILER_TYPE;
-    exports.StrictMode = REACT_STRICT_MODE_TYPE;
-    exports.Suspense = REACT_SUSPENSE_TYPE;
-    exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
-      ReactSharedInternals;
-    exports.cache = function (fn) {
-      return function () {
-        var dispatcher = ReactSharedInternals.A;
-        if (!dispatcher) return fn.apply(null, arguments);
-        var fnMap = dispatcher.getCacheForType(createCacheRoot);
-        dispatcher = fnMap.get(fn);
-        void 0 === dispatcher &&
-          ((dispatcher = createCacheNode()), fnMap.set(fn, dispatcher));
-        fnMap = 0;
-        for (var l = arguments.length; fnMap < l; fnMap++) {
-          var arg = arguments[fnMap];
-          if (
-            "function" === typeof arg ||
-            ("object" === typeof arg && null !== arg)
-          ) {
-            var objectCache = dispatcher.o;
-            null === objectCache &&
-              (dispatcher.o = objectCache = new WeakMap());
-            dispatcher = objectCache.get(arg);
-            void 0 === dispatcher &&
-              ((dispatcher = createCacheNode()),
-              objectCache.set(arg, dispatcher));
-          } else
-            (objectCache = dispatcher.p),
-              null === objectCache && (dispatcher.p = objectCache = new Map()),
-              (dispatcher = objectCache.get(arg)),
-              void 0 === dispatcher &&
-                ((dispatcher = createCacheNode()),
-                objectCache.set(arg, dispatcher));
+    });
+  }
+  return elementType;
+}
+
+var UNTERMINATED = 0;
+var TERMINATED = 1;
+var ERRORED = 2;
+function createCacheRoot() {
+  return new WeakMap();
+}
+function createCacheNode() {
+  return {
+    s: UNTERMINATED,
+    // status, represents whether the cached computation returned a value or threw an error
+    v: undefined,
+    // value, either the cached result or an error, depending on s
+    o: null,
+    // object cache, a WeakMap where non-primitive arguments are stored
+    p: null // primitive cache, a regular Map where primitive arguments are stored.
+  };
+}
+function cache(fn) {
+  return function () {
+    var dispatcher = ReactSharedInternals.A;
+    if (!dispatcher) {
+      // If there is no dispatcher, then we treat this as not being cached.
+      // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.
+      return fn.apply(null, arguments);
+    }
+    var fnMap = dispatcher.getCacheForType(createCacheRoot);
+    var fnNode = fnMap.get(fn);
+    var cacheNode;
+    if (fnNode === undefined) {
+      cacheNode = createCacheNode();
+      fnMap.set(fn, cacheNode);
+    } else {
+      cacheNode = fnNode;
+    }
+    for (var i = 0, l = arguments.length; i < l; i++) {
+      var arg = arguments[i];
+      if (typeof arg === 'function' || typeof arg === 'object' && arg !== null) {
+        // Objects go into a WeakMap
+        var objectCache = cacheNode.o;
+        if (objectCache === null) {
+          cacheNode.o = objectCache = new WeakMap();
         }
-        if (1 === dispatcher.s) return dispatcher.v;
-        if (2 === dispatcher.s) throw dispatcher.v;
-        try {
-          var result = fn.apply(null, arguments);
-          fnMap = dispatcher;
-          fnMap.s = 1;
-          return (fnMap.v = result);
-        } catch (error) {
-          throw (
-            ((result = dispatcher), (result.s = 2), (result.v = error), error)
-          );
+        var objectNode = objectCache.get(arg);
+        if (objectNode === undefined) {
+          cacheNode = createCacheNode();
+          objectCache.set(arg, cacheNode);
+        } else {
+          cacheNode = objectNode;
         }
-      };
-    };
-    exports.captureOwnerStack = function () {
-      var getCurrentStack = ReactSharedInternals.getCurrentStack;
-      return null === getCurrentStack ? null : getCurrentStack();
-    };
-    exports.cloneElement = function (element, config, children) {
-      if (null === element || void 0 === element)
-        throw Error(
-          "The argument must be a React element, but you passed " +
-            element +
-            "."
-        );
-      var props = assign({}, element.props),
-        key = element.key,
-        owner = element._owner;
-      if (null != config) {
-        var JSCompiler_inline_result;
-        a: {
-          if (
-            hasOwnProperty.call(config, "ref") &&
-            (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
-              config,
-              "ref"
-            ).get) &&
-            JSCompiler_inline_result.isReactWarning
-          ) {
-            JSCompiler_inline_result = !1;
-            break a;
-          }
-          JSCompiler_inline_result = void 0 !== config.ref;
+      } else {
+        // Primitives go into a regular Map
+        var primitiveCache = cacheNode.p;
+        if (primitiveCache === null) {
+          cacheNode.p = primitiveCache = new Map();
         }
-        JSCompiler_inline_result && (owner = getOwner());
-        hasValidKey(config) &&
-          (checkKeyStringCoercion(config.key), (key = "" + config.key));
-        for (propName in config)
-          !hasOwnProperty.call(config, propName) ||
-            "key" === propName ||
-            "__self" === propName ||
-            "__source" === propName ||
-            ("ref" === propName && void 0 === config.ref) ||
-            (props[propName] = config[propName]);
-      }
-      var propName = arguments.length - 2;
-      if (1 === propName) props.children = children;
-      else if (1 < propName) {
-        JSCompiler_inline_result = Array(propName);
-        for (var i = 0; i < propName; i++)
-          JSCompiler_inline_result[i] = arguments[i + 2];
-        props.children = JSCompiler_inline_result;
-      }
-      props = ReactElement(
-        element.type,
-        key,
-        void 0,
-        void 0,
-        owner,
-        props,
-        element._debugStack,
-        element._debugTask
-      );
-      for (key = 2; key < arguments.length; key++)
-        (owner = arguments[key]),
-          isValidElement(owner) && owner._store && (owner._store.validated = 1);
-      return props;
-    };
-    exports.createElement = function (type, config, children) {
-      for (var i = 2; i < arguments.length; i++) {
-        var node = arguments[i];
-        isValidElement(node) && node._store && (node._store.validated = 1);
-      }
-      i = {};
-      node = null;
-      if (null != config)
-        for (propName in (didWarnAboutOldJSXRuntime ||
-          !("__self" in config) ||
-          "key" in config ||
-          ((didWarnAboutOldJSXRuntime = !0),
-          console.warn(
-            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
-          )),
-        hasValidKey(config) &&
-          (checkKeyStringCoercion(config.key), (node = "" + config.key)),
-        config))
-          hasOwnProperty.call(config, propName) &&
-            "key" !== propName &&
-            "__self" !== propName &&
-            "__source" !== propName &&
-            (i[propName] = config[propName]);
-      var childrenLength = arguments.length - 2;
-      if (1 === childrenLength) i.children = children;
-      else if (1 < childrenLength) {
-        for (
-          var childArray = Array(childrenLength), _i = 0;
-          _i < childrenLength;
-          _i++
-        )
-          childArray[_i] = arguments[_i + 2];
-        Object.freeze && Object.freeze(childArray);
-        i.children = childArray;
-      }
-      if (type && type.defaultProps)
-        for (propName in ((childrenLength = type.defaultProps), childrenLength))
-          void 0 === i[propName] && (i[propName] = childrenLength[propName]);
-      node &&
-        defineKeyPropWarningGetter(
-          i,
-          "function" === typeof type
-            ? type.displayName || type.name || "Unknown"
-            : type
-        );
-      var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
-      return ReactElement(
-        type,
-        node,
-        void 0,
-        void 0,
-        getOwner(),
-        i,
-        propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
-        propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
-      );
-    };
-    exports.createRef = function () {
-      var refObject = { current: null };
-      Object.seal(refObject);
-      return refObject;
-    };
-    exports.forwardRef = function (render) {
-      null != render && render.$$typeof === REACT_MEMO_TYPE
-        ? console.error(
-            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
-          )
-        : "function" !== typeof render
-          ? console.error(
-              "forwardRef requires a render function but was given %s.",
-              null === render ? "null" : typeof render
-            )
-          : 0 !== render.length &&
-            2 !== render.length &&
-            console.error(
-              "forwardRef render functions accept exactly two parameters: props and ref. %s",
-              1 === render.length
-                ? "Did you forget to use the ref parameter?"
-                : "Any additional parameter will be undefined."
-            );
-      null != render &&
-        null != render.defaultProps &&
-        console.error(
-          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
-        );
-      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render: render },
-        ownName;
-      Object.defineProperty(elementType, "displayName", {
-        enumerable: !1,
-        configurable: !0,
-        get: function () {
-          return ownName;
-        },
-        set: function (name) {
-          ownName = name;
-          render.name ||
-            render.displayName ||
-            (Object.defineProperty(render, "name", { value: name }),
-            (render.displayName = name));
+        var primitiveNode = primitiveCache.get(arg);
+        if (primitiveNode === undefined) {
+          cacheNode = createCacheNode();
+          primitiveCache.set(arg, cacheNode);
+        } else {
+          cacheNode = primitiveNode;
         }
-      });
-      return elementType;
-    };
-    exports.isValidElement = isValidElement;
-    exports.lazy = function (ctor) {
-      return {
-        $$typeof: REACT_LAZY_TYPE,
-        _payload: { _status: -1, _result: ctor },
-        _init: lazyInitializer
-      };
-    };
-    exports.memo = function (type, compare) {
-      null == type &&
-        console.error(
-          "memo: The first argument must be a component. Instead received: %s",
-          null === type ? "null" : typeof type
-        );
-      compare = {
-        $$typeof: REACT_MEMO_TYPE,
-        type: type,
-        compare: void 0 === compare ? null : compare
-      };
-      var ownName;
-      Object.defineProperty(compare, "displayName", {
-        enumerable: !1,
-        configurable: !0,
-        get: function () {
-          return ownName;
-        },
-        set: function (name) {
-          ownName = name;
-          type.name ||
-            type.displayName ||
-            (Object.defineProperty(type, "name", { value: name }),
-            (type.displayName = name));
+      }
+    }
+    if (cacheNode.s === TERMINATED) {
+      return cacheNode.v;
+    }
+    if (cacheNode.s === ERRORED) {
+      throw cacheNode.v;
+    }
+    try {
+      // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.
+      var result = fn.apply(null, arguments);
+      var terminatedNode = cacheNode;
+      terminatedNode.s = TERMINATED;
+      terminatedNode.v = result;
+      return result;
+    } catch (error) {
+      // We store the first error that's thrown and rethrow it.
+      var erroredNode = cacheNode;
+      erroredNode.s = ERRORED;
+      erroredNode.v = error;
+      throw error;
+    }
+  };
+}
+function cacheSignal() {
+  var dispatcher = ReactSharedInternals.A;
+  if (!dispatcher) {
+    // If there is no dispatcher, then we treat this as not having an AbortSignal
+    // since in the same context, a cached function will be allowed to be called
+    // but it won't be cached. So it's neither an infinite AbortSignal nor an
+    // already resolved one.
+    return null;
+  }
+  return dispatcher.cacheSignal();
+}
+
+var reportGlobalError = typeof reportError === 'function' ?
+// In modern browsers, reportError will dispatch an error event,
+// emulating an uncaught JavaScript error.
+reportError : function (error) {
+  if (typeof window === 'object' && typeof window.ErrorEvent === 'function') {
+    // Browser Polyfill
+    var message = typeof error === 'object' && error !== null && typeof error.message === 'string' ?
+    // eslint-disable-next-line react-internal/safe-string-coercion
+    String(error.message) :
+    // eslint-disable-next-line react-internal/safe-string-coercion
+    String(error);
+    var event = new window.ErrorEvent('error', {
+      bubbles: true,
+      cancelable: true,
+      message: message,
+      error: error
+    });
+    var shouldLog = window.dispatchEvent(event);
+    if (!shouldLog) {
+      return;
+    }
+  } else if (typeof process === 'object' &&
+  // $FlowFixMe[method-unbinding]
+  typeof process.emit === 'function') {
+    // Node Polyfill
+    process.emit('uncaughtException', error);
+    return;
+  }
+  console['error'](error);
+};
+
+function releaseAsyncTransition() {
+  {
+    ReactSharedInternals.asyncTransitions--;
+  }
+}
+function startTransition(scope, options) {
+  var prevTransition = ReactSharedInternals.T;
+  var currentTransition = {};
+  {
+    currentTransition.types = prevTransition !== null ?
+    // If we're a nested transition, we should use the same set as the parent
+    // since we're conceptually always joined into the same entangled transition.
+    // In practice, this only matters if we add transition types in the inner
+    // without setting state. In that case, the inner transition can finish
+    // without waiting for the outer.
+    prevTransition.types : null;
+  }
+  {
+    currentTransition.gesture = null;
+  }
+  {
+    currentTransition._updatedFibers = new Set();
+  }
+  ReactSharedInternals.T = currentTransition;
+  try {
+    var returnValue = scope();
+    var onStartTransitionFinish = ReactSharedInternals.S;
+    if (onStartTransitionFinish !== null) {
+      onStartTransitionFinish(currentTransition, returnValue);
+    }
+    if (typeof returnValue === 'object' && returnValue !== null && typeof returnValue.then === 'function') {
+      if (true) {
+        // Keep track of the number of async transitions still running so we can warn.
+        ReactSharedInternals.asyncTransitions++;
+        returnValue.then(releaseAsyncTransition, releaseAsyncTransition);
+      }
+      returnValue.then(noop, reportGlobalError);
+    }
+  } catch (error) {
+    reportGlobalError(error);
+  } finally {
+    warnAboutTransitionSubscriptions(prevTransition, currentTransition);
+    if (prevTransition !== null && currentTransition.types !== null) {
+      // If we created a new types set in the inner transition, we transfer it to the parent
+      // since they should share the same set. They're conceptually entangled.
+      {
+        if (prevTransition.types !== null && prevTransition.types !== currentTransition.types) {
+          // Just assert that assumption holds that we're not overriding anything.
+          console.error('We expected inner Transitions to have transferred the outer types set and ' + 'that you cannot add to the outer Transition while inside the inner.' + 'This is a bug in React.');
         }
-      });
-      return compare;
-    };
-    exports.use = function (usable) {
-      return resolveDispatcher().use(usable);
-    };
-    exports.useCallback = function (callback, deps) {
-      return resolveDispatcher().useCallback(callback, deps);
-    };
-    exports.useDebugValue = function (value, formatterFn) {
-      return resolveDispatcher().useDebugValue(value, formatterFn);
-    };
-    exports.useId = function () {
-      return resolveDispatcher().useId();
-    };
-    exports.useMemo = function (create, deps) {
-      return resolveDispatcher().useMemo(create, deps);
-    };
-    exports.version = "19.1.0";
-  })();
+      }
+      prevTransition.types = currentTransition.types;
+    }
+    ReactSharedInternals.T = prevTransition;
+  }
+}
+function warnAboutTransitionSubscriptions(prevTransition, currentTransition) {
+  {
+    if (prevTransition === null && currentTransition._updatedFibers) {
+      var updatedFibersCount = currentTransition._updatedFibers.size;
+      currentTransition._updatedFibers.clear();
+      if (updatedFibersCount > 10) {
+        console.warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
+      }
+    }
+  }
+}
+
+function postpone(reason) {
+  // eslint-disable-next-line react-internal/prod-error-codes
+  var postponeInstance = new Error(reason);
+  postponeInstance.$$typeof = REACT_POSTPONE_TYPE;
+  throw postponeInstance;
+}
+
+function captureOwnerStack() {
+  {
+    var getCurrentStack = ReactSharedInternals.getCurrentStack;
+    if (getCurrentStack === null) {
+      return null;
+    }
+    // The current stack will be the owner stack which it is always here.
+    return getCurrentStack();
+  }
+}
+
+var ReactVersion = '19.2.0-experimental-602917c8-20250701';
+
+var getPrototypeOf = Object.getPrototypeOf;
+
+// Turns a TypedArray or ArrayBuffer into a string that can be used for comparison
+// in a Map to see if the bytes are the same.
+function binaryToComparableString(view) {
+  return String.fromCharCode.apply(String, new Uint8Array(view.buffer, view.byteOffset, view.byteLength));
+}
+
+var TaintRegistryObjects = ReactSharedInternals.TaintRegistryObjects,
+  TaintRegistryValues = ReactSharedInternals.TaintRegistryValues,
+  TaintRegistryByteLengths = ReactSharedInternals.TaintRegistryByteLengths,
+  TaintRegistryPendingRequests = ReactSharedInternals.TaintRegistryPendingRequests; // This is the shared constructor of all typed arrays.
+var TypedArrayConstructor = getPrototypeOf(Uint32Array.prototype).constructor;
+var defaultMessage = 'A tainted value was attempted to be serialized to a Client Component or Action closure. ' + 'This would leak it to the client.';
+function cleanup(entryValue) {
+  var entry = TaintRegistryValues.get(entryValue);
+  if (entry !== undefined) {
+    TaintRegistryPendingRequests.forEach(function (requestQueue) {
+      requestQueue.push(entryValue);
+      entry.count++;
+    });
+    if (entry.count === 1) {
+      TaintRegistryValues.delete(entryValue);
+    } else {
+      entry.count--;
+    }
+  }
+}
+
+// If FinalizationRegistry doesn't exist, we assume that objects life forever.
+// E.g. the whole VM is just the lifetime of a request.
+var finalizationRegistry = typeof FinalizationRegistry === 'function' ? new FinalizationRegistry(cleanup) : null;
+function taintUniqueValue(message, lifetime, value) {
+  // eslint-disable-next-line react-internal/safe-string-coercion
+  message = '' + (message || defaultMessage);
+  if (lifetime === null || typeof lifetime !== 'object' && typeof lifetime !== 'function') {
+    throw new Error('To taint a value, a lifetime must be defined by passing an object that holds ' + 'the value.');
+  }
+  var entryValue;
+  if (typeof value === 'string' || typeof value === 'bigint') {
+    // Use as is.
+    entryValue = value;
+  } else if (value instanceof TypedArrayConstructor || value instanceof DataView) {
+    // For now, we just convert binary data to a string so that we can just use the native
+    // hashing in the Map implementation. It doesn't really matter what form the string
+    // take as long as it's the same when we look it up.
+    // We're not too worried about collisions since this should be a high entropy value.
+    TaintRegistryByteLengths.add(value.byteLength);
+    entryValue = binaryToComparableString(value);
+  } else {
+    var kind = value === null ? 'null' : typeof value;
+    if (kind === 'object' || kind === 'function') {
+      throw new Error('taintUniqueValue cannot taint objects or functions. Try taintObjectReference instead.');
+    }
+    throw new Error('Cannot taint a ' + kind + ' because the value is too general and not unique enough to block globally.');
+  }
+  var existingEntry = TaintRegistryValues.get(entryValue);
+  if (existingEntry === undefined) {
+    TaintRegistryValues.set(entryValue, {
+      message: message,
+      count: 1
+    });
+  } else {
+    existingEntry.count++;
+  }
+  if (finalizationRegistry !== null) {
+    finalizationRegistry.register(lifetime, entryValue);
+  }
+}
+function taintObjectReference(message, object) {
+  // eslint-disable-next-line react-internal/safe-string-coercion
+  message = '' + (message || defaultMessage);
+  if (typeof object === 'string' || typeof object === 'bigint') {
+    throw new Error('Only objects or functions can be passed to taintObjectReference. Try taintUniqueValue instead.');
+  }
+  if (object === null || typeof object !== 'object' && typeof object !== 'function') {
+    throw new Error('Only objects or functions can be passed to taintObjectReference.');
+  }
+  TaintRegistryObjects.set(object, message);
+}
+
+var Children = {
+  map: mapChildren,
+  forEach: forEachChildren,
+  count: countChildren,
+  toArray: toArray,
+  only: onlyChild
+};
+
+exports.Children = Children;
+exports.Fragment = REACT_FRAGMENT_TYPE;
+exports.Profiler = REACT_PROFILER_TYPE;
+exports.StrictMode = REACT_STRICT_MODE_TYPE;
+exports.Suspense = REACT_SUSPENSE_TYPE;
+exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
+exports.cache = cache;
+exports.cacheSignal = cacheSignal;
+exports.captureOwnerStack = captureOwnerStack;
+exports.cloneElement = cloneElement;
+exports.createElement = createElement;
+exports.createRef = createRef;
+exports.experimental_taintObjectReference = taintObjectReference;
+exports.experimental_taintUniqueValue = taintUniqueValue;
+exports.forwardRef = forwardRef;
+exports.isValidElement = isValidElement;
+exports.lazy = lazy;
+exports.memo = memo;
+exports.startTransition = startTransition;
+exports.unstable_SuspenseList = REACT_SUSPENSE_LIST_TYPE;
+exports.unstable_ViewTransition = REACT_VIEW_TRANSITION_TYPE;
+exports.unstable_getCacheForType = getCacheForType;
+exports.unstable_postpone = postpone;
+exports.use = use;
+exports.useCallback = useCallback;
+exports.useDebugValue = useDebugValue;
+exports.useId = useId;
+exports.useMemo = useMemo;
+exports.version = ReactVersion;
+//# sourceMappingURL=react.react-server.development.js.map
diff --git a/cjs/react.react-server.development.js.map b/cjs/react.react-server.development.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..bc442870eeeb50f3b372d8f31cfdb0ce42fba64e
--- /dev/null
+++ b/cjs/react.react-server.development.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react.react-server.development.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactTaintRegistry.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactFeatureFlags.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactSharedInternalsServer.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/isArray.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/noop.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/CheckStringCoercion.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/getComponentNameFromType.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/hasOwnProperty.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/assign.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXElement.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactChildren.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactCreateRef.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactHooks.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactForwardRef.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactLazy.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactMemo.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactCacheImpl.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/reportGlobalError.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactStartTransition.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactPostpone.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactOwnerStack.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactVersion.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/getPrototypeOf.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/binaryToComparableString.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactTaint.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactServer.experimental.development.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport interface Reference {}\n\nexport type TaintEntry = {\n  message: string,\n  count: number,\n};\n\nexport const TaintRegistryObjects: WeakMap<Reference, string> = new WeakMap();\nexport const TaintRegistryValues: Map<string | bigint, TaintEntry> = new Map();\n// Byte lengths of all binary values we've ever seen. We don't both refcounting this.\n// We expect to see only a few lengths here such as the length of token.\nexport const TaintRegistryByteLengths: Set<number> = new Set();\n\n// When a value is finalized, it means that it has been removed from any global caches.\n// No future requests can get a handle on it but any ongoing requests can still have\n// a handle on it. It's still tainted until that happens.\nexport type RequestCleanupQueue = Array<string | bigint>;\nexport const TaintRegistryPendingRequests: Set<RequestCleanupQueue> = new Set();\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n */\n\n// -----------------------------------------------------------------------------\n// Land or remove (zero effort)\n//\n// Flags that can likely be deleted or landed without consequences\n// -----------------------------------------------------------------------------\n\n// None\n\n// -----------------------------------------------------------------------------\n// Killswitch\n//\n// Flags that exist solely to turn off a change in case it causes a regression\n// when it rolls out to prod. We should remove these as soon as possible.\n// -----------------------------------------------------------------------------\n\nexport const enableHydrationLaneScheduling = true;\n\n// -----------------------------------------------------------------------------\n// Land or remove (moderate effort)\n//\n// Flags that can be probably deleted or landed, but might require extra effort\n// like migrating internal callers or performance testing.\n// -----------------------------------------------------------------------------\n\n// TODO: Finish rolling out in www\nexport const favorSafetyOverHydrationPerf = true;\n\n// Need to remove didTimeout argument from Scheduler before landing\nexport const disableSchedulerTimeoutInWorkLoop = false;\n\n// -----------------------------------------------------------------------------\n// Slated for removal in the future (significant effort)\n//\n// These are experiments that didn't work out, and never shipped, but we can't\n// delete from the codebase until we migrate internal callers.\n// -----------------------------------------------------------------------------\n\n// Add a callback property to suspense to notify which promises are currently\n// in the update queue. This allows reporting and tracing of what is causing\n// the user to see a loading state.\n//\n// Also allows hydration callbacks to fire when a dehydrated boundary gets\n// hydrated or deleted.\n//\n// This will eventually be replaced by the Transition Tracing proposal.\nexport const enableSuspenseCallback = false;\n\n// Experimental Scope support.\nexport const enableScopeAPI = false;\n\n// Experimental Create Event Handle API.\nexport const enableCreateEventHandleAPI = false;\n\n// Support legacy Primer support on internal FB www\nexport const enableLegacyFBSupport = false;\n\n// -----------------------------------------------------------------------------\n// Ongoing experiments\n//\n// These are features that we're either actively exploring or are reasonably\n// likely to include in an upcoming release.\n// -----------------------------------------------------------------------------\n\n// Yield to the browser event loop and not just the scheduler event loop before passive effects.\n// Fix gated tests that fail with this flag enabled before turning it back on.\nexport const enableYieldingBeforePassive = false;\n\n// Experiment to intentionally yield less to block high framerate animations.\nexport const enableThrottledScheduling = false;\n\nexport const enableLegacyCache = __EXPERIMENTAL__;\n\nexport const enableAsyncIterableChildren = __EXPERIMENTAL__;\n\nexport const enableTaint = __EXPERIMENTAL__;\n\nexport const enablePostpone = __EXPERIMENTAL__;\n\nexport const enableHalt = __EXPERIMENTAL__;\n\nexport const enableViewTransition = __EXPERIMENTAL__;\n\nexport const enableGestureTransition = __EXPERIMENTAL__;\n\nexport const enableScrollEndPolyfill = __EXPERIMENTAL__;\n\nexport const enableSuspenseyImages = false;\n\nexport const enableFizzBlockingRender = __EXPERIMENTAL__; // rel=\"expect\"\n\nexport const enableSrcObject = __EXPERIMENTAL__;\n\nexport const enableHydrationChangeEvent = __EXPERIMENTAL__;\n\nexport const enableDefaultTransitionIndicator = __EXPERIMENTAL__;\n\n/**\n * Switches Fiber creation to a simple object instead of a constructor.\n */\nexport const enableObjectFiber = false;\n\nexport const enableTransitionTracing = false;\n\n// FB-only usage. The new API has different semantics.\nexport const enableLegacyHidden = false;\n\n// Enables unstable_avoidThisFallback feature in Fiber\nexport const enableSuspenseAvoidThisFallback = false;\n\nexport const enableCPUSuspense = __EXPERIMENTAL__;\n\n// Test this at Meta before enabling.\nexport const enableNoCloningMemoCache = false;\n\nexport const enableUseEffectEventHook = __EXPERIMENTAL__;\n\n// Test in www before enabling in open source.\n// Enables DOM-server to stream its instruction set as data-attributes\n// (handled with an MutationObserver) instead of inline-scripts\nexport const enableFizzExternalRuntime = __EXPERIMENTAL__;\n\nexport const alwaysThrottleRetries = true;\n\nexport const passChildrenWhenCloningPersistedNodes = false;\n\n/**\n * Enables a new Fiber flag used in persisted mode to reduce the number\n * of cloned host components.\n */\nexport const enablePersistedModeClonedFlag = false;\n\nexport const enableEagerAlternateStateNodeCleanup = true;\n\n/**\n * Enables an expiration time for retry lanes to avoid starvation.\n */\nexport const enableRetryLaneExpiration = false;\nexport const retryLaneExpirationMs = 5000;\nexport const syncLaneExpirationMs = 250;\nexport const transitionLaneExpirationMs = 5000;\n\n/**\n * Enables a new error detection for infinite render loops from updates caused\n * by setState or similar outside of the component owning the state.\n */\nexport const enableInfiniteRenderLoopDetection = false;\n\nexport const enableLazyPublicInstanceInFabric = false;\n\nexport const enableFragmentRefs = __EXPERIMENTAL__;\n\n// -----------------------------------------------------------------------------\n// Ready for next major.\n//\n// Alias __NEXT_MAJOR__ to __EXPERIMENTAL__ for easier skimming.\n// -----------------------------------------------------------------------------\n\n// TODO: Anything that's set to `true` in this section should either be cleaned\n// up (if it's on everywhere, including Meta and RN builds) or moved to a\n// different section of this file.\n\n// const __NEXT_MAJOR__ = __EXPERIMENTAL__;\n\n// Renames the internal symbol for elements since they have changed signature/constructor\nexport const renameElementSymbol = true;\n\n/**\n * Enables a fix to run insertion effect cleanup on hidden subtrees.\n */\nexport const enableHiddenSubtreeInsertionEffectCleanup = false;\n\n/**\n * Removes legacy style context defined using static `contextTypes` and consumed with static `childContextTypes`.\n */\nexport const disableLegacyContext = true;\n/**\n * Removes legacy style context just from function components.\n */\nexport const disableLegacyContextForFunctionComponents = true;\n\n// Enable the moveBefore() alternative to insertBefore(). This preserves states of moves.\nexport const enableMoveBefore = false;\n\n// Disabled caching behavior of `react/cache` in client runtimes.\nexport const disableClientCache = true;\n\n// Warn on any usage of ReactTestRenderer\nexport const enableReactTestRendererWarning = true;\n\n// Disables legacy mode\n// This allows us to land breaking changes to remove legacy mode APIs in experimental builds\n// before removing them in stable in the next Major\nexport const disableLegacyMode = true;\n\n// -----------------------------------------------------------------------------\n// Chopping Block\n//\n// Planned feature deprecations and breaking changes. Sorted roughly in order of\n// when we plan to enable them.\n// -----------------------------------------------------------------------------\n\n// -----------------------------------------------------------------------------\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nexport const disableCommentsAsDOMContainers = true;\n\nexport const enableTrustedTypesIntegration = false;\n\n// Prevent the value and checked attributes from syncing with their related\n// DOM properties\nexport const disableInputAttributeSyncing = false;\n\n// Disables children for <textarea> elements\nexport const disableTextareaChildren = false;\n\n// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n\n// Gather advanced timing metrics for Profiler subtrees.\nexport const enableProfilerTimer = __PROFILE__;\n\n// Adds performance.measure() marks using Chrome extensions to allow formatted\n// Component rendering tracks to show up in the Performance tab.\n// This flag will be used for both Server Component and Client Component tracks.\n// All calls should also be gated on enableProfilerTimer.\nexport const enableComponentPerformanceTrack = __EXPERIMENTAL__;\n\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nexport const enableSchedulingProfiler: boolean =\n  !enableComponentPerformanceTrack && __PROFILE__;\n\n// Record durations for commit and passive effects phases.\nexport const enableProfilerCommitHooks = __PROFILE__;\n\n// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nexport const enableProfilerNestedUpdatePhase = __PROFILE__;\n\nexport const enableAsyncDebugInfo = __EXPERIMENTAL__;\n\n// Track which Fiber(s) schedule render work.\nexport const enableUpdaterTracking = __PROFILE__;\n\nexport const ownerStackLimit = 1e4;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {AsyncDispatcher} from 'react-reconciler/src/ReactInternalTypes';\n\nimport type {\n  Reference,\n  TaintEntry,\n  RequestCleanupQueue,\n} from './ReactTaintRegistry';\n\nimport {\n  TaintRegistryObjects,\n  TaintRegistryValues,\n  TaintRegistryByteLengths,\n  TaintRegistryPendingRequests,\n} from './ReactTaintRegistry';\n\nimport {enableTaint} from 'shared/ReactFeatureFlags';\n\nexport type SharedStateServer = {\n  H: null | Dispatcher, // ReactCurrentDispatcher for Hooks\n  A: null | AsyncDispatcher, // ReactCurrentCache for Cache\n\n  // enableTaint\n  TaintRegistryObjects: WeakMap<Reference, string>,\n  TaintRegistryValues: Map<string | bigint, TaintEntry>,\n  TaintRegistryByteLengths: Set<number>,\n  TaintRegistryPendingRequests: Set<RequestCleanupQueue>,\n\n  // DEV-only\n\n  // ReactDebugCurrentFrame\n  getCurrentStack: null | (() => string),\n\n  // ReactOwnerStackReset\n  recentlyCreatedOwnerStacks: 0,\n};\n\nexport type RendererTask = boolean => RendererTask | null;\n\nconst ReactSharedInternals: SharedStateServer = ({\n  H: null,\n  A: null,\n}: any);\n\nif (enableTaint) {\n  ReactSharedInternals.TaintRegistryObjects = TaintRegistryObjects;\n  ReactSharedInternals.TaintRegistryValues = TaintRegistryValues;\n  ReactSharedInternals.TaintRegistryByteLengths = TaintRegistryByteLengths;\n  ReactSharedInternals.TaintRegistryPendingRequests =\n    TaintRegistryPendingRequests;\n}\n\nif (__DEV__) {\n  // Stack implementation injected by the current renderer.\n  ReactSharedInternals.getCurrentStack = (null: null | (() => string));\n  ReactSharedInternals.recentlyCreatedOwnerStacks = 0;\n}\n\nexport default ReactSharedInternals;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\ndeclare function isArray(a: mixed): boolean %checks(Array.isArray(a));\n\nconst isArrayImpl = Array.isArray;\n\nfunction isArray(a: mixed): boolean {\n  return isArrayImpl(a);\n}\n\nexport default isArray;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport default function noop() {}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value: mixed): string {\n  if (__DEV__) {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    const hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    const type =\n      (hasToStringTag && (value: any)[Symbol.toStringTag]) ||\n      (value: any).constructor.name ||\n      'Object';\n    // $FlowFixMe[incompatible-return]\n    return type;\n  }\n}\n\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value: mixed): boolean {\n  if (__DEV__) {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\n/** @noinline */\nfunction testStringCoercion(value: mixed) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + (value: any);\n}\n\nexport function checkAttributeStringCoercion(\n  value: mixed,\n  attributeName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` attribute is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        attributeName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkKeyStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided key is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkPropStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` prop is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkOptionStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` option is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkCSSPropertyStringCoercion(\n  value: mixed,\n  propName: string,\n): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided `%s` CSS property is an unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        propName,\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkHtmlStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'The provided HTML markup uses a value of unsupported type %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nexport function checkFormFieldValueStringCoercion(value: mixed): void | string {\n  if (__DEV__) {\n    if (willCoercionThrow(value)) {\n      console.error(\n        'Form field values (value, checked, defaultValue, or defaultChecked props)' +\n          ' must be strings, not %s.' +\n          ' This value must be coerced to a string before using it here.',\n        typeName(value),\n      );\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {LazyComponent} from 'react/src/ReactLazy';\nimport type {ReactContext, ReactConsumerType} from 'shared/ReactTypes';\n\nimport {\n  REACT_CONTEXT_TYPE,\n  REACT_CONSUMER_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_TRACING_MARKER_TYPE,\n  REACT_VIEW_TRANSITION_TYPE,\n  REACT_ACTIVITY_TYPE,\n} from 'shared/ReactSymbols';\n\nimport {\n  enableTransitionTracing,\n  enableViewTransition,\n} from './ReactFeatureFlags';\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getWrappedName(\n  outerType: mixed,\n  innerType: any,\n  wrapperName: string,\n): string {\n  const displayName = (outerType: any).displayName;\n  if (displayName) {\n    return displayName;\n  }\n  const functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? `${wrapperName}(${functionName})` : wrapperName;\n}\n\n// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type: ReactContext<any>) {\n  return type.displayName || 'Context';\n}\n\nconst REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\n// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nexport default function getComponentNameFromType(type: mixed): string | null {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n  if (typeof type === 'function') {\n    if ((type: any).$$typeof === REACT_CLIENT_REFERENCE) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n    return (type: any).displayName || type.name || null;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n    case REACT_ACTIVITY_TYPE:\n      return 'Activity';\n    case REACT_VIEW_TRANSITION_TYPE:\n      if (enableViewTransition) {\n        return 'ViewTransition';\n      }\n    // Fall through\n    case REACT_TRACING_MARKER_TYPE:\n      if (enableTransitionTracing) {\n        return 'TracingMarker';\n      }\n  }\n  if (typeof type === 'object') {\n    if (__DEV__) {\n      if (typeof (type: any).tag === 'number') {\n        console.error(\n          'Received an unexpected object in getComponentNameFromType(). ' +\n            'This is likely a bug in React. Please file an issue.',\n        );\n      }\n    }\n    switch (type.$$typeof) {\n      case REACT_PORTAL_TYPE:\n        return 'Portal';\n      case REACT_CONTEXT_TYPE:\n        const context: ReactContext<any> = (type: any);\n        return getContextName(context);\n      case REACT_CONSUMER_TYPE:\n        const consumer: ReactConsumerType<any> = (type: any);\n        return getContextName(consumer._context) + '.Consumer';\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n      case REACT_MEMO_TYPE:\n        const outerName = (type: any).displayName || null;\n        if (outerName !== null) {\n          return outerName;\n        }\n        return getComponentNameFromType(type.type) || 'Memo';\n      case REACT_LAZY_TYPE: {\n        const lazyComponent: LazyComponent<any, any> = (type: any);\n        const payload = lazyComponent._payload;\n        const init = lazyComponent._init;\n        try {\n          return getComponentNameFromType(init(payload));\n        } catch (x) {\n          return null;\n        }\n      }\n    }\n  }\n  return null;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// $FlowFixMe[method-unbinding]\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport default hasOwnProperty;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst assign = Object.assign;\n\nexport default assign;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport assign from 'shared/assign';\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\nimport isArray from 'shared/isArray';\nimport {ownerStackLimit} from 'shared/ReactFeatureFlags';\n\nconst createTask =\n  // eslint-disable-next-line react-internal/no-production-logging\n  __DEV__ && console.createTask\n    ? // eslint-disable-next-line react-internal/no-production-logging\n      console.createTask\n    : () => null;\n\nfunction getTaskName(type) {\n  if (type === REACT_FRAGMENT_TYPE) {\n    return '<>';\n  }\n  if (\n    typeof type === 'object' &&\n    type !== null &&\n    type.$$typeof === REACT_LAZY_TYPE\n  ) {\n    // We don't want to eagerly initialize the initializer in DEV mode so we can't\n    // call it to extract the type so we don't know the type of this component.\n    return '<...>';\n  }\n  try {\n    const name = getComponentNameFromType(type);\n    return name ? '<' + name + '>' : '<...>';\n  } catch (x) {\n    return '<...>';\n  }\n}\n\nfunction getOwner() {\n  if (__DEV__) {\n    const dispatcher = ReactSharedInternals.A;\n    if (dispatcher === null) {\n      return null;\n    }\n    return dispatcher.getOwner();\n  }\n  return null;\n}\n\n/** @noinline */\nfunction UnknownOwner() {\n  /** @noinline */\n  return (() => Error('react-stack-top-frame'))();\n}\nconst createFakeCallStack = {\n  react_stack_bottom_frame: function (callStackForError) {\n    return callStackForError();\n  },\n};\n\nlet specialPropKeyWarningShown;\nlet didWarnAboutElementRef;\nlet didWarnAboutOldJSXRuntime;\nlet unknownOwnerDebugStack;\nlet unknownOwnerDebugTask;\n\nif (__DEV__) {\n  didWarnAboutElementRef = {};\n\n  // We use this technique to trick minifiers to preserve the function name.\n  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(\n    createFakeCallStack,\n    UnknownOwner,\n  )();\n  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://react.dev/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction elementRefGetterWithDeprecationWarning() {\n  if (__DEV__) {\n    const componentName = getComponentNameFromType(this.type);\n    if (!didWarnAboutElementRef[componentName]) {\n      didWarnAboutElementRef[componentName] = true;\n      console.error(\n        'Accessing element.ref was removed in React 19. ref is now a ' +\n          'regular prop. It will be removed from the JSX Element ' +\n          'type in a future release.',\n      );\n    }\n\n    // An undefined `element.ref` is coerced to `null` for\n    // backwards compatibility.\n    const refProp = this.props.ref;\n    return refProp !== undefined ? refProp : null;\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nfunction ReactElement(\n  type,\n  key,\n  self,\n  source,\n  owner,\n  props,\n  debugStack,\n  debugTask,\n) {\n  // Ignore whatever was passed as the ref argument and treat `props.ref` as\n  // the source of truth. The only thing we use this for is `element.ref`,\n  // which will log a deprecation warning on access. In the next release, we\n  // can remove `element.ref` as well as the `ref` argument.\n  const refProp = props.ref;\n\n  // An undefined `element.ref` is coerced to `null` for\n  // backwards compatibility.\n  const ref = refProp !== undefined ? refProp : null;\n\n  let element;\n  if (__DEV__) {\n    // In dev, make `ref` a non-enumerable property with a warning. It's non-\n    // enumerable so that test matchers and serializers don't access it and\n    // trigger the warning.\n    //\n    // `ref` will be removed from the element completely in a future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n\n      props,\n\n      // Record the component responsible for creating this element.\n      _owner: owner,\n    };\n    if (ref !== null) {\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        get: elementRefGetterWithDeprecationWarning,\n      });\n    } else {\n      // Don't warn on access if a ref is not given. This reduces false\n      // positives in cases where a test serializer uses\n      // getOwnPropertyDescriptors to compare objects, like Jest does, which is\n      // a problem because it bypasses non-enumerability.\n      //\n      // So unfortunately this will trigger a false positive warning in Jest\n      // when the diff is printed:\n      //\n      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);\n      //\n      // A bit sketchy, but this is what we've done for the `props.key` and\n      // `props.ref` accessors for years, which implies it will be good enough\n      // for `element.ref`, too. Let's see if anyone complains.\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        value: null,\n      });\n    }\n  } else {\n    // In prod, `ref` is a regular property and _owner doesn't exist.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n      ref,\n\n      props,\n    };\n  }\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: 0,\n    });\n    // debugInfo contains Server Component debug information.\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null,\n    });\n    Object.defineProperty(element, '_debugStack', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugStack,\n    });\n    Object.defineProperty(element, '_debugTask', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugTask,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxProd(type, config, maybeKey) {\n  let key = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  let props;\n  if (!('key' in config)) {\n    // If key was not spread in, we can reuse the original props object. This\n    // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n    // target and the compiler always passes a new object. For `createElement`,\n    // we can't assume a new object is passed every time because it can be\n    // called manually.\n    //\n    // Spreading key is a warning in dev. In a future release, we will not\n    // remove a spread key from the props object. (But we'll still warn.) We'll\n    // always pass the object straight through.\n    props = config;\n  } else {\n    // We need to remove reserved props (key, prop, ref). Create a fresh props\n    // object and copy over all the non-reserved props. We don't use `delete`\n    // because in V8 it will deopt the object to dictionary mode.\n    props = {};\n    for (const propName in config) {\n      // Skip over reserved prop names\n      if (propName !== 'key') {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    undefined,\n    undefined,\n  );\n}\n\n// While `jsxDEV` should never be called when running in production, we do\n// support `jsx` and `jsxs` when running in development. This supports the case\n// where a third-party dependency ships code that was compiled for production;\n// we want to still provide warnings in development.\n//\n// So these functions are the _dev_ implementations of the _production_\n// API signatures.\n//\n// Since these functions are dev-only, it's ok to add an indirection here. They\n// only exist to provide different versions of `isStaticChildren`. (We shouldn't\n// use this pattern for the prod versions, though, because it will add an call\n// frame.)\nexport function jsxProdSignatureRunningInDevWithDynamicChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = false;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nexport function jsxProdSignatureRunningInDevWithStaticChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = true;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nconst didWarnAboutKeySpread = {};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return jsxDEVImpl(\n    type,\n    config,\n    maybeKey,\n    isStaticChildren,\n    source,\n    self,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nfunction jsxDEVImpl(\n  type,\n  config,\n  maybeKey,\n  isStaticChildren,\n  source,\n  self,\n  debugStack,\n  debugTask,\n) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    // With owner stacks, we no longer need the type here so this comment is\n    // no longer true. Which is why we can run this even for invalid types.\n    const children = config.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          console.error(\n            'React.jsx: Static children should always be an array. ' +\n              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n              'Use the Babel transform instead.',\n          );\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n\n    // Warn about key spread regardless of whether the type is valid.\n    if (hasOwnProperty.call(config, 'key')) {\n      const componentName = getComponentNameFromType(type);\n      const keys = Object.keys(config).filter(k => k !== 'key');\n      const beforeExample =\n        keys.length > 0\n          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'\n          : '{key: someKey}';\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        const afterExample =\n          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n        console.error(\n          'A props object containing a \"key\" prop is being spread into JSX:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s {...props} />\\n' +\n            'React keys must be passed directly to JSX without using spread:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s key={someKey} {...props} />',\n          beforeExample,\n          componentName,\n          afterExample,\n          componentName,\n        );\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    let key = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    let props;\n    if (!('key' in config)) {\n      // If key was not spread in, we can reuse the original props object. This\n      // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n      // target and the compiler always passes a new object. For `createElement`,\n      // we can't assume a new object is passed every time because it can be\n      // called manually.\n      //\n      // Spreading key is a warning in dev. In a future release, we will not\n      // remove a spread key from the props object. (But we'll still warn.) We'll\n      // always pass the object straight through.\n      props = config;\n    } else {\n      // We need to remove reserved props (key, prop, ref). Create a fresh props\n      // object and copy over all the non-reserved props. We don't use `delete`\n      // because in V8 it will deopt the object to dictionary mode.\n      props = {};\n      for (const propName in config) {\n        // Skip over reserved prop names\n        if (propName !== 'key') {\n          props[propName] = config[propName];\n        }\n      }\n    }\n\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    return ReactElement(\n      type,\n      key,\n      self,\n      source,\n      getOwner(),\n      props,\n      debugStack,\n      debugTask,\n    );\n  }\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n  }\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const clonedElement = ReactElement(\n    oldElement.type,\n    newKey,\n    undefined,\n    undefined,\n    !__DEV__ ? undefined : oldElement._owner,\n    oldElement.props,\n    __DEV__ && oldElement._debugStack,\n    __DEV__ && oldElement._debugTask,\n  );\n  if (__DEV__) {\n    // The cloned element should inherit the original element's key validation.\n    if (oldElement._store) {\n      clonedElement._store.validated = oldElement._store.validated;\n    }\n  }\n  return clonedElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = !__DEV__ ? undefined : element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      owner = __DEV__ ? getOwner() : undefined;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // ...and maybe these, too, though we currently rely on them for\n        // warnings and debug information in dev. Need to decide if we're OK\n        // with dropping them. In the jsx() runtime it's not an issue because\n        // the data gets passed as separate arguments instead of props, but\n        // it would be nice to stop relying on them entirely so we can drop\n        // them from the internal Fiber field.\n        propName !== '__self' &&\n        propName !== '__source' &&\n        // Undefined `ref` is ignored by cloneElement. We treat it the same as\n        // if the property were missing. This is mostly for\n        // backwards compatibility.\n        !(propName === 'ref' && config.ref === undefined)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  const clonedElement = ReactElement(\n    element.type,\n    key,\n    undefined,\n    undefined,\n    owner,\n    props,\n    __DEV__ && element._debugStack,\n    __DEV__ && element._debugTask,\n  );\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], clonedElement.type);\n  }\n\n  return clonedElement;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    // With owner stacks is, no warnings happens. All we do is\n    // mark elements as being in a valid static child position so they\n    // don't need keys.\n    if (isValidElement(node)) {\n      if (node._store) {\n        node._store.validated = 1;\n      }\n    }\n  }\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  ReactNodeList,\n  Thenable,\n  PendingThenable,\n  FulfilledThenable,\n  RejectedThenable,\n} from 'shared/ReactTypes';\n\nimport isArray from 'shared/isArray';\nimport noop from 'shared/noop';\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_PORTAL_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\n\nimport {isValidElement, cloneAndReplaceKey} from './jsx/ReactJSXElement';\n\nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key: string): string {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedString = key.replace(escapeRegex, function (match) {\n    // $FlowFixMe[invalid-computed-prop]\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nlet didWarnAboutMaps = false;\n\nconst userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text: string): string {\n  return text.replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\n/**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getElementKey(element: any, index: number): string {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    // Explicit key\n    if (__DEV__) {\n      checkKeyStringCoercion(element.key);\n    }\n    return escape('' + element.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction resolveThenable<T>(thenable: Thenable<T>): T {\n  switch (thenable.status) {\n    case 'fulfilled': {\n      const fulfilledValue: T = thenable.value;\n      return fulfilledValue;\n    }\n    case 'rejected': {\n      const rejectedError = thenable.reason;\n      throw rejectedError;\n    }\n    default: {\n      if (typeof thenable.status === 'string') {\n        // Only instrument the thenable if the status if not defined. If\n        // it's defined, but an unknown value, assume it's been instrumented by\n        // some custom userspace implementation. We treat it as \"pending\".\n        // Attach a dummy listener, to ensure that any lazy initialization can\n        // happen. Flight lazily parses JSON when the value is actually awaited.\n        thenable.then(noop, noop);\n      } else {\n        // This is an uncached thenable that we haven't seen before.\n\n        // TODO: Detect infinite ping loops caused by uncached promises.\n\n        const pendingThenable: PendingThenable<T> = (thenable: any);\n        pendingThenable.status = 'pending';\n        pendingThenable.then(\n          fulfilledValue => {\n            if (thenable.status === 'pending') {\n              const fulfilledThenable: FulfilledThenable<T> = (thenable: any);\n              fulfilledThenable.status = 'fulfilled';\n              fulfilledThenable.value = fulfilledValue;\n            }\n          },\n          (error: mixed) => {\n            if (thenable.status === 'pending') {\n              const rejectedThenable: RejectedThenable<T> = (thenable: any);\n              rejectedThenable.status = 'rejected';\n              rejectedThenable.reason = error;\n            }\n          },\n        );\n      }\n\n      // Check one more time in case the thenable resolved synchronously.\n      switch ((thenable: Thenable<T>).status) {\n        case 'fulfilled': {\n          const fulfilledThenable: FulfilledThenable<T> = (thenable: any);\n          return fulfilledThenable.value;\n        }\n        case 'rejected': {\n          const rejectedThenable: RejectedThenable<T> = (thenable: any);\n          const rejectedError = rejectedThenable.reason;\n          throw rejectedError;\n        }\n      }\n    }\n  }\n  throw thenable;\n}\n\nfunction mapIntoArray(\n  children: ?ReactNodeList,\n  array: Array<React$Node>,\n  escapedPrefix: string,\n  nameSoFar: string,\n  callback: (?React$Node) => ?ReactNodeList,\n): number {\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  let invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'bigint':\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch ((children: any).$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n            break;\n          case REACT_LAZY_TYPE:\n            const payload = (children: any)._payload;\n            const init = (children: any)._init;\n            return mapIntoArray(\n              init(payload),\n              array,\n              escapedPrefix,\n              nameSoFar,\n              callback,\n            );\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    const child = children;\n    let mappedChild = callback(child);\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows:\n    const childKey =\n      nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;\n    if (isArray(mappedChild)) {\n      let escapedChildKey = '';\n      if (childKey != null) {\n        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n      }\n      mapIntoArray(mappedChild, array, escapedChildKey, '', c => c);\n    } else if (mappedChild != null) {\n      if (isValidElement(mappedChild)) {\n        if (__DEV__) {\n          // The `if` statement here prevents auto-disabling of the safe\n          // coercion ESLint rule, so we must manually disable it below.\n          // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n          if (mappedChild.key != null) {\n            if (!child || child.key !== mappedChild.key) {\n              checkKeyStringCoercion(mappedChild.key);\n            }\n          }\n        }\n        const newChild = cloneAndReplaceKey(\n          mappedChild,\n          // Keep both the (mapped) and old keys if they differ, just as\n          // traverseAllChildren used to do for objects as children\n          escapedPrefix +\n            // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n            (mappedChild.key != null &&\n            (!child || child.key !== mappedChild.key)\n              ? escapeUserProvidedKey(\n                  // $FlowFixMe[unsafe-addition]\n                  '' + mappedChild.key, // eslint-disable-line react-internal/safe-string-coercion\n                ) + '/'\n              : '') +\n            childKey,\n        );\n        if (__DEV__) {\n          // If `child` was an element without a `key`, we need to validate if\n          // it should have had a `key`, before assigning one to `mappedChild`.\n          // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n          if (\n            nameSoFar !== '' &&\n            child != null &&\n            isValidElement(child) &&\n            child.key == null\n          ) {\n            // We check truthiness of `child._store.validated` instead of being\n            // inequal to `1` to provide a bit of backward compatibility for any\n            // libraries (like `fbt`) which may be hacking this property.\n            if (child._store && !child._store.validated) {\n              // Mark this child as having failed validation, but let the actual\n              // renderer print the warning later.\n              newChild._store.validated = 2;\n            }\n          }\n        }\n        mappedChild = newChild;\n      }\n      array.push(mappedChild);\n    }\n    return 1;\n  }\n\n  let child;\n  let nextName;\n  let subtreeCount = 0; // Count of children found in the current subtree.\n  const nextNamePrefix =\n    nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getElementKey(child, i);\n      subtreeCount += mapIntoArray(\n        child,\n        array,\n        escapedPrefix,\n        nextName,\n        callback,\n      );\n    }\n  } else {\n    const iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      const iterableChildren: Iterable<React$Node> & {\n        entries: any,\n      } = (children: any);\n\n      if (__DEV__) {\n        // Warn about using Maps as children\n        if (iteratorFn === iterableChildren.entries) {\n          if (!didWarnAboutMaps) {\n            console.warn(\n              'Using Maps as children is not supported. ' +\n                'Use an array of keyed ReactElements instead.',\n            );\n          }\n          didWarnAboutMaps = true;\n        }\n      }\n\n      const iterator = iteratorFn.call(iterableChildren);\n      let step;\n      let ii = 0;\n      // $FlowFixMe[incompatible-use] `iteratorFn` might return null according to typing.\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getElementKey(child, ii++);\n        subtreeCount += mapIntoArray(\n          child,\n          array,\n          escapedPrefix,\n          nextName,\n          callback,\n        );\n      }\n    } else if (type === 'object') {\n      if (typeof (children: any).then === 'function') {\n        return mapIntoArray(\n          resolveThenable((children: any)),\n          array,\n          escapedPrefix,\n          nameSoFar,\n          callback,\n        );\n      }\n\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      const childrenString = String((children: any));\n\n      throw new Error(\n        `Objects are not valid as a React child (found: ${\n          childrenString === '[object Object]'\n            ? 'object with keys {' +\n              Object.keys((children: any)).join(', ') +\n              '}'\n            : childrenString\n        }). ` +\n          'If you meant to render a collection of children, use an array ' +\n          'instead.',\n      );\n    }\n  }\n\n  return subtreeCount;\n}\n\ntype MapFunc = (child: ?React$Node, index: number) => ?ReactNodeList;\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(\n  children: ?ReactNodeList,\n  func: MapFunc,\n  context: mixed,\n): ?Array<React$Node> {\n  if (children == null) {\n    // $FlowFixMe limitation refining abstract types in Flow\n    return children;\n  }\n  const result: Array<React$Node> = [];\n  let count = 0;\n  mapIntoArray(children, result, '', '', function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children: ?ReactNodeList): number {\n  let n = 0;\n  mapChildren(children, () => {\n    n++;\n    // Don't return anything\n  });\n  return n;\n}\n\ntype ForEachFunc = (child: ?React$Node) => void;\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(\n  children: ?ReactNodeList,\n  forEachFunc: ForEachFunc,\n  forEachContext: mixed,\n): void {\n  mapChildren(\n    children,\n    // $FlowFixMe[missing-this-annot]\n    function () {\n      forEachFunc.apply(this, arguments);\n      // Don't return anything.\n    },\n    forEachContext,\n  );\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\nfunction toArray(children: ?ReactNodeList): Array<React$Node> {\n  return mapChildren(children, child => child) || [];\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild<T>(children: T): T {\n  if (!isValidElement(children)) {\n    throw new Error(\n      'React.Children.only expected to receive a single React element child.',\n    );\n  }\n\n  return children;\n}\n\nexport {\n  forEachChildren as forEach,\n  mapChildren as map,\n  countChildren as count,\n  onlyChild as only,\n  toArray,\n};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n * @flow\n */\n\nimport type {RefObject} from 'shared/ReactTypes';\n\n// an immutable object with a single mutable value\nexport function createRef(): RefObject {\n  const refObject = {\n    current: null,\n  };\n  if (__DEV__) {\n    Object.seal(refObject);\n  }\n  return refObject;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  ReactContext,\n  StartTransitionOptions,\n  Usable,\n  Awaited,\n} from 'shared/ReactTypes';\nimport {REACT_CONSUMER_TYPE} from 'shared/ReactSymbols';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\ntype BasicStateAction<S> = (S => S) | S;\ntype Dispatch<A> = A => void;\n\nfunction resolveDispatcher() {\n  const dispatcher = ReactSharedInternals.H;\n  if (__DEV__) {\n    if (dispatcher === null) {\n      console.error(\n        'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n          ' one of the following reasons:\\n' +\n          '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n          '2. You might be breaking the Rules of Hooks\\n' +\n          '3. You might have more than one copy of React in the same app\\n' +\n          'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.',\n      );\n    }\n  }\n  // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n  return ((dispatcher: any): Dispatcher);\n}\n\nexport function getCacheForType<T>(resourceType: () => T): T {\n  const dispatcher = ReactSharedInternals.A;\n  if (!dispatcher) {\n    // If there is no dispatcher, then we treat this as not being cached.\n    return resourceType();\n  }\n  return dispatcher.getCacheForType(resourceType);\n}\n\nexport function useContext<T>(Context: ReactContext<T>): T {\n  const dispatcher = resolveDispatcher();\n  if (__DEV__) {\n    if (Context.$$typeof === REACT_CONSUMER_TYPE) {\n      console.error(\n        'Calling useContext(Context.Consumer) is not supported and will cause bugs. ' +\n          'Did you mean to call useContext(Context) instead?',\n      );\n    }\n  }\n  return dispatcher.useContext(Context);\n}\n\nexport function useState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n\nexport function useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\n\nexport function useRef<T>(initialValue: T): {current: T} {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\n\nexport function useEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\n\nexport function useInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\n\nexport function useLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\n\nexport function useCallback<T>(\n  callback: T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\n\nexport function useMemo<T>(\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\n\nexport function useImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\n\nexport function useDebugValue<T>(\n  value: T,\n  formatterFn: ?(value: T) => mixed,\n): void {\n  if (__DEV__) {\n    const dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\n\nexport function useTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\n\nexport function useDeferredValue<T>(value: T, initialValue?: T): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value, initialValue);\n}\n\nexport function useId(): string {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\n\nexport function useSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n  );\n}\n\nexport function useCacheRefresh(): <T>(?() => T, ?T) => void {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useCacheRefresh();\n}\n\nexport function use<T>(usable: Usable<T>): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.use(usable);\n}\n\nexport function useMemoCache(size: number): Array<mixed> {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useMemoCache(size);\n}\n\nexport function useEffectEvent<Args, F: (...Array<Args>) => mixed>(\n  callback: F,\n): F {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useEffectEvent(callback);\n}\n\nexport function useOptimistic<S, A>(\n  passthrough: S,\n  reducer: ?(S, A) => S,\n): [S, (A) => void] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useOptimistic(passthrough, reducer);\n}\n\nexport function useActionState<S, P>(\n  action: (Awaited<S>, P) => S,\n  initialState: Awaited<S>,\n  permalink?: string,\n): [Awaited<S>, (P) => void, boolean] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useActionState(action, initialState, permalink);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n */\n\nimport {REACT_FORWARD_REF_TYPE, REACT_MEMO_TYPE} from 'shared/ReactSymbols';\n\nexport function forwardRef<Props, ElementType: React$ElementType>(\n  render: (\n    props: Props,\n    ref: React$RefSetter<React$ElementRef<ElementType>>,\n  ) => React$Node,\n) {\n  if (__DEV__) {\n    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n      console.error(\n        'forwardRef requires a render function but received a `memo` ' +\n          'component. Instead of forwardRef(memo(...)), use ' +\n          'memo(forwardRef(...)).',\n      );\n    } else if (typeof render !== 'function') {\n      console.error(\n        'forwardRef requires a render function but was given %s.',\n        render === null ? 'null' : typeof render,\n      );\n    } else {\n      if (render.length !== 0 && render.length !== 2) {\n        console.error(\n          'forwardRef render functions accept exactly two parameters: props and ref. %s',\n          render.length === 1\n            ? 'Did you forget to use the ref parameter?'\n            : 'Any additional parameter will be undefined.',\n        );\n      }\n    }\n\n    if (render != null) {\n      if (render.defaultProps != null) {\n        console.error(\n          'forwardRef render functions do not support defaultProps. ' +\n            'Did you accidentally pass a React component?',\n        );\n      }\n    }\n  }\n\n  const elementType = {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render,\n  };\n  if (__DEV__) {\n    let ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name;\n\n        // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.forwardRef((props, ref) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n        if (!render.name && !render.displayName) {\n          Object.defineProperty(render, 'name', {\n            value: name,\n          });\n          render.displayName = name;\n        }\n      },\n    });\n  }\n  return elementType;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Wakeable, Thenable, ReactDebugInfo} from 'shared/ReactTypes';\n\nimport {REACT_LAZY_TYPE} from 'shared/ReactSymbols';\n\nconst Uninitialized = -1;\nconst Pending = 0;\nconst Resolved = 1;\nconst Rejected = 2;\n\ntype UninitializedPayload<T> = {\n  _status: -1,\n  _result: () => Thenable<{default: T, ...}>,\n};\n\ntype PendingPayload = {\n  _status: 0,\n  _result: Wakeable,\n};\n\ntype ResolvedPayload<T> = {\n  _status: 1,\n  _result: {default: T, ...},\n};\n\ntype RejectedPayload = {\n  _status: 2,\n  _result: mixed,\n};\n\ntype Payload<T> =\n  | UninitializedPayload<T>\n  | PendingPayload\n  | ResolvedPayload<T>\n  | RejectedPayload;\n\nexport type LazyComponent<T, P> = {\n  $$typeof: symbol | number,\n  _payload: P,\n  _init: (payload: P) => T,\n  _debugInfo?: null | ReactDebugInfo,\n};\n\nfunction lazyInitializer<T>(payload: Payload<T>): T {\n  if (payload._status === Uninitialized) {\n    const ctor = payload._result;\n    const thenable = ctor();\n    // Transition to the next state.\n    // This might throw either because it's missing or throws. If so, we treat it\n    // as still uninitialized and try again next time. Which is the same as what\n    // happens if the ctor or any wrappers processing the ctor throws. This might\n    // end up fixing it if the resolution was a concurrency bug.\n    thenable.then(\n      moduleObject => {\n        if (\n          (payload: Payload<T>)._status === Pending ||\n          payload._status === Uninitialized\n        ) {\n          // Transition to the next state.\n          const resolved: ResolvedPayload<T> = (payload: any);\n          resolved._status = Resolved;\n          resolved._result = moduleObject;\n        }\n      },\n      error => {\n        if (\n          (payload: Payload<T>)._status === Pending ||\n          payload._status === Uninitialized\n        ) {\n          // Transition to the next state.\n          const rejected: RejectedPayload = (payload: any);\n          rejected._status = Rejected;\n          rejected._result = error;\n        }\n      },\n    );\n    if (payload._status === Uninitialized) {\n      // In case, we're still uninitialized, then we're waiting for the thenable\n      // to resolve. Set it as pending in the meantime.\n      const pending: PendingPayload = (payload: any);\n      pending._status = Pending;\n      pending._result = thenable;\n    }\n  }\n  if (payload._status === Resolved) {\n    const moduleObject = payload._result;\n    if (__DEV__) {\n      if (moduleObject === undefined) {\n        console.error(\n          'lazy: Expected the result of a dynamic imp' +\n            'ort() call. ' +\n            'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' +\n            \"ort('./MyComponent'))\\n\\n\" +\n            'Did you accidentally put curly braces around the import?',\n          moduleObject,\n        );\n      }\n    }\n    if (__DEV__) {\n      if (!('default' in moduleObject)) {\n        console.error(\n          'lazy: Expected the result of a dynamic imp' +\n            'ort() call. ' +\n            'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' +\n            \"ort('./MyComponent'))\",\n          moduleObject,\n        );\n      }\n    }\n    return moduleObject.default;\n  } else {\n    throw payload._result;\n  }\n}\n\nexport function lazy<T>(\n  ctor: () => Thenable<{default: T, ...}>,\n): LazyComponent<T, Payload<T>> {\n  const payload: Payload<T> = {\n    // We use these fields to store the result.\n    _status: Uninitialized,\n    _result: ctor,\n  };\n\n  const lazyType: LazyComponent<T, Payload<T>> = {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: payload,\n    _init: lazyInitializer,\n  };\n\n  return lazyType;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n */\n\nimport {REACT_MEMO_TYPE} from 'shared/ReactSymbols';\n\nexport function memo<Props>(\n  type: React$ElementType,\n  compare?: (oldProps: Props, newProps: Props) => boolean,\n) {\n  if (__DEV__) {\n    if (type == null) {\n      console.error(\n        'memo: The first argument must be a component. Instead ' +\n          'received: %s',\n        type === null ? 'null' : typeof type,\n      );\n    }\n  }\n  const elementType = {\n    $$typeof: REACT_MEMO_TYPE,\n    type,\n    compare: compare === undefined ? null : compare,\n  };\n  if (__DEV__) {\n    let ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name;\n\n        // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.memo((props) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n        if (!type.name && !type.displayName) {\n          Object.defineProperty(type, 'name', {\n            value: name,\n          });\n          type.displayName = name;\n        }\n      },\n    });\n  }\n  return elementType;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nconst UNTERMINATED = 0;\nconst TERMINATED = 1;\nconst ERRORED = 2;\n\ntype UnterminatedCacheNode<T> = {\n  s: 0,\n  v: void,\n  o: null | WeakMap<Function | Object, CacheNode<T>>,\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>,\n};\n\ntype TerminatedCacheNode<T> = {\n  s: 1,\n  v: T,\n  o: null | WeakMap<Function | Object, CacheNode<T>>,\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>,\n};\n\ntype ErroredCacheNode<T> = {\n  s: 2,\n  v: mixed,\n  o: null | WeakMap<Function | Object, CacheNode<T>>,\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>,\n};\n\ntype CacheNode<T> =\n  | TerminatedCacheNode<T>\n  | UnterminatedCacheNode<T>\n  | ErroredCacheNode<T>;\n\nfunction createCacheRoot<T>(): WeakMap<Function | Object, CacheNode<T>> {\n  return new WeakMap();\n}\n\nfunction createCacheNode<T>(): CacheNode<T> {\n  return {\n    s: UNTERMINATED, // status, represents whether the cached computation returned a value or threw an error\n    v: undefined, // value, either the cached result or an error, depending on s\n    o: null, // object cache, a WeakMap where non-primitive arguments are stored\n    p: null, // primitive cache, a regular Map where primitive arguments are stored.\n  };\n}\n\nexport function cache<A: Iterable<mixed>, T>(fn: (...A) => T): (...A) => T {\n  return function () {\n    const dispatcher = ReactSharedInternals.A;\n    if (!dispatcher) {\n      // If there is no dispatcher, then we treat this as not being cached.\n      // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.\n      return fn.apply(null, arguments);\n    }\n    const fnMap: WeakMap<any, CacheNode<T>> = dispatcher.getCacheForType(\n      createCacheRoot,\n    );\n    const fnNode = fnMap.get(fn);\n    let cacheNode: CacheNode<T>;\n    if (fnNode === undefined) {\n      cacheNode = createCacheNode();\n      fnMap.set(fn, cacheNode);\n    } else {\n      cacheNode = fnNode;\n    }\n    for (let i = 0, l = arguments.length; i < l; i++) {\n      const arg = arguments[i];\n      if (\n        typeof arg === 'function' ||\n        (typeof arg === 'object' && arg !== null)\n      ) {\n        // Objects go into a WeakMap\n        let objectCache = cacheNode.o;\n        if (objectCache === null) {\n          cacheNode.o = objectCache = new WeakMap();\n        }\n        const objectNode = objectCache.get(arg);\n        if (objectNode === undefined) {\n          cacheNode = createCacheNode();\n          objectCache.set(arg, cacheNode);\n        } else {\n          cacheNode = objectNode;\n        }\n      } else {\n        // Primitives go into a regular Map\n        let primitiveCache = cacheNode.p;\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = new Map();\n        }\n        const primitiveNode = primitiveCache.get(arg);\n        if (primitiveNode === undefined) {\n          cacheNode = createCacheNode();\n          primitiveCache.set(arg, cacheNode);\n        } else {\n          cacheNode = primitiveNode;\n        }\n      }\n    }\n    if (cacheNode.s === TERMINATED) {\n      return cacheNode.v;\n    }\n    if (cacheNode.s === ERRORED) {\n      throw cacheNode.v;\n    }\n    try {\n      // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.\n      const result = fn.apply(null, arguments);\n      const terminatedNode: TerminatedCacheNode<T> = (cacheNode: any);\n      terminatedNode.s = TERMINATED;\n      terminatedNode.v = result;\n      return result;\n    } catch (error) {\n      // We store the first error that's thrown and rethrow it.\n      const erroredNode: ErroredCacheNode<T> = (cacheNode: any);\n      erroredNode.s = ERRORED;\n      erroredNode.v = error;\n      throw error;\n    }\n  };\n}\n\nexport function cacheSignal(): null | AbortSignal {\n  const dispatcher = ReactSharedInternals.A;\n  if (!dispatcher) {\n    // If there is no dispatcher, then we treat this as not having an AbortSignal\n    // since in the same context, a cached function will be allowed to be called\n    // but it won't be cached. So it's neither an infinite AbortSignal nor an\n    // already resolved one.\n    return null;\n  }\n  return dispatcher.cacheSignal();\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst reportGlobalError: (error: mixed) => void =\n  typeof reportError === 'function'\n    ? // In modern browsers, reportError will dispatch an error event,\n      // emulating an uncaught JavaScript error.\n      reportError\n    : error => {\n        if (\n          typeof window === 'object' &&\n          typeof window.ErrorEvent === 'function'\n        ) {\n          // Browser Polyfill\n          const message =\n            typeof error === 'object' &&\n            error !== null &&\n            typeof error.message === 'string'\n              ? // eslint-disable-next-line react-internal/safe-string-coercion\n                String(error.message)\n              : // eslint-disable-next-line react-internal/safe-string-coercion\n                String(error);\n          const event = new window.ErrorEvent('error', {\n            bubbles: true,\n            cancelable: true,\n            message: message,\n            error: error,\n          });\n          const shouldLog = window.dispatchEvent(event);\n          if (!shouldLog) {\n            return;\n          }\n        } else if (\n          typeof process === 'object' &&\n          // $FlowFixMe[method-unbinding]\n          typeof process.emit === 'function'\n        ) {\n          // Node Polyfill\n          process.emit('uncaughtException', error);\n          return;\n        }\n        console['error'](error);\n      };\n\nexport default reportGlobalError;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  StartTransitionOptions,\n  GestureProvider,\n  GestureOptions,\n} from 'shared/ReactTypes';\nimport type {TransitionTypes} from './ReactTransitionType';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nimport {\n  enableTransitionTracing,\n  enableViewTransition,\n  enableGestureTransition,\n} from 'shared/ReactFeatureFlags';\n\nimport reportGlobalError from 'shared/reportGlobalError';\n\nimport noop from 'shared/noop';\n\nexport type Transition = {\n  types: null | TransitionTypes, // enableViewTransition\n  gesture: null | GestureProvider, // enableGestureTransition\n  name: null | string, // enableTransitionTracing only\n  startTime: number, // enableTransitionTracing only\n  _updatedFibers: Set<Fiber>, // DEV-only\n  ...\n};\n\nfunction releaseAsyncTransition() {\n  if (__DEV__) {\n    ReactSharedInternals.asyncTransitions--;\n  }\n}\n\nexport function startTransition(\n  scope: () => void,\n  options?: StartTransitionOptions,\n): void {\n  const prevTransition = ReactSharedInternals.T;\n  const currentTransition: Transition = ({}: any);\n  if (enableViewTransition) {\n    currentTransition.types =\n      prevTransition !== null\n        ? // If we're a nested transition, we should use the same set as the parent\n          // since we're conceptually always joined into the same entangled transition.\n          // In practice, this only matters if we add transition types in the inner\n          // without setting state. In that case, the inner transition can finish\n          // without waiting for the outer.\n          prevTransition.types\n        : null;\n  }\n  if (enableGestureTransition) {\n    currentTransition.gesture = null;\n  }\n  if (enableTransitionTracing) {\n    currentTransition.name =\n      options !== undefined && options.name !== undefined ? options.name : null;\n    currentTransition.startTime = -1; // TODO: This should read the timestamp.\n  }\n  if (__DEV__) {\n    currentTransition._updatedFibers = new Set();\n  }\n  ReactSharedInternals.T = currentTransition;\n\n  try {\n    const returnValue = scope();\n    const onStartTransitionFinish = ReactSharedInternals.S;\n    if (onStartTransitionFinish !== null) {\n      onStartTransitionFinish(currentTransition, returnValue);\n    }\n    if (\n      typeof returnValue === 'object' &&\n      returnValue !== null &&\n      typeof returnValue.then === 'function'\n    ) {\n      if (__DEV__) {\n        // Keep track of the number of async transitions still running so we can warn.\n        ReactSharedInternals.asyncTransitions++;\n        returnValue.then(releaseAsyncTransition, releaseAsyncTransition);\n      }\n      returnValue.then(noop, reportGlobalError);\n    }\n  } catch (error) {\n    reportGlobalError(error);\n  } finally {\n    warnAboutTransitionSubscriptions(prevTransition, currentTransition);\n    if (prevTransition !== null && currentTransition.types !== null) {\n      // If we created a new types set in the inner transition, we transfer it to the parent\n      // since they should share the same set. They're conceptually entangled.\n      if (__DEV__) {\n        if (\n          prevTransition.types !== null &&\n          prevTransition.types !== currentTransition.types\n        ) {\n          // Just assert that assumption holds that we're not overriding anything.\n          console.error(\n            'We expected inner Transitions to have transferred the outer types set and ' +\n              'that you cannot add to the outer Transition while inside the inner.' +\n              'This is a bug in React.',\n          );\n        }\n      }\n      prevTransition.types = currentTransition.types;\n    }\n    ReactSharedInternals.T = prevTransition;\n  }\n}\n\nexport function startGestureTransition(\n  provider: GestureProvider,\n  scope: () => void,\n  options?: GestureOptions & StartTransitionOptions,\n): () => void {\n  if (!enableGestureTransition) {\n    // eslint-disable-next-line react-internal/prod-error-codes\n    throw new Error(\n      'startGestureTransition should not be exported when the enableGestureTransition flag is off.',\n    );\n  }\n  if (provider == null) {\n    // We enforce this at runtime even though the type also enforces it since we\n    // use null as a signal internally so it would lead it to be treated as a\n    // regular transition otherwise.\n    throw new Error(\n      'A Timeline is required as the first argument to startGestureTransition.',\n    );\n  }\n  const prevTransition = ReactSharedInternals.T;\n  const currentTransition: Transition = ({}: any);\n  if (enableViewTransition) {\n    currentTransition.types = null;\n  }\n  if (enableGestureTransition) {\n    currentTransition.gesture = provider;\n  }\n  if (enableTransitionTracing) {\n    currentTransition.name =\n      options !== undefined && options.name !== undefined ? options.name : null;\n    currentTransition.startTime = -1; // TODO: This should read the timestamp.\n  }\n  if (__DEV__) {\n    currentTransition._updatedFibers = new Set();\n  }\n  ReactSharedInternals.T = currentTransition;\n\n  try {\n    const returnValue = scope();\n    if (__DEV__) {\n      if (\n        typeof returnValue === 'object' &&\n        returnValue !== null &&\n        typeof returnValue.then === 'function'\n      ) {\n        console.error(\n          'Cannot use an async function in startGestureTransition. It must be able to start immediately.',\n        );\n      }\n    }\n    const onStartGestureTransitionFinish = ReactSharedInternals.G;\n    if (onStartGestureTransitionFinish !== null) {\n      return onStartGestureTransitionFinish(\n        currentTransition,\n        provider,\n        options,\n      );\n    }\n  } catch (error) {\n    reportGlobalError(error);\n  } finally {\n    ReactSharedInternals.T = prevTransition;\n  }\n  return noop;\n}\n\nfunction warnAboutTransitionSubscriptions(\n  prevTransition: Transition | null,\n  currentTransition: Transition,\n) {\n  if (__DEV__) {\n    if (prevTransition === null && currentTransition._updatedFibers) {\n      const updatedFibersCount = currentTransition._updatedFibers.size;\n      currentTransition._updatedFibers.clear();\n      if (updatedFibersCount > 10) {\n        console.warn(\n          'Detected a large number of updates inside startTransition. ' +\n            'If this is due to a subscription please re-write it to use React provided hooks. ' +\n            'Otherwise concurrent mode guarantees are off the table.',\n        );\n      }\n    }\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {REACT_POSTPONE_TYPE} from 'shared/ReactSymbols';\n\ndeclare class Postpone extends Error {\n  $$typeof: symbol;\n}\n\nexport type {Postpone};\n\nexport function postpone(reason: string): void {\n  // eslint-disable-next-line react-internal/prod-error-codes\n  const postponeInstance: Postpone = (new Error(reason): any);\n  postponeInstance.$$typeof = REACT_POSTPONE_TYPE;\n  throw postponeInstance;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nexport function captureOwnerStack(): null | string {\n  if (__DEV__) {\n    const getCurrentStack = ReactSharedInternals.getCurrentStack;\n    if (getCurrentStack === null) {\n      return null;\n    }\n    // The current stack will be the owner stack which it is always here.\n    return getCurrentStack();\n  }\n\n  return null;\n}\n","export default '19.2.0-canary-602917c8-20250701';\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst getPrototypeOf = Object.getPrototypeOf;\n\nexport default getPrototypeOf;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// Turns a TypedArray or ArrayBuffer into a string that can be used for comparison\n// in a Map to see if the bytes are the same.\nexport default function binaryToComparableString(\n  view: $ArrayBufferView,\n): string {\n  return String.fromCharCode.apply(\n    String,\n    new Uint8Array(view.buffer, view.byteOffset, view.byteLength),\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {enableTaint} from 'shared/ReactFeatureFlags';\n\nimport getPrototypeOf from 'shared/getPrototypeOf';\n\nimport binaryToComparableString from 'shared/binaryToComparableString';\n\nimport ReactSharedInternals from './ReactSharedInternalsServer';\nconst {\n  TaintRegistryObjects,\n  TaintRegistryValues,\n  TaintRegistryByteLengths,\n  TaintRegistryPendingRequests,\n} = ReactSharedInternals;\n\ninterface Reference {}\n\n// This is the shared constructor of all typed arrays.\nconst TypedArrayConstructor = getPrototypeOf(Uint32Array.prototype).constructor;\n\nconst defaultMessage =\n  'A tainted value was attempted to be serialized to a Client Component or Action closure. ' +\n  'This would leak it to the client.';\n\nfunction cleanup(entryValue: string | bigint): void {\n  const entry = TaintRegistryValues.get(entryValue);\n  if (entry !== undefined) {\n    TaintRegistryPendingRequests.forEach(function (requestQueue) {\n      requestQueue.push(entryValue);\n      entry.count++;\n    });\n    if (entry.count === 1) {\n      TaintRegistryValues.delete(entryValue);\n    } else {\n      entry.count--;\n    }\n  }\n}\n\n// If FinalizationRegistry doesn't exist, we assume that objects life forever.\n// E.g. the whole VM is just the lifetime of a request.\nconst finalizationRegistry =\n  typeof FinalizationRegistry === 'function'\n    ? new FinalizationRegistry(cleanup)\n    : null;\n\nexport function taintUniqueValue(\n  message: ?string,\n  lifetime: Reference,\n  value: string | bigint | $ArrayBufferView,\n): void {\n  if (!enableTaint) {\n    throw new Error('Not implemented.');\n  }\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  message = '' + (message || defaultMessage);\n  if (\n    lifetime === null ||\n    (typeof lifetime !== 'object' && typeof lifetime !== 'function')\n  ) {\n    throw new Error(\n      'To taint a value, a lifetime must be defined by passing an object that holds ' +\n        'the value.',\n    );\n  }\n  let entryValue: string | bigint;\n  if (typeof value === 'string' || typeof value === 'bigint') {\n    // Use as is.\n    entryValue = value;\n  } else if (\n    value instanceof TypedArrayConstructor ||\n    value instanceof DataView\n  ) {\n    // For now, we just convert binary data to a string so that we can just use the native\n    // hashing in the Map implementation. It doesn't really matter what form the string\n    // take as long as it's the same when we look it up.\n    // We're not too worried about collisions since this should be a high entropy value.\n    TaintRegistryByteLengths.add(value.byteLength);\n    entryValue = binaryToComparableString(value);\n  } else {\n    const kind = value === null ? 'null' : typeof value;\n    if (kind === 'object' || kind === 'function') {\n      throw new Error(\n        'taintUniqueValue cannot taint objects or functions. Try taintObjectReference instead.',\n      );\n    }\n    throw new Error(\n      'Cannot taint a ' +\n        kind +\n        ' because the value is too general and not unique enough to block globally.',\n    );\n  }\n  const existingEntry = TaintRegistryValues.get(entryValue);\n  if (existingEntry === undefined) {\n    TaintRegistryValues.set(entryValue, {\n      message,\n      count: 1,\n    });\n  } else {\n    existingEntry.count++;\n  }\n  if (finalizationRegistry !== null) {\n    finalizationRegistry.register(lifetime, entryValue);\n  }\n}\n\nexport function taintObjectReference(\n  message: ?string,\n  object: Reference,\n): void {\n  if (!enableTaint) {\n    throw new Error('Not implemented.');\n  }\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  message = '' + (message || defaultMessage);\n  if (typeof object === 'string' || typeof object === 'bigint') {\n    throw new Error(\n      'Only objects or functions can be passed to taintObjectReference. Try taintUniqueValue instead.',\n    );\n  }\n  if (\n    object === null ||\n    (typeof object !== 'object' && typeof object !== 'function')\n  ) {\n    throw new Error(\n      'Only objects or functions can be passed to taintObjectReference.',\n    );\n  }\n  TaintRegistryObjects.set(object, message);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport {default as __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE} from './ReactSharedInternalsServer';\n\nimport {forEach, map, count, toArray, only} from './ReactChildren';\nimport {\n  REACT_FRAGMENT_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_VIEW_TRANSITION_TYPE,\n} from 'shared/ReactSymbols';\nimport {\n  cloneElement,\n  createElement,\n  isValidElement,\n} from './jsx/ReactJSXElement';\nimport {createRef} from './ReactCreateRef';\nimport {\n  use,\n  useId,\n  useCallback,\n  useDebugValue,\n  useMemo,\n  getCacheForType,\n} from './ReactHooks';\nimport {forwardRef} from './ReactForwardRef';\nimport {lazy} from './ReactLazy';\nimport {memo} from './ReactMemo';\nimport {cache, cacheSignal} from './ReactCacheServer';\nimport {startTransition} from './ReactStartTransition';\nimport {postpone} from './ReactPostpone';\nimport {captureOwnerStack} from './ReactOwnerStack';\nimport version from 'shared/ReactVersion';\n\nconst Children = {\n  map,\n  forEach,\n  count,\n  toArray,\n  only,\n};\n\n// These are server-only\nexport {\n  taintUniqueValue as experimental_taintUniqueValue,\n  taintObjectReference as experimental_taintObjectReference,\n} from './ReactTaint';\n\nexport {\n  Children,\n  REACT_FRAGMENT_TYPE as Fragment,\n  REACT_PROFILER_TYPE as Profiler,\n  REACT_STRICT_MODE_TYPE as StrictMode,\n  REACT_SUSPENSE_TYPE as Suspense,\n  cloneElement,\n  createElement,\n  createRef,\n  use,\n  forwardRef,\n  isValidElement,\n  lazy,\n  memo,\n  cache,\n  cacheSignal,\n  startTransition,\n  getCacheForType as unstable_getCacheForType,\n  postpone as unstable_postpone,\n  useId,\n  useCallback,\n  useDebugValue,\n  useMemo,\n  version,\n  // Experimental\n  REACT_SUSPENSE_LIST_TYPE as unstable_SuspenseList,\n  REACT_VIEW_TRANSITION_TYPE as unstable_ViewTransition,\n  captureOwnerStack, // DEV-only\n};\n"],"names":["TaintRegistryObjects","WeakMap","TaintRegistryValues","Map","TaintRegistryByteLengths","Set","TaintRegistryPendingRequests","ownerStackLimit","ReactSharedInternals","H","A","getCurrentStack","recentlyCreatedOwnerStacks","isArrayImpl","Array","isArray","a","noop","REACT_ELEMENT_TYPE","Symbol","for","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_CONSUMER_TYPE","REACT_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_ACTIVITY_TYPE","REACT_POSTPONE_TYPE","REACT_VIEW_TRANSITION_TYPE","MAYBE_ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","typeName","value","hasToStringTag","toStringTag","type","constructor","name","willCoercionThrow","testStringCoercion","e","checkKeyStringCoercion","console","error","getWrappedName","outerType","innerType","wrapperName","displayName","functionName","getContextName","REACT_CLIENT_REFERENCE","getComponentNameFromType","$$typeof","tag","context","consumer","_context","render","outerName","lazyComponent","payload","_payload","init","_init","x","hasOwnProperty","Object","prototype","assign","createTask","getTaskName","getOwner","dispatcher","UnknownOwner","Error","createFakeCallStack","react_stack_bottom_frame","callStackForError","specialPropKeyWarningShown","didWarnAboutElementRef","didWarnAboutOldJSXRuntime","unknownOwnerDebugStack","unknownOwnerDebugTask","bind","hasValidRef","config","call","getter","getOwnPropertyDescriptor","get","isReactWarning","ref","undefined","hasValidKey","key","defineKeyPropWarningGetter","props","warnAboutAccessingKey","defineProperty","configurable","elementRefGetterWithDeprecationWarning","componentName","refProp","ReactElement","self","source","owner","debugStack","debugTask","element","_owner","enumerable","_store","writable","freeze","createElement","children","i","arguments","length","validateChildKeys","propName","warn","childrenLength","childArray","defaultProps","trackActualOwner","cloneAndReplaceKey","oldElement","newKey","clonedElement","_debugStack","_debugTask","validated","cloneElement","node","parentType","isValidElement","object","SEPARATOR","SUBSEPARATOR","escape","escapeRegex","escaperLookup","escapedString","replace","match","didWarnAboutMaps","userProvidedKeyEscapeRegex","escapeUserProvidedKey","text","getElementKey","index","toString","resolveThenable","thenable","status","fulfilledValue","rejectedError","reason","then","pendingThenable","fulfilledThenable","rejectedThenable","mapIntoArray","array","escapedPrefix","nameSoFar","callback","invokeCallback","child","mappedChild","childKey","escapedChildKey","c","newChild","push","nextName","subtreeCount","nextNamePrefix","iteratorFn","iterableChildren","entries","step","ii","next","done","childrenString","String","keys","join","mapChildren","func","result","count","countChildren","n","forEachChildren","forEachFunc","forEachContext","apply","toArray","onlyChild","createRef","refObject","current","seal","resolveDispatcher","getCacheForType","resourceType","useCallback","deps","useMemo","create","useDebugValue","formatterFn","useId","use","usable","forwardRef","elementType","ownName","set","Uninitialized","Pending","Resolved","Rejected","lazyInitializer","_status","ctor","_result","moduleObject","resolved","rejected","pending","default","lazy","lazyType","memo","compare","UNTERMINATED","TERMINATED","ERRORED","createCacheRoot","createCacheNode","s","v","o","p","cache","fn","fnMap","fnNode","cacheNode","l","arg","objectCache","objectNode","primitiveCache","primitiveNode","terminatedNode","erroredNode","cacheSignal","reportGlobalError","reportError","window","ErrorEvent","message","event","bubbles","cancelable","shouldLog","dispatchEvent","process","emit","releaseAsyncTransition","asyncTransitions","startTransition","scope","options","prevTransition","T","currentTransition","types","gesture","_updatedFibers","returnValue","onStartTransitionFinish","S","__DEV__","warnAboutTransitionSubscriptions","updatedFibersCount","size","clear","postpone","postponeInstance","captureOwnerStack","getPrototypeOf","binaryToComparableString","view","fromCharCode","Uint8Array","buffer","byteOffset","byteLength","TypedArrayConstructor","Uint32Array","defaultMessage","cleanup","entryValue","entry","forEach","requestQueue","delete","finalizationRegistry","FinalizationRegistry","taintUniqueValue","lifetime","DataView","add","kind","existingEntry","register","taintObjectReference","Children","map","only"],"mappings":"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"}
\ No newline at end of file
diff --git a/cjs/react.react-server.production.js b/cjs/react.react-server.production.js
index c7771124ce19178666bdb0fddc8bad74e4db3d07..b0095ca79f6acda85cf013204c14832a681271f2 100644
--- a/cjs/react.react-server.production.js
+++ b/cjs/react.react-server.production.js
@@ -1,429 +1,971 @@
+'use strict';
+
+const TaintRegistryObjects$1 = new WeakMap();
+const TaintRegistryValues$1 = new Map();
+// Byte lengths of all binary values we've ever seen. We don't both refcounting this.
+// We expect to see only a few lengths here such as the length of token.
+const TaintRegistryByteLengths$1 = new Set();
+
+// When a value is finalized, it means that it has been removed from any global caches.
+// No future requests can get a handle on it but any ongoing requests can still have
+// a handle on it. It's still tainted until that happens.
+
+const TaintRegistryPendingRequests$1 = new Set();
+
+const ReactSharedInternals = {
+  H: null,
+  A: null
+};
+{
+  ReactSharedInternals.TaintRegistryObjects = TaintRegistryObjects$1;
+  ReactSharedInternals.TaintRegistryValues = TaintRegistryValues$1;
+  ReactSharedInternals.TaintRegistryByteLengths = TaintRegistryByteLengths$1;
+  ReactSharedInternals.TaintRegistryPendingRequests = TaintRegistryPendingRequests$1;
+}
+
+// Do not require this module directly! Use normal `invariant` calls with
+// template literal strings. The messages will be replaced with error codes
+// during build.
+
+function formatProdErrorMessage(code) {
+  let url = 'https://react.dev/errors/' + code;
+  if (arguments.length > 1) {
+    url += '?args[]=' + encodeURIComponent(arguments[1]);
+    for (let i = 2; i < arguments.length; i++) {
+      url += '&args[]=' + encodeURIComponent(arguments[i]);
+    }
+  }
+  return "Minified React error #" + code + "; visit " + url + " for the full message or " + 'use the non-minified dev environment for full errors and additional ' + 'helpful warnings.';
+}
+
+const isArrayImpl = Array.isArray;
+function isArray(a) {
+  return isArrayImpl(a);
+}
+
+function noop() {}
+
+const REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element') ;
+const REACT_PORTAL_TYPE = Symbol.for('react.portal');
+const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
+const REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
+const REACT_PROFILER_TYPE = Symbol.for('react.profiler');
+const REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
+const REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
+const REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
+const REACT_MEMO_TYPE = Symbol.for('react.memo');
+const REACT_LAZY_TYPE = Symbol.for('react.lazy');
+const REACT_ACTIVITY_TYPE = Symbol.for('react.activity');
+const REACT_POSTPONE_TYPE = Symbol.for('react.postpone');
+const REACT_VIEW_TRANSITION_TYPE = Symbol.for('react.view_transition');
+const MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
+const FAUX_ITERATOR_SYMBOL = '@@iterator';
+function getIteratorFn(maybeIterable) {
+  if (maybeIterable === null || typeof maybeIterable !== 'object') {
+    return null;
+  }
+  const maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
+  if (typeof maybeIterator === 'function') {
+    return maybeIterator;
+  }
+  return null;
+}
+
+// $FlowFixMe[method-unbinding]
+const hasOwnProperty = Object.prototype.hasOwnProperty;
+
+const assign = Object.assign;
+
+function getOwner() {
+  return null;
+}
+function hasValidRef(config) {
+  return config.ref !== undefined;
+}
+function hasValidKey(config) {
+  return config.key !== undefined;
+}
+
 /**
- * @license React
- * react.react-server.production.js
- *
- * Copyright (c) Meta Platforms, Inc. and affiliates.
+ * Factory method to create a new React element. This no longer adheres to
+ * the class pattern, so do not use new to call it. Also, instanceof check
+ * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check
+ * if something is a React Element.
  *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
+ * @param {*} type
+ * @param {*} props
+ * @param {*} key
+ * @param {string|object} ref
+ * @param {*} owner
+ * @param {*} self A *temporary* helper to detect places where `this` is
+ * different from the `owner` when React.createElement is called, so that we
+ * can warn. We want to get rid of owner and replace string `ref`s with arrow
+ * functions, and as long as `this` and owner are the same, there will be no
+ * change in behavior.
+ * @param {*} source An annotation object (added by a transpiler or otherwise)
+ * indicating filename, line number, and/or other information.
+ * @internal
  */
+function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
+  // Ignore whatever was passed as the ref argument and treat `props.ref` as
+  // the source of truth. The only thing we use this for is `element.ref`,
+  // which will log a deprecation warning on access. In the next release, we
+  // can remove `element.ref` as well as the `ref` argument.
+  const refProp = props.ref;
 
-"use strict";
-var ReactSharedInternals = { H: null, A: null };
-function formatProdErrorMessage(code) {
-  var url = "https://react.dev/errors/" + code;
-  if (1 < arguments.length) {
-    url += "?args[]=" + encodeURIComponent(arguments[1]);
-    for (var i = 2; i < arguments.length; i++)
-      url += "&args[]=" + encodeURIComponent(arguments[i]);
-  }
-  return (
-    "Minified React error #" +
-    code +
-    "; visit " +
-    url +
-    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
-  );
-}
-var isArrayImpl = Array.isArray,
-  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
-  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
-  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
-  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
-  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
-  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
-  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
-  REACT_MEMO_TYPE = Symbol.for("react.memo"),
-  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
-  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
-function getIteratorFn(maybeIterable) {
-  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
-  maybeIterable =
-    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
-    maybeIterable["@@iterator"];
-  return "function" === typeof maybeIterable ? maybeIterable : null;
-}
-var hasOwnProperty = Object.prototype.hasOwnProperty,
-  assign = Object.assign;
-function ReactElement(type, key, self, source, owner, props) {
-  self = props.ref;
-  return {
-    $$typeof: REACT_ELEMENT_TYPE,
-    type: type,
-    key: key,
-    ref: void 0 !== self ? self : null,
-    props: props
-  };
+  // An undefined `element.ref` is coerced to `null` for
+  // backwards compatibility.
+  const ref = refProp !== undefined ? refProp : null;
+  let element;
+  {
+    // In prod, `ref` is a regular property and _owner doesn't exist.
+    element = {
+      // This tag allows us to uniquely identify this as a React Element
+      $$typeof: REACT_ELEMENT_TYPE,
+      // Built-in properties that belong on the element
+      type,
+      key,
+      ref,
+      props
+    };
+  }
+  return element;
+}
+
+/**
+ * Create and return a new ReactElement of the given type.
+ * See https://reactjs.org/docs/react-api.html#createelement
+ */
+function createElement(type, config, children) {
+  let propName;
+
+  // Reserved names are extracted
+  const props = {};
+  let key = null;
+  if (config != null) {
+    if (hasValidKey(config)) {
+      key = '' + config.key;
+    }
+
+    // Remaining properties are added to a new props object
+    for (propName in config) {
+      if (hasOwnProperty.call(config, propName) &&
+      // Skip over reserved prop names
+      propName !== 'key' &&
+      // Even though we don't use these anymore in the runtime, we don't want
+      // them to appear as props, so in createElement we filter them out.
+      // We don't have to do this in the jsx() runtime because the jsx()
+      // transform never passed these as props; it used separate arguments.
+      propName !== '__self' && propName !== '__source') {
+        props[propName] = config[propName];
+      }
+    }
+  }
+
+  // Children can be more than one argument, and those are transferred onto
+  // the newly allocated props object.
+  const childrenLength = arguments.length - 2;
+  if (childrenLength === 1) {
+    props.children = children;
+  } else if (childrenLength > 1) {
+    const childArray = Array(childrenLength);
+    for (let i = 0; i < childrenLength; i++) {
+      childArray[i] = arguments[i + 2];
+    }
+    props.children = childArray;
+  }
+
+  // Resolve default props
+  if (type && type.defaultProps) {
+    const defaultProps = type.defaultProps;
+    for (propName in defaultProps) {
+      if (props[propName] === undefined) {
+        props[propName] = defaultProps[propName];
+      }
+    }
+  }
+  return ReactElement(type, key, undefined, undefined, getOwner(), props);
 }
 function cloneAndReplaceKey(oldElement, newKey) {
-  return ReactElement(
-    oldElement.type,
-    newKey,
-    void 0,
-    void 0,
-    void 0,
-    oldElement.props
-  );
+  const clonedElement = ReactElement(oldElement.type, newKey, undefined, undefined, undefined , oldElement.props);
+  return clonedElement;
+}
+
+/**
+ * Clone and return a new ReactElement using element as the starting point.
+ * See https://reactjs.org/docs/react-api.html#cloneelement
+ */
+function cloneElement(element, config, children) {
+  if (element === null || element === undefined) {
+    throw Error(formatProdErrorMessage(267, element));
+  }
+  let propName;
+
+  // Original props are copied
+  const props = assign({}, element.props);
+
+  // Reserved names are extracted
+  let key = element.key;
+
+  // Owner will be preserved, unless ref is overridden
+  let owner = undefined ;
+  if (config != null) {
+    if (hasValidRef(config)) {
+      owner = undefined;
+    }
+    if (hasValidKey(config)) {
+      key = '' + config.key;
+    }
+
+    // Remaining properties override existing props
+    for (propName in config) {
+      if (hasOwnProperty.call(config, propName) &&
+      // Skip over reserved prop names
+      propName !== 'key' &&
+      // ...and maybe these, too, though we currently rely on them for
+      // warnings and debug information in dev. Need to decide if we're OK
+      // with dropping them. In the jsx() runtime it's not an issue because
+      // the data gets passed as separate arguments instead of props, but
+      // it would be nice to stop relying on them entirely so we can drop
+      // them from the internal Fiber field.
+      propName !== '__self' && propName !== '__source' &&
+      // Undefined `ref` is ignored by cloneElement. We treat it the same as
+      // if the property were missing. This is mostly for
+      // backwards compatibility.
+      !(propName === 'ref' && config.ref === undefined)) {
+        props[propName] = config[propName];
+      }
+    }
+  }
+
+  // Children can be more than one argument, and those are transferred onto
+  // the newly allocated props object.
+  const childrenLength = arguments.length - 2;
+  if (childrenLength === 1) {
+    props.children = children;
+  } else if (childrenLength > 1) {
+    const childArray = Array(childrenLength);
+    for (let i = 0; i < childrenLength; i++) {
+      childArray[i] = arguments[i + 2];
+    }
+    props.children = childArray;
+  }
+  const clonedElement = ReactElement(element.type, key, undefined, undefined, owner, props);
+  return clonedElement;
 }
+
+/**
+ * Verifies the object is a ReactElement.
+ * See https://reactjs.org/docs/react-api.html#isvalidelement
+ * @param {?object} object
+ * @return {boolean} True if `object` is a ReactElement.
+ * @final
+ */
 function isValidElement(object) {
-  return (
-    "object" === typeof object &&
-    null !== object &&
-    object.$$typeof === REACT_ELEMENT_TYPE
-  );
+  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
 }
+
+const SEPARATOR = '.';
+const SUBSEPARATOR = ':';
+
+/**
+ * Escape and wrap key so it is safe to use as a reactid
+ *
+ * @param {string} key to be escaped.
+ * @return {string} the escaped key.
+ */
 function escape(key) {
-  var escaperLookup = { "=": "=0", ":": "=2" };
-  return (
-    "$" +
-    key.replace(/[=:]/g, function (match) {
-      return escaperLookup[match];
-    })
-  );
-}
-var userProvidedKeyEscapeRegex = /\/+/g;
+  const escapeRegex = /[=:]/g;
+  const escaperLookup = {
+    '=': '=0',
+    ':': '=2'
+  };
+  const escapedString = key.replace(escapeRegex, function (match) {
+    // $FlowFixMe[invalid-computed-prop]
+    return escaperLookup[match];
+  });
+  return '$' + escapedString;
+}
+const userProvidedKeyEscapeRegex = /\/+/g;
+function escapeUserProvidedKey(text) {
+  return text.replace(userProvidedKeyEscapeRegex, '$&/');
+}
+
+/**
+ * Generate a key string that identifies a element within a set.
+ *
+ * @param {*} element A element that could contain a manual key.
+ * @param {number} index Index that is used if a manual key is not provided.
+ * @return {string}
+ */
 function getElementKey(element, index) {
-  return "object" === typeof element && null !== element && null != element.key
-    ? escape("" + element.key)
-    : index.toString(36);
+  // Do some typechecking here since we call this blindly. We want to ensure
+  // that we don't block potential future ES APIs.
+  if (typeof element === 'object' && element !== null && element.key != null) {
+    return escape('' + element.key);
+  }
+  // Implicit key determined by the index in the set
+  return index.toString(36);
 }
-function noop() {}
 function resolveThenable(thenable) {
   switch (thenable.status) {
-    case "fulfilled":
-      return thenable.value;
-    case "rejected":
-      throw thenable.reason;
+    case 'fulfilled':
+      {
+        const fulfilledValue = thenable.value;
+        return fulfilledValue;
+      }
+    case 'rejected':
+      {
+        const rejectedError = thenable.reason;
+        throw rejectedError;
+      }
     default:
-      switch (
-        ("string" === typeof thenable.status
-          ? thenable.then(noop, noop)
-          : ((thenable.status = "pending"),
-            thenable.then(
-              function (fulfilledValue) {
-                "pending" === thenable.status &&
-                  ((thenable.status = "fulfilled"),
-                  (thenable.value = fulfilledValue));
-              },
-              function (error) {
-                "pending" === thenable.status &&
-                  ((thenable.status = "rejected"), (thenable.reason = error));
-              }
-            )),
-        thenable.status)
-      ) {
-        case "fulfilled":
-          return thenable.value;
-        case "rejected":
-          throw thenable.reason;
+      {
+        if (typeof thenable.status === 'string') {
+          // Only instrument the thenable if the status if not defined. If
+          // it's defined, but an unknown value, assume it's been instrumented by
+          // some custom userspace implementation. We treat it as "pending".
+          // Attach a dummy listener, to ensure that any lazy initialization can
+          // happen. Flight lazily parses JSON when the value is actually awaited.
+          thenable.then(noop, noop);
+        } else {
+          // This is an uncached thenable that we haven't seen before.
+
+          // TODO: Detect infinite ping loops caused by uncached promises.
+
+          const pendingThenable = thenable;
+          pendingThenable.status = 'pending';
+          pendingThenable.then(fulfilledValue => {
+            if (thenable.status === 'pending') {
+              const fulfilledThenable = thenable;
+              fulfilledThenable.status = 'fulfilled';
+              fulfilledThenable.value = fulfilledValue;
+            }
+          }, error => {
+            if (thenable.status === 'pending') {
+              const rejectedThenable = thenable;
+              rejectedThenable.status = 'rejected';
+              rejectedThenable.reason = error;
+            }
+          });
+        }
+
+        // Check one more time in case the thenable resolved synchronously.
+        switch (thenable.status) {
+          case 'fulfilled':
+            {
+              const fulfilledThenable = thenable;
+              return fulfilledThenable.value;
+            }
+          case 'rejected':
+            {
+              const rejectedThenable = thenable;
+              const rejectedError = rejectedThenable.reason;
+              throw rejectedError;
+            }
+        }
       }
   }
   throw thenable;
 }
 function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
-  var type = typeof children;
-  if ("undefined" === type || "boolean" === type) children = null;
-  var invokeCallback = !1;
-  if (null === children) invokeCallback = !0;
-  else
+  const type = typeof children;
+  if (type === 'undefined' || type === 'boolean') {
+    // All of the above are perceived as null.
+    children = null;
+  }
+  let invokeCallback = false;
+  if (children === null) {
+    invokeCallback = true;
+  } else {
     switch (type) {
-      case "bigint":
-      case "string":
-      case "number":
-        invokeCallback = !0;
+      case 'bigint':
+      case 'string':
+      case 'number':
+        invokeCallback = true;
         break;
-      case "object":
+      case 'object':
         switch (children.$$typeof) {
           case REACT_ELEMENT_TYPE:
           case REACT_PORTAL_TYPE:
-            invokeCallback = !0;
+            invokeCallback = true;
             break;
           case REACT_LAZY_TYPE:
-            return (
-              (invokeCallback = children._init),
-              mapIntoArray(
-                invokeCallback(children._payload),
-                array,
-                escapedPrefix,
-                nameSoFar,
-                callback
-              )
-            );
+            const payload = children._payload;
+            const init = children._init;
+            return mapIntoArray(init(payload), array, escapedPrefix, nameSoFar, callback);
         }
     }
-  if (invokeCallback)
-    return (
-      (callback = callback(children)),
-      (invokeCallback =
-        "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),
-      isArrayImpl(callback)
-        ? ((escapedPrefix = ""),
-          null != invokeCallback &&
-            (escapedPrefix =
-              invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
-          mapIntoArray(callback, array, escapedPrefix, "", function (c) {
-            return c;
-          }))
-        : null != callback &&
-          (isValidElement(callback) &&
-            (callback = cloneAndReplaceKey(
-              callback,
-              escapedPrefix +
-                (null == callback.key ||
-                (children && children.key === callback.key)
-                  ? ""
-                  : ("" + callback.key).replace(
-                      userProvidedKeyEscapeRegex,
-                      "$&/"
-                    ) + "/") +
-                invokeCallback
-            )),
-          array.push(callback)),
-      1
-    );
-  invokeCallback = 0;
-  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
-  if (isArrayImpl(children))
-    for (var i = 0; i < children.length; i++)
-      (nameSoFar = children[i]),
-        (type = nextNamePrefix + getElementKey(nameSoFar, i)),
-        (invokeCallback += mapIntoArray(
-          nameSoFar,
-          array,
-          escapedPrefix,
-          type,
-          callback
-        ));
-  else if (((i = getIteratorFn(children)), "function" === typeof i))
-    for (
-      children = i.call(children), i = 0;
-      !(nameSoFar = children.next()).done;
-
-    )
-      (nameSoFar = nameSoFar.value),
-        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),
-        (invokeCallback += mapIntoArray(
-          nameSoFar,
-          array,
-          escapedPrefix,
-          type,
-          callback
-        ));
-  else if ("object" === type) {
-    if ("function" === typeof children.then)
-      return mapIntoArray(
-        resolveThenable(children),
-        array,
-        escapedPrefix,
-        nameSoFar,
-        callback
-      );
-    array = String(children);
-    throw Error(
-      formatProdErrorMessage(
-        31,
-        "[object Object]" === array
-          ? "object with keys {" + Object.keys(children).join(", ") + "}"
-          : array
-      )
-    );
-  }
-  return invokeCallback;
+  }
+  if (invokeCallback) {
+    const child = children;
+    let mappedChild = callback(child);
+    // If it's the only child, treat the name as if it was wrapped in an array
+    // so that it's consistent if the number of children grows:
+    const childKey = nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;
+    if (isArray(mappedChild)) {
+      let escapedChildKey = '';
+      if (childKey != null) {
+        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
+      }
+      mapIntoArray(mappedChild, array, escapedChildKey, '', c => c);
+    } else if (mappedChild != null) {
+      if (isValidElement(mappedChild)) {
+        const newChild = cloneAndReplaceKey(mappedChild,
+        // Keep both the (mapped) and old keys if they differ, just as
+        // traverseAllChildren used to do for objects as children
+        escapedPrefix + (
+        // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key
+        mappedChild.key != null && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(
+        // $FlowFixMe[unsafe-addition]
+        '' + mappedChild.key // eslint-disable-line react-internal/safe-string-coercion
+        ) + '/' : '') + childKey);
+        mappedChild = newChild;
+      }
+      array.push(mappedChild);
+    }
+    return 1;
+  }
+  let child;
+  let nextName;
+  let subtreeCount = 0; // Count of children found in the current subtree.
+  const nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
+  if (isArray(children)) {
+    for (let i = 0; i < children.length; i++) {
+      child = children[i];
+      nextName = nextNamePrefix + getElementKey(child, i);
+      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
+    }
+  } else {
+    const iteratorFn = getIteratorFn(children);
+    if (typeof iteratorFn === 'function') {
+      const iterableChildren = children;
+      const iterator = iteratorFn.call(iterableChildren);
+      let step;
+      let ii = 0;
+      // $FlowFixMe[incompatible-use] `iteratorFn` might return null according to typing.
+      while (!(step = iterator.next()).done) {
+        child = step.value;
+        nextName = nextNamePrefix + getElementKey(child, ii++);
+        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
+      }
+    } else if (type === 'object') {
+      if (typeof children.then === 'function') {
+        return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
+      }
+
+      // eslint-disable-next-line react-internal/safe-string-coercion
+      const childrenString = String(children);
+      throw Error(formatProdErrorMessage(31, childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString));
+    }
+  }
+  return subtreeCount;
 }
+
+/**
+ * Maps children that are typically specified as `props.children`.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrenmap
+ *
+ * The provided mapFunction(child, index) will be called for each
+ * leaf child.
+ *
+ * @param {?*} children Children tree container.
+ * @param {function(*, int)} func The map function.
+ * @param {*} context Context for mapFunction.
+ * @return {object} Object containing the ordered map of results.
+ */
 function mapChildren(children, func, context) {
-  if (null == children) return children;
-  var result = [],
-    count = 0;
-  mapIntoArray(children, result, "", "", function (child) {
+  if (children == null) {
+    // $FlowFixMe limitation refining abstract types in Flow
+    return children;
+  }
+  const result = [];
+  let count = 0;
+  mapIntoArray(children, result, '', '', function (child) {
     return func.call(context, child, count++);
   });
   return result;
 }
+
+/**
+ * Count the number of children that are typically specified as
+ * `props.children`.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrencount
+ *
+ * @param {?*} children Children tree container.
+ * @return {number} The number of children.
+ */
+function countChildren(children) {
+  let n = 0;
+  mapChildren(children, () => {
+    n++;
+    // Don't return anything
+  });
+  return n;
+}
+
+/**
+ * Iterates through children that are typically specified as `props.children`.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
+ *
+ * The provided forEachFunc(child, index) will be called for each
+ * leaf child.
+ *
+ * @param {?*} children Children tree container.
+ * @param {function(*, int)} forEachFunc
+ * @param {*} forEachContext Context for forEachContext.
+ */
+function forEachChildren(children, forEachFunc, forEachContext) {
+  mapChildren(children,
+  // $FlowFixMe[missing-this-annot]
+  function () {
+    forEachFunc.apply(this, arguments);
+    // Don't return anything.
+  }, forEachContext);
+}
+
+/**
+ * Flatten a children object (typically specified as `props.children`) and
+ * return an array with appropriately re-keyed children.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
+ */
+function toArray(children) {
+  return mapChildren(children, child => child) || [];
+}
+
+/**
+ * Returns the first child in a collection of children and verifies that there
+ * is only one child in the collection.
+ *
+ * See https://reactjs.org/docs/react-api.html#reactchildrenonly
+ *
+ * The current implementation of this function assumes that a single child gets
+ * passed without a wrapper, but the purpose of this helper function is to
+ * abstract away the particular structure of children.
+ *
+ * @param {?object} children Child collection structure.
+ * @return {ReactElement} The first and only `ReactElement` contained in the
+ * structure.
+ */
+function onlyChild(children) {
+  if (!isValidElement(children)) {
+    throw Error(formatProdErrorMessage(143));
+  }
+  return children;
+}
+
+// an immutable object with a single mutable value
+function createRef() {
+  const refObject = {
+    current: null
+  };
+  return refObject;
+}
+
+function resolveDispatcher() {
+  const dispatcher = ReactSharedInternals.H;
+  // Will result in a null access error if accessed outside render phase. We
+  // intentionally don't throw our own error because this is in a hot path.
+  // Also helps ensure this is inlined.
+  return dispatcher;
+}
+function getCacheForType(resourceType) {
+  const dispatcher = ReactSharedInternals.A;
+  if (!dispatcher) {
+    // If there is no dispatcher, then we treat this as not being cached.
+    return resourceType();
+  }
+  return dispatcher.getCacheForType(resourceType);
+}
+function useCallback(callback, deps) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useCallback(callback, deps);
+}
+function useMemo(create, deps) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useMemo(create, deps);
+}
+function useDebugValue(value, formatterFn) {
+}
+function useId() {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.useId();
+}
+function use(usable) {
+  const dispatcher = resolveDispatcher();
+  return dispatcher.use(usable);
+}
+
+function forwardRef(render) {
+  const elementType = {
+    $$typeof: REACT_FORWARD_REF_TYPE,
+    render
+  };
+  return elementType;
+}
+
+const Uninitialized = -1;
+const Pending = 0;
+const Resolved = 1;
+const Rejected = 2;
 function lazyInitializer(payload) {
-  if (-1 === payload._status) {
-    var ctor = payload._result;
-    ctor = ctor();
-    ctor.then(
-      function (moduleObject) {
-        if (0 === payload._status || -1 === payload._status)
-          (payload._status = 1), (payload._result = moduleObject);
-      },
-      function (error) {
-        if (0 === payload._status || -1 === payload._status)
-          (payload._status = 2), (payload._result = error);
+  if (payload._status === Uninitialized) {
+    const ctor = payload._result;
+    const thenable = ctor();
+    // Transition to the next state.
+    // This might throw either because it's missing or throws. If so, we treat it
+    // as still uninitialized and try again next time. Which is the same as what
+    // happens if the ctor or any wrappers processing the ctor throws. This might
+    // end up fixing it if the resolution was a concurrency bug.
+    thenable.then(moduleObject => {
+      if (payload._status === Pending || payload._status === Uninitialized) {
+        // Transition to the next state.
+        const resolved = payload;
+        resolved._status = Resolved;
+        resolved._result = moduleObject;
       }
-    );
-    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));
+    }, error => {
+      if (payload._status === Pending || payload._status === Uninitialized) {
+        // Transition to the next state.
+        const rejected = payload;
+        rejected._status = Rejected;
+        rejected._result = error;
+      }
+    });
+    if (payload._status === Uninitialized) {
+      // In case, we're still uninitialized, then we're waiting for the thenable
+      // to resolve. Set it as pending in the meantime.
+      const pending = payload;
+      pending._status = Pending;
+      pending._result = thenable;
+    }
+  }
+  if (payload._status === Resolved) {
+    const moduleObject = payload._result;
+    return moduleObject.default;
+  } else {
+    throw payload._result;
   }
-  if (1 === payload._status) return payload._result.default;
-  throw payload._result;
 }
+function lazy(ctor) {
+  const payload = {
+    // We use these fields to store the result.
+    _status: Uninitialized,
+    _result: ctor
+  };
+  const lazyType = {
+    $$typeof: REACT_LAZY_TYPE,
+    _payload: payload,
+    _init: lazyInitializer
+  };
+  return lazyType;
+}
+
+function memo(type, compare) {
+  const elementType = {
+    $$typeof: REACT_MEMO_TYPE,
+    type,
+    compare: compare === undefined ? null : compare
+  };
+  return elementType;
+}
+
+const UNTERMINATED = 0;
+const TERMINATED = 1;
+const ERRORED = 2;
 function createCacheRoot() {
   return new WeakMap();
 }
 function createCacheNode() {
-  return { s: 0, v: void 0, o: null, p: null };
+  return {
+    s: UNTERMINATED,
+    // status, represents whether the cached computation returned a value or threw an error
+    v: undefined,
+    // value, either the cached result or an error, depending on s
+    o: null,
+    // object cache, a WeakMap where non-primitive arguments are stored
+    p: null // primitive cache, a regular Map where primitive arguments are stored.
+  };
 }
-exports.Children = {
-  map: mapChildren,
-  forEach: function (children, forEachFunc, forEachContext) {
-    mapChildren(
-      children,
-      function () {
-        forEachFunc.apply(this, arguments);
-      },
-      forEachContext
-    );
-  },
-  count: function (children) {
-    var n = 0;
-    mapChildren(children, function () {
-      n++;
-    });
-    return n;
-  },
-  toArray: function (children) {
-    return (
-      mapChildren(children, function (child) {
-        return child;
-      }) || []
-    );
-  },
-  only: function (children) {
-    if (!isValidElement(children)) throw Error(formatProdErrorMessage(143));
-    return children;
-  }
-};
-exports.Fragment = REACT_FRAGMENT_TYPE;
-exports.Profiler = REACT_PROFILER_TYPE;
-exports.StrictMode = REACT_STRICT_MODE_TYPE;
-exports.Suspense = REACT_SUSPENSE_TYPE;
-exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
-  ReactSharedInternals;
-exports.cache = function (fn) {
+function cache(fn) {
   return function () {
-    var dispatcher = ReactSharedInternals.A;
-    if (!dispatcher) return fn.apply(null, arguments);
-    var fnMap = dispatcher.getCacheForType(createCacheRoot);
-    dispatcher = fnMap.get(fn);
-    void 0 === dispatcher &&
-      ((dispatcher = createCacheNode()), fnMap.set(fn, dispatcher));
-    fnMap = 0;
-    for (var l = arguments.length; fnMap < l; fnMap++) {
-      var arg = arguments[fnMap];
-      if (
-        "function" === typeof arg ||
-        ("object" === typeof arg && null !== arg)
-      ) {
-        var objectCache = dispatcher.o;
-        null === objectCache && (dispatcher.o = objectCache = new WeakMap());
-        dispatcher = objectCache.get(arg);
-        void 0 === dispatcher &&
-          ((dispatcher = createCacheNode()), objectCache.set(arg, dispatcher));
-      } else
-        (objectCache = dispatcher.p),
-          null === objectCache && (dispatcher.p = objectCache = new Map()),
-          (dispatcher = objectCache.get(arg)),
-          void 0 === dispatcher &&
-            ((dispatcher = createCacheNode()),
-            objectCache.set(arg, dispatcher));
+    const dispatcher = ReactSharedInternals.A;
+    if (!dispatcher) {
+      // If there is no dispatcher, then we treat this as not being cached.
+      // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.
+      return fn.apply(null, arguments);
+    }
+    const fnMap = dispatcher.getCacheForType(createCacheRoot);
+    const fnNode = fnMap.get(fn);
+    let cacheNode;
+    if (fnNode === undefined) {
+      cacheNode = createCacheNode();
+      fnMap.set(fn, cacheNode);
+    } else {
+      cacheNode = fnNode;
+    }
+    for (let i = 0, l = arguments.length; i < l; i++) {
+      const arg = arguments[i];
+      if (typeof arg === 'function' || typeof arg === 'object' && arg !== null) {
+        // Objects go into a WeakMap
+        let objectCache = cacheNode.o;
+        if (objectCache === null) {
+          cacheNode.o = objectCache = new WeakMap();
+        }
+        const objectNode = objectCache.get(arg);
+        if (objectNode === undefined) {
+          cacheNode = createCacheNode();
+          objectCache.set(arg, cacheNode);
+        } else {
+          cacheNode = objectNode;
+        }
+      } else {
+        // Primitives go into a regular Map
+        let primitiveCache = cacheNode.p;
+        if (primitiveCache === null) {
+          cacheNode.p = primitiveCache = new Map();
+        }
+        const primitiveNode = primitiveCache.get(arg);
+        if (primitiveNode === undefined) {
+          cacheNode = createCacheNode();
+          primitiveCache.set(arg, cacheNode);
+        } else {
+          cacheNode = primitiveNode;
+        }
+      }
+    }
+    if (cacheNode.s === TERMINATED) {
+      return cacheNode.v;
+    }
+    if (cacheNode.s === ERRORED) {
+      throw cacheNode.v;
     }
-    if (1 === dispatcher.s) return dispatcher.v;
-    if (2 === dispatcher.s) throw dispatcher.v;
     try {
-      var result = fn.apply(null, arguments);
-      fnMap = dispatcher;
-      fnMap.s = 1;
-      return (fnMap.v = result);
+      // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.
+      const result = fn.apply(null, arguments);
+      const terminatedNode = cacheNode;
+      terminatedNode.s = TERMINATED;
+      terminatedNode.v = result;
+      return result;
     } catch (error) {
-      throw ((result = dispatcher), (result.s = 2), (result.v = error), error);
+      // We store the first error that's thrown and rethrow it.
+      const erroredNode = cacheNode;
+      erroredNode.s = ERRORED;
+      erroredNode.v = error;
+      throw error;
     }
   };
-};
-exports.captureOwnerStack = function () {
-  return null;
-};
-exports.cloneElement = function (element, config, children) {
-  if (null === element || void 0 === element)
-    throw Error(formatProdErrorMessage(267, element));
-  var props = assign({}, element.props),
-    key = element.key,
-    owner = void 0;
-  if (null != config)
-    for (propName in (void 0 !== config.ref && (owner = void 0),
-    void 0 !== config.key && (key = "" + config.key),
-    config))
-      !hasOwnProperty.call(config, propName) ||
-        "key" === propName ||
-        "__self" === propName ||
-        "__source" === propName ||
-        ("ref" === propName && void 0 === config.ref) ||
-        (props[propName] = config[propName]);
-  var propName = arguments.length - 2;
-  if (1 === propName) props.children = children;
-  else if (1 < propName) {
-    for (var childArray = Array(propName), i = 0; i < propName; i++)
-      childArray[i] = arguments[i + 2];
-    props.children = childArray;
+}
+function cacheSignal() {
+  const dispatcher = ReactSharedInternals.A;
+  if (!dispatcher) {
+    // If there is no dispatcher, then we treat this as not having an AbortSignal
+    // since in the same context, a cached function will be allowed to be called
+    // but it won't be cached. So it's neither an infinite AbortSignal nor an
+    // already resolved one.
+    return null;
   }
-  return ReactElement(element.type, key, void 0, void 0, owner, props);
-};
-exports.createElement = function (type, config, children) {
-  var propName,
-    props = {},
-    key = null;
-  if (null != config)
-    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
-      hasOwnProperty.call(config, propName) &&
-        "key" !== propName &&
-        "__self" !== propName &&
-        "__source" !== propName &&
-        (props[propName] = config[propName]);
-  var childrenLength = arguments.length - 2;
-  if (1 === childrenLength) props.children = children;
-  else if (1 < childrenLength) {
-    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
-      childArray[i] = arguments[i + 2];
-    props.children = childArray;
+  return dispatcher.cacheSignal();
+}
+
+const reportGlobalError = typeof reportError === 'function' ?
+// In modern browsers, reportError will dispatch an error event,
+// emulating an uncaught JavaScript error.
+reportError : error => {
+  if (typeof window === 'object' && typeof window.ErrorEvent === 'function') {
+    // Browser Polyfill
+    const message = typeof error === 'object' && error !== null && typeof error.message === 'string' ?
+    // eslint-disable-next-line react-internal/safe-string-coercion
+    String(error.message) :
+    // eslint-disable-next-line react-internal/safe-string-coercion
+    String(error);
+    const event = new window.ErrorEvent('error', {
+      bubbles: true,
+      cancelable: true,
+      message: message,
+      error: error
+    });
+    const shouldLog = window.dispatchEvent(event);
+    if (!shouldLog) {
+      return;
+    }
+  } else if (typeof process === 'object' &&
+  // $FlowFixMe[method-unbinding]
+  typeof process.emit === 'function') {
+    // Node Polyfill
+    process.emit('uncaughtException', error);
+    return;
   }
-  if (type && type.defaultProps)
-    for (propName in ((childrenLength = type.defaultProps), childrenLength))
-      void 0 === props[propName] &&
-        (props[propName] = childrenLength[propName]);
-  return ReactElement(type, key, void 0, void 0, null, props);
+  console['error'](error);
 };
-exports.createRef = function () {
-  return { current: null };
-};
-exports.forwardRef = function (render) {
-  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };
+
+function releaseAsyncTransition() {
+}
+function startTransition(scope, options) {
+  const prevTransition = ReactSharedInternals.T;
+  const currentTransition = {};
+  {
+    currentTransition.types = prevTransition !== null ?
+    // If we're a nested transition, we should use the same set as the parent
+    // since we're conceptually always joined into the same entangled transition.
+    // In practice, this only matters if we add transition types in the inner
+    // without setting state. In that case, the inner transition can finish
+    // without waiting for the outer.
+    prevTransition.types : null;
+  }
+  {
+    currentTransition.gesture = null;
+  }
+  ReactSharedInternals.T = currentTransition;
+  try {
+    const returnValue = scope();
+    const onStartTransitionFinish = ReactSharedInternals.S;
+    if (onStartTransitionFinish !== null) {
+      onStartTransitionFinish(currentTransition, returnValue);
+    }
+    if (typeof returnValue === 'object' && returnValue !== null && typeof returnValue.then === 'function') {
+      if (false) ;
+      returnValue.then(noop, reportGlobalError);
+    }
+  } catch (error) {
+    reportGlobalError(error);
+  } finally {
+    if (prevTransition !== null && currentTransition.types !== null) {
+      prevTransition.types = currentTransition.types;
+    }
+    ReactSharedInternals.T = prevTransition;
+  }
+}
+
+function postpone(reason) {
+  // eslint-disable-next-line react-internal/prod-error-codes
+  const postponeInstance = new Error(reason);
+  postponeInstance.$$typeof = REACT_POSTPONE_TYPE;
+  throw postponeInstance;
+}
+
+var ReactVersion = '19.2.0-experimental-602917c8-20250701';
+
+const getPrototypeOf = Object.getPrototypeOf;
+
+// Turns a TypedArray or ArrayBuffer into a string that can be used for comparison
+// in a Map to see if the bytes are the same.
+function binaryToComparableString(view) {
+  return String.fromCharCode.apply(String, new Uint8Array(view.buffer, view.byteOffset, view.byteLength));
+}
+
+const TaintRegistryObjects = ReactSharedInternals.TaintRegistryObjects,
+  TaintRegistryValues = ReactSharedInternals.TaintRegistryValues,
+  TaintRegistryByteLengths = ReactSharedInternals.TaintRegistryByteLengths,
+  TaintRegistryPendingRequests = ReactSharedInternals.TaintRegistryPendingRequests; // This is the shared constructor of all typed arrays.
+const TypedArrayConstructor = getPrototypeOf(Uint32Array.prototype).constructor;
+const defaultMessage = 'A tainted value was attempted to be serialized to a Client Component or Action closure. ' + 'This would leak it to the client.';
+function cleanup(entryValue) {
+  const entry = TaintRegistryValues.get(entryValue);
+  if (entry !== undefined) {
+    TaintRegistryPendingRequests.forEach(function (requestQueue) {
+      requestQueue.push(entryValue);
+      entry.count++;
+    });
+    if (entry.count === 1) {
+      TaintRegistryValues.delete(entryValue);
+    } else {
+      entry.count--;
+    }
+  }
+}
+
+// If FinalizationRegistry doesn't exist, we assume that objects life forever.
+// E.g. the whole VM is just the lifetime of a request.
+const finalizationRegistry = typeof FinalizationRegistry === 'function' ? new FinalizationRegistry(cleanup) : null;
+function taintUniqueValue(message, lifetime, value) {
+  // eslint-disable-next-line react-internal/safe-string-coercion
+  message = '' + (message || defaultMessage);
+  if (lifetime === null || typeof lifetime !== 'object' && typeof lifetime !== 'function') {
+    throw Error(formatProdErrorMessage(493));
+  }
+  let entryValue;
+  if (typeof value === 'string' || typeof value === 'bigint') {
+    // Use as is.
+    entryValue = value;
+  } else if (value instanceof TypedArrayConstructor || value instanceof DataView) {
+    // For now, we just convert binary data to a string so that we can just use the native
+    // hashing in the Map implementation. It doesn't really matter what form the string
+    // take as long as it's the same when we look it up.
+    // We're not too worried about collisions since this should be a high entropy value.
+    TaintRegistryByteLengths.add(value.byteLength);
+    entryValue = binaryToComparableString(value);
+  } else {
+    const kind = value === null ? 'null' : typeof value;
+    if (kind === 'object' || kind === 'function') {
+      throw Error(formatProdErrorMessage(494));
+    }
+    throw Error(formatProdErrorMessage(495, kind));
+  }
+  const existingEntry = TaintRegistryValues.get(entryValue);
+  if (existingEntry === undefined) {
+    TaintRegistryValues.set(entryValue, {
+      message,
+      count: 1
+    });
+  } else {
+    existingEntry.count++;
+  }
+  if (finalizationRegistry !== null) {
+    finalizationRegistry.register(lifetime, entryValue);
+  }
+}
+function taintObjectReference(message, object) {
+  // eslint-disable-next-line react-internal/safe-string-coercion
+  message = '' + (message || defaultMessage);
+  if (typeof object === 'string' || typeof object === 'bigint') {
+    throw Error(formatProdErrorMessage(496));
+  }
+  if (object === null || typeof object !== 'object' && typeof object !== 'function') {
+    throw Error(formatProdErrorMessage(497));
+  }
+  TaintRegistryObjects.set(object, message);
+}
+
+const Children = {
+  map: mapChildren,
+  forEach: forEachChildren,
+  count: countChildren,
+  toArray,
+  only: onlyChild
 };
+
+exports.Children = Children;
+exports.Fragment = REACT_FRAGMENT_TYPE;
+exports.Profiler = REACT_PROFILER_TYPE;
+exports.StrictMode = REACT_STRICT_MODE_TYPE;
+exports.Suspense = REACT_SUSPENSE_TYPE;
+exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
+exports.cache = cache;
+exports.cacheSignal = cacheSignal;
+exports.cloneElement = cloneElement;
+exports.createElement = createElement;
+exports.createRef = createRef;
+exports.experimental_taintObjectReference = taintObjectReference;
+exports.experimental_taintUniqueValue = taintUniqueValue;
+exports.forwardRef = forwardRef;
 exports.isValidElement = isValidElement;
-exports.lazy = function (ctor) {
-  return {
-    $$typeof: REACT_LAZY_TYPE,
-    _payload: { _status: -1, _result: ctor },
-    _init: lazyInitializer
-  };
-};
-exports.memo = function (type, compare) {
-  return {
-    $$typeof: REACT_MEMO_TYPE,
-    type: type,
-    compare: void 0 === compare ? null : compare
-  };
-};
-exports.use = function (usable) {
-  return ReactSharedInternals.H.use(usable);
-};
-exports.useCallback = function (callback, deps) {
-  return ReactSharedInternals.H.useCallback(callback, deps);
-};
-exports.useDebugValue = function () {};
-exports.useId = function () {
-  return ReactSharedInternals.H.useId();
-};
-exports.useMemo = function (create, deps) {
-  return ReactSharedInternals.H.useMemo(create, deps);
-};
-exports.version = "19.1.0";
+exports.lazy = lazy;
+exports.memo = memo;
+exports.startTransition = startTransition;
+exports.unstable_Activity = REACT_ACTIVITY_TYPE;
+exports.unstable_SuspenseList = REACT_SUSPENSE_LIST_TYPE;
+exports.unstable_ViewTransition = REACT_VIEW_TRANSITION_TYPE;
+exports.unstable_getCacheForType = getCacheForType;
+exports.unstable_postpone = postpone;
+exports.use = use;
+exports.useCallback = useCallback;
+exports.useDebugValue = useDebugValue;
+exports.useId = useId;
+exports.useMemo = useMemo;
+exports.version = ReactVersion;
+//# sourceMappingURL=react.react-server.production.js.map
diff --git a/cjs/react.react-server.production.js.map b/cjs/react.react-server.production.js.map
new file mode 100644
index 0000000000000000000000000000000000000000..d0d69a4056f49bd7526224931ae425850d6e064a
--- /dev/null
+++ b/cjs/react.react-server.production.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"react.react-server.production.js","sources":["/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactTaintRegistry.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactSharedInternalsServer.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/formatProdErrorMessage.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/isArray.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/noop.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactSymbols.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/hasOwnProperty.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/assign.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/jsx/ReactJSXElement.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactChildren.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactCreateRef.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactHooks.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactForwardRef.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactLazy.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactMemo.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactCacheImpl.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/reportGlobalError.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactStartTransition.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactPostpone.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/ReactVersion.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/getPrototypeOf.js","/Users/liuhao/maodun/react-source-debug/react/packages/shared/binaryToComparableString.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactTaint.js","/Users/liuhao/maodun/react-source-debug/react/packages/react/src/ReactServer.experimental.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport interface Reference {}\n\nexport type TaintEntry = {\n  message: string,\n  count: number,\n};\n\nexport const TaintRegistryObjects: WeakMap<Reference, string> = new WeakMap();\nexport const TaintRegistryValues: Map<string | bigint, TaintEntry> = new Map();\n// Byte lengths of all binary values we've ever seen. We don't both refcounting this.\n// We expect to see only a few lengths here such as the length of token.\nexport const TaintRegistryByteLengths: Set<number> = new Set();\n\n// When a value is finalized, it means that it has been removed from any global caches.\n// No future requests can get a handle on it but any ongoing requests can still have\n// a handle on it. It's still tainted until that happens.\nexport type RequestCleanupQueue = Array<string | bigint>;\nexport const TaintRegistryPendingRequests: Set<RequestCleanupQueue> = new Set();\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {AsyncDispatcher} from 'react-reconciler/src/ReactInternalTypes';\n\nimport type {\n  Reference,\n  TaintEntry,\n  RequestCleanupQueue,\n} from './ReactTaintRegistry';\n\nimport {\n  TaintRegistryObjects,\n  TaintRegistryValues,\n  TaintRegistryByteLengths,\n  TaintRegistryPendingRequests,\n} from './ReactTaintRegistry';\n\nimport {enableTaint} from 'shared/ReactFeatureFlags';\n\nexport type SharedStateServer = {\n  H: null | Dispatcher, // ReactCurrentDispatcher for Hooks\n  A: null | AsyncDispatcher, // ReactCurrentCache for Cache\n\n  // enableTaint\n  TaintRegistryObjects: WeakMap<Reference, string>,\n  TaintRegistryValues: Map<string | bigint, TaintEntry>,\n  TaintRegistryByteLengths: Set<number>,\n  TaintRegistryPendingRequests: Set<RequestCleanupQueue>,\n\n  // DEV-only\n\n  // ReactDebugCurrentFrame\n  getCurrentStack: null | (() => string),\n\n  // ReactOwnerStackReset\n  recentlyCreatedOwnerStacks: 0,\n};\n\nexport type RendererTask = boolean => RendererTask | null;\n\nconst ReactSharedInternals: SharedStateServer = ({\n  H: null,\n  A: null,\n}: any);\n\nif (enableTaint) {\n  ReactSharedInternals.TaintRegistryObjects = TaintRegistryObjects;\n  ReactSharedInternals.TaintRegistryValues = TaintRegistryValues;\n  ReactSharedInternals.TaintRegistryByteLengths = TaintRegistryByteLengths;\n  ReactSharedInternals.TaintRegistryPendingRequests =\n    TaintRegistryPendingRequests;\n}\n\nif (__DEV__) {\n  // Stack implementation injected by the current renderer.\n  ReactSharedInternals.getCurrentStack = (null: null | (() => string));\n  ReactSharedInternals.recentlyCreatedOwnerStacks = 0;\n}\n\nexport default ReactSharedInternals;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls with\n// template literal strings. The messages will be replaced with error codes\n// during build.\n\nfunction formatProdErrorMessage(code) {\n  let url = 'https://react.dev/errors/' + code;\n  if (arguments.length > 1) {\n    url += '?args[]=' + encodeURIComponent(arguments[1]);\n    for (let i = 2; i < arguments.length; i++) {\n      url += '&args[]=' + encodeURIComponent(arguments[i]);\n    }\n  }\n\n  return (\n    `Minified React error #${code}; visit ${url} for the full message or ` +\n    'use the non-minified dev environment for full errors and additional ' +\n    'helpful warnings.'\n  );\n}\n\nexport default formatProdErrorMessage;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\ndeclare function isArray(a: mixed): boolean %checks(Array.isArray(a));\n\nconst isArrayImpl = Array.isArray;\n\nfunction isArray(a: mixed): boolean {\n  return isArrayImpl(a);\n}\n\nexport default isArray;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport default function noop() {}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {renameElementSymbol} from 'shared/ReactFeatureFlags';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\n// The Symbol used to tag the ReactElement-like types.\nexport const REACT_LEGACY_ELEMENT_TYPE: symbol = Symbol.for('react.element');\nexport const REACT_ELEMENT_TYPE: symbol = renameElementSymbol\n  ? Symbol.for('react.transitional.element')\n  : REACT_LEGACY_ELEMENT_TYPE;\nexport const REACT_PORTAL_TYPE: symbol = Symbol.for('react.portal');\nexport const REACT_FRAGMENT_TYPE: symbol = Symbol.for('react.fragment');\nexport const REACT_STRICT_MODE_TYPE: symbol = Symbol.for('react.strict_mode');\nexport const REACT_PROFILER_TYPE: symbol = Symbol.for('react.profiler');\nexport const REACT_CONSUMER_TYPE: symbol = Symbol.for('react.consumer');\nexport const REACT_CONTEXT_TYPE: symbol = Symbol.for('react.context');\nexport const REACT_FORWARD_REF_TYPE: symbol = Symbol.for('react.forward_ref');\nexport const REACT_SUSPENSE_TYPE: symbol = Symbol.for('react.suspense');\nexport const REACT_SUSPENSE_LIST_TYPE: symbol = Symbol.for(\n  'react.suspense_list',\n);\nexport const REACT_MEMO_TYPE: symbol = Symbol.for('react.memo');\nexport const REACT_LAZY_TYPE: symbol = Symbol.for('react.lazy');\nexport const REACT_SCOPE_TYPE: symbol = Symbol.for('react.scope');\nexport const REACT_ACTIVITY_TYPE: symbol = Symbol.for('react.activity');\nexport const REACT_LEGACY_HIDDEN_TYPE: symbol = Symbol.for(\n  'react.legacy_hidden',\n);\nexport const REACT_TRACING_MARKER_TYPE: symbol = Symbol.for(\n  'react.tracing_marker',\n);\n\nexport const REACT_MEMO_CACHE_SENTINEL: symbol = Symbol.for(\n  'react.memo_cache_sentinel',\n);\n\nexport const REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nexport const REACT_VIEW_TRANSITION_TYPE: symbol = Symbol.for(\n  'react.view_transition',\n);\n\nconst MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nexport function getIteratorFn(maybeIterable: ?any): ?() => ?Iterator<any> {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  const maybeIterator =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nexport const ASYNC_ITERATOR = Symbol.asyncIterator;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// $FlowFixMe[method-unbinding]\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport default hasOwnProperty;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst assign = Object.assign;\n\nexport default assign;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getComponentNameFromType from 'shared/getComponentNameFromType';\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\nimport hasOwnProperty from 'shared/hasOwnProperty';\nimport assign from 'shared/assign';\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_LAZY_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\nimport isArray from 'shared/isArray';\nimport {ownerStackLimit} from 'shared/ReactFeatureFlags';\n\nconst createTask =\n  // eslint-disable-next-line react-internal/no-production-logging\n  __DEV__ && console.createTask\n    ? // eslint-disable-next-line react-internal/no-production-logging\n      console.createTask\n    : () => null;\n\nfunction getTaskName(type) {\n  if (type === REACT_FRAGMENT_TYPE) {\n    return '<>';\n  }\n  if (\n    typeof type === 'object' &&\n    type !== null &&\n    type.$$typeof === REACT_LAZY_TYPE\n  ) {\n    // We don't want to eagerly initialize the initializer in DEV mode so we can't\n    // call it to extract the type so we don't know the type of this component.\n    return '<...>';\n  }\n  try {\n    const name = getComponentNameFromType(type);\n    return name ? '<' + name + '>' : '<...>';\n  } catch (x) {\n    return '<...>';\n  }\n}\n\nfunction getOwner() {\n  if (__DEV__) {\n    const dispatcher = ReactSharedInternals.A;\n    if (dispatcher === null) {\n      return null;\n    }\n    return dispatcher.getOwner();\n  }\n  return null;\n}\n\n/** @noinline */\nfunction UnknownOwner() {\n  /** @noinline */\n  return (() => Error('react-stack-top-frame'))();\n}\nconst createFakeCallStack = {\n  react_stack_bottom_frame: function (callStackForError) {\n    return callStackForError();\n  },\n};\n\nlet specialPropKeyWarningShown;\nlet didWarnAboutElementRef;\nlet didWarnAboutOldJSXRuntime;\nlet unknownOwnerDebugStack;\nlet unknownOwnerDebugTask;\n\nif (__DEV__) {\n  didWarnAboutElementRef = {};\n\n  // We use this technique to trick minifiers to preserve the function name.\n  unknownOwnerDebugStack = createFakeCallStack.react_stack_bottom_frame.bind(\n    createFakeCallStack,\n    UnknownOwner,\n  )();\n  unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n}\n\nfunction hasValidRef(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'ref')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  if (__DEV__) {\n    if (hasOwnProperty.call(config, 'key')) {\n      const getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  if (__DEV__) {\n    const warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n        console.error(\n          '%s: `key` is not a prop. Trying to access it will result ' +\n            'in `undefined` being returned. If you need to access the same ' +\n            'value within the child component, you should pass it as a different ' +\n            'prop. (https://react.dev/link/special-props)',\n          displayName,\n        );\n      }\n    };\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true,\n    });\n  }\n}\n\nfunction elementRefGetterWithDeprecationWarning() {\n  if (__DEV__) {\n    const componentName = getComponentNameFromType(this.type);\n    if (!didWarnAboutElementRef[componentName]) {\n      didWarnAboutElementRef[componentName] = true;\n      console.error(\n        'Accessing element.ref was removed in React 19. ref is now a ' +\n          'regular prop. It will be removed from the JSX Element ' +\n          'type in a future release.',\n      );\n    }\n\n    // An undefined `element.ref` is coerced to `null` for\n    // backwards compatibility.\n    const refProp = this.props.ref;\n    return refProp !== undefined ? refProp : null;\n  }\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.transitional.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\nfunction ReactElement(\n  type,\n  key,\n  self,\n  source,\n  owner,\n  props,\n  debugStack,\n  debugTask,\n) {\n  // Ignore whatever was passed as the ref argument and treat `props.ref` as\n  // the source of truth. The only thing we use this for is `element.ref`,\n  // which will log a deprecation warning on access. In the next release, we\n  // can remove `element.ref` as well as the `ref` argument.\n  const refProp = props.ref;\n\n  // An undefined `element.ref` is coerced to `null` for\n  // backwards compatibility.\n  const ref = refProp !== undefined ? refProp : null;\n\n  let element;\n  if (__DEV__) {\n    // In dev, make `ref` a non-enumerable property with a warning. It's non-\n    // enumerable so that test matchers and serializers don't access it and\n    // trigger the warning.\n    //\n    // `ref` will be removed from the element completely in a future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n\n      props,\n\n      // Record the component responsible for creating this element.\n      _owner: owner,\n    };\n    if (ref !== null) {\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        get: elementRefGetterWithDeprecationWarning,\n      });\n    } else {\n      // Don't warn on access if a ref is not given. This reduces false\n      // positives in cases where a test serializer uses\n      // getOwnPropertyDescriptors to compare objects, like Jest does, which is\n      // a problem because it bypasses non-enumerability.\n      //\n      // So unfortunately this will trigger a false positive warning in Jest\n      // when the diff is printed:\n      //\n      //   expect(<div ref={ref} />).toEqual(<span ref={ref} />);\n      //\n      // A bit sketchy, but this is what we've done for the `props.key` and\n      // `props.ref` accessors for years, which implies it will be good enough\n      // for `element.ref`, too. Let's see if anyone complains.\n      Object.defineProperty(element, 'ref', {\n        enumerable: false,\n        value: null,\n      });\n    }\n  } else {\n    // In prod, `ref` is a regular property and _owner doesn't exist.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n\n      // Built-in properties that belong on the element\n      type,\n      key,\n      ref,\n\n      props,\n    };\n  }\n\n  if (__DEV__) {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: 0,\n    });\n    // debugInfo contains Server Component debug information.\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null,\n    });\n    Object.defineProperty(element, '_debugStack', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugStack,\n    });\n    Object.defineProperty(element, '_debugTask', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: debugTask,\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxProd(type, config, maybeKey) {\n  let key = null;\n\n  // Currently, key can be spread in as a prop. This causes a potential\n  // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n  // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n  // but as an intermediary step, we will use jsxDEV for everything except\n  // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n  // key is explicitly declared to be undefined or not.\n  if (maybeKey !== undefined) {\n    if (__DEV__) {\n      checkKeyStringCoercion(maybeKey);\n    }\n    key = '' + maybeKey;\n  }\n\n  if (hasValidKey(config)) {\n    if (__DEV__) {\n      checkKeyStringCoercion(config.key);\n    }\n    key = '' + config.key;\n  }\n\n  let props;\n  if (!('key' in config)) {\n    // If key was not spread in, we can reuse the original props object. This\n    // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n    // target and the compiler always passes a new object. For `createElement`,\n    // we can't assume a new object is passed every time because it can be\n    // called manually.\n    //\n    // Spreading key is a warning in dev. In a future release, we will not\n    // remove a spread key from the props object. (But we'll still warn.) We'll\n    // always pass the object straight through.\n    props = config;\n  } else {\n    // We need to remove reserved props (key, prop, ref). Create a fresh props\n    // object and copy over all the non-reserved props. We don't use `delete`\n    // because in V8 it will deopt the object to dictionary mode.\n    props = {};\n    for (const propName in config) {\n      // Skip over reserved prop names\n      if (propName !== 'key') {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    undefined,\n    undefined,\n  );\n}\n\n// While `jsxDEV` should never be called when running in production, we do\n// support `jsx` and `jsxs` when running in development. This supports the case\n// where a third-party dependency ships code that was compiled for production;\n// we want to still provide warnings in development.\n//\n// So these functions are the _dev_ implementations of the _production_\n// API signatures.\n//\n// Since these functions are dev-only, it's ok to add an indirection here. They\n// only exist to provide different versions of `isStaticChildren`. (We shouldn't\n// use this pattern for the prod versions, though, because it will add an call\n// frame.)\nexport function jsxProdSignatureRunningInDevWithDynamicChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = false;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nexport function jsxProdSignatureRunningInDevWithStaticChildren(\n  type,\n  config,\n  maybeKey,\n  source,\n  self,\n) {\n  if (__DEV__) {\n    const isStaticChildren = true;\n    const trackActualOwner =\n      __DEV__ &&\n      ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n    return jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      __DEV__ &&\n        (trackActualOwner\n          ? Error('react-stack-top-frame')\n          : unknownOwnerDebugStack),\n      __DEV__ &&\n        (trackActualOwner\n          ? createTask(getTaskName(type))\n          : unknownOwnerDebugTask),\n    );\n  }\n}\n\nconst didWarnAboutKeySpread = {};\n\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\nexport function jsxDEV(type, config, maybeKey, isStaticChildren, source, self) {\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return jsxDEVImpl(\n    type,\n    config,\n    maybeKey,\n    isStaticChildren,\n    source,\n    self,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nfunction jsxDEVImpl(\n  type,\n  config,\n  maybeKey,\n  isStaticChildren,\n  source,\n  self,\n  debugStack,\n  debugTask,\n) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    // With owner stacks, we no longer need the type here so this comment is\n    // no longer true. Which is why we can run this even for invalid types.\n    const children = config.children;\n    if (children !== undefined) {\n      if (isStaticChildren) {\n        if (isArray(children)) {\n          for (let i = 0; i < children.length; i++) {\n            validateChildKeys(children[i], type);\n          }\n\n          if (Object.freeze) {\n            Object.freeze(children);\n          }\n        } else {\n          console.error(\n            'React.jsx: Static children should always be an array. ' +\n              'You are likely explicitly calling React.jsxs or React.jsxDEV. ' +\n              'Use the Babel transform instead.',\n          );\n        }\n      } else {\n        validateChildKeys(children, type);\n      }\n    }\n\n    // Warn about key spread regardless of whether the type is valid.\n    if (hasOwnProperty.call(config, 'key')) {\n      const componentName = getComponentNameFromType(type);\n      const keys = Object.keys(config).filter(k => k !== 'key');\n      const beforeExample =\n        keys.length > 0\n          ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}'\n          : '{key: someKey}';\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        const afterExample =\n          keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n        console.error(\n          'A props object containing a \"key\" prop is being spread into JSX:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s {...props} />\\n' +\n            'React keys must be passed directly to JSX without using spread:\\n' +\n            '  let props = %s;\\n' +\n            '  <%s key={someKey} {...props} />',\n          beforeExample,\n          componentName,\n          afterExample,\n          componentName,\n        );\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    let key = null;\n\n    // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n    if (maybeKey !== undefined) {\n      if (__DEV__) {\n        checkKeyStringCoercion(maybeKey);\n      }\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    let props;\n    if (!('key' in config)) {\n      // If key was not spread in, we can reuse the original props object. This\n      // only works for `jsx`, not `createElement`, because `jsx` is a compiler\n      // target and the compiler always passes a new object. For `createElement`,\n      // we can't assume a new object is passed every time because it can be\n      // called manually.\n      //\n      // Spreading key is a warning in dev. In a future release, we will not\n      // remove a spread key from the props object. (But we'll still warn.) We'll\n      // always pass the object straight through.\n      props = config;\n    } else {\n      // We need to remove reserved props (key, prop, ref). Create a fresh props\n      // object and copy over all the non-reserved props. We don't use `delete`\n      // because in V8 it will deopt the object to dictionary mode.\n      props = {};\n      for (const propName in config) {\n        // Skip over reserved prop names\n        if (propName !== 'key') {\n          props[propName] = config[propName];\n        }\n      }\n    }\n\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n\n    return ReactElement(\n      type,\n      key,\n      self,\n      source,\n      getOwner(),\n      props,\n      debugStack,\n      debugTask,\n    );\n  }\n}\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nexport function createElement(type, config, children) {\n  if (__DEV__) {\n    // We don't warn for invalid element type here because with owner stacks,\n    // we error in the renderer. The renderer is the only one that knows what\n    // types are valid for this particular renderer so we let it error there.\n\n    // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing\n    // errors. We don't want exception behavior to differ between dev and\n    // prod. (Rendering will throw with a helpful message and as soon as the\n    // type is fixed, the key warnings will appear.)\n    for (let i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    // Unlike the jsx() runtime, createElement() doesn't warn about key spread.\n  }\n\n  let propName;\n\n  // Reserved names are extracted\n  const props = {};\n\n  let key = null;\n\n  if (config != null) {\n    if (__DEV__) {\n      if (\n        !didWarnAboutOldJSXRuntime &&\n        '__self' in config &&\n        // Do not assume this is the result of an oudated JSX transform if key\n        // is present, because the modern JSX transform sometimes outputs\n        // createElement to preserve precedence between a static key and a\n        // spread key. To avoid false positive warnings, we never warn if\n        // there's a key.\n        !('key' in config)\n      ) {\n        didWarnAboutOldJSXRuntime = true;\n        console.warn(\n          'Your app (or one of its dependencies) is using an outdated JSX ' +\n            'transform. Update to the modern JSX transform for ' +\n            'faster performance: https://react.dev/link/new-jsx-transform',\n        );\n      }\n    }\n\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // Even though we don't use these anymore in the runtime, we don't want\n        // them to appear as props, so in createElement we filter them out.\n        // We don't have to do this in the jsx() runtime because the jsx()\n        // transform never passed these as props; it used separate arguments.\n        propName !== '__self' &&\n        propName !== '__source'\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    if (__DEV__) {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    const defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  if (__DEV__) {\n    if (key) {\n      const displayName =\n        typeof type === 'function'\n          ? type.displayName || type.name || 'Unknown'\n          : type;\n      defineKeyPropWarningGetter(props, displayName);\n    }\n  }\n  const trackActualOwner =\n    __DEV__ &&\n    ReactSharedInternals.recentlyCreatedOwnerStacks++ < ownerStackLimit;\n  return ReactElement(\n    type,\n    key,\n    undefined,\n    undefined,\n    getOwner(),\n    props,\n    __DEV__ &&\n      (trackActualOwner\n        ? Error('react-stack-top-frame')\n        : unknownOwnerDebugStack),\n    __DEV__ &&\n      (trackActualOwner\n        ? createTask(getTaskName(type))\n        : unknownOwnerDebugTask),\n  );\n}\n\nexport function cloneAndReplaceKey(oldElement, newKey) {\n  const clonedElement = ReactElement(\n    oldElement.type,\n    newKey,\n    undefined,\n    undefined,\n    !__DEV__ ? undefined : oldElement._owner,\n    oldElement.props,\n    __DEV__ && oldElement._debugStack,\n    __DEV__ && oldElement._debugTask,\n  );\n  if (__DEV__) {\n    // The cloned element should inherit the original element's key validation.\n    if (oldElement._store) {\n      clonedElement._store.validated = oldElement._store.validated;\n    }\n  }\n  return clonedElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nexport function cloneElement(element, config, children) {\n  if (element === null || element === undefined) {\n    throw new Error(\n      `The argument must be a React element, but you passed ${element}.`,\n    );\n  }\n\n  let propName;\n\n  // Original props are copied\n  const props = assign({}, element.props);\n\n  // Reserved names are extracted\n  let key = element.key;\n\n  // Owner will be preserved, unless ref is overridden\n  let owner = !__DEV__ ? undefined : element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      owner = __DEV__ ? getOwner() : undefined;\n    }\n    if (hasValidKey(config)) {\n      if (__DEV__) {\n        checkKeyStringCoercion(config.key);\n      }\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    for (propName in config) {\n      if (\n        hasOwnProperty.call(config, propName) &&\n        // Skip over reserved prop names\n        propName !== 'key' &&\n        // ...and maybe these, too, though we currently rely on them for\n        // warnings and debug information in dev. Need to decide if we're OK\n        // with dropping them. In the jsx() runtime it's not an issue because\n        // the data gets passed as separate arguments instead of props, but\n        // it would be nice to stop relying on them entirely so we can drop\n        // them from the internal Fiber field.\n        propName !== '__self' &&\n        propName !== '__source' &&\n        // Undefined `ref` is ignored by cloneElement. We treat it the same as\n        // if the property were missing. This is mostly for\n        // backwards compatibility.\n        !(propName === 'ref' && config.ref === undefined)\n      ) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  const childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    const childArray = Array(childrenLength);\n    for (let i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  const clonedElement = ReactElement(\n    element.type,\n    key,\n    undefined,\n    undefined,\n    owner,\n    props,\n    __DEV__ && element._debugStack,\n    __DEV__ && element._debugTask,\n  );\n\n  for (let i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], clonedElement.type);\n  }\n\n  return clonedElement;\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (__DEV__) {\n    // With owner stacks is, no warnings happens. All we do is\n    // mark elements as being in a valid static child position so they\n    // don't need keys.\n    if (isValidElement(node)) {\n      if (node._store) {\n        node._store.validated = 1;\n      }\n    }\n  }\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nexport function isValidElement(object) {\n  return (\n    typeof object === 'object' &&\n    object !== null &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {\n  ReactNodeList,\n  Thenable,\n  PendingThenable,\n  FulfilledThenable,\n  RejectedThenable,\n} from 'shared/ReactTypes';\n\nimport isArray from 'shared/isArray';\nimport noop from 'shared/noop';\nimport {\n  getIteratorFn,\n  REACT_ELEMENT_TYPE,\n  REACT_LAZY_TYPE,\n  REACT_PORTAL_TYPE,\n} from 'shared/ReactSymbols';\nimport {checkKeyStringCoercion} from 'shared/CheckStringCoercion';\n\nimport {isValidElement, cloneAndReplaceKey} from './jsx/ReactJSXElement';\n\nconst SEPARATOR = '.';\nconst SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key: string): string {\n  const escapeRegex = /[=:]/g;\n  const escaperLookup = {\n    '=': '=0',\n    ':': '=2',\n  };\n  const escapedString = key.replace(escapeRegex, function (match) {\n    // $FlowFixMe[invalid-computed-prop]\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nlet didWarnAboutMaps = false;\n\nconst userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text: string): string {\n  return text.replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\n/**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getElementKey(element: any, index: number): string {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    // Explicit key\n    if (__DEV__) {\n      checkKeyStringCoercion(element.key);\n    }\n    return escape('' + element.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction resolveThenable<T>(thenable: Thenable<T>): T {\n  switch (thenable.status) {\n    case 'fulfilled': {\n      const fulfilledValue: T = thenable.value;\n      return fulfilledValue;\n    }\n    case 'rejected': {\n      const rejectedError = thenable.reason;\n      throw rejectedError;\n    }\n    default: {\n      if (typeof thenable.status === 'string') {\n        // Only instrument the thenable if the status if not defined. If\n        // it's defined, but an unknown value, assume it's been instrumented by\n        // some custom userspace implementation. We treat it as \"pending\".\n        // Attach a dummy listener, to ensure that any lazy initialization can\n        // happen. Flight lazily parses JSON when the value is actually awaited.\n        thenable.then(noop, noop);\n      } else {\n        // This is an uncached thenable that we haven't seen before.\n\n        // TODO: Detect infinite ping loops caused by uncached promises.\n\n        const pendingThenable: PendingThenable<T> = (thenable: any);\n        pendingThenable.status = 'pending';\n        pendingThenable.then(\n          fulfilledValue => {\n            if (thenable.status === 'pending') {\n              const fulfilledThenable: FulfilledThenable<T> = (thenable: any);\n              fulfilledThenable.status = 'fulfilled';\n              fulfilledThenable.value = fulfilledValue;\n            }\n          },\n          (error: mixed) => {\n            if (thenable.status === 'pending') {\n              const rejectedThenable: RejectedThenable<T> = (thenable: any);\n              rejectedThenable.status = 'rejected';\n              rejectedThenable.reason = error;\n            }\n          },\n        );\n      }\n\n      // Check one more time in case the thenable resolved synchronously.\n      switch ((thenable: Thenable<T>).status) {\n        case 'fulfilled': {\n          const fulfilledThenable: FulfilledThenable<T> = (thenable: any);\n          return fulfilledThenable.value;\n        }\n        case 'rejected': {\n          const rejectedThenable: RejectedThenable<T> = (thenable: any);\n          const rejectedError = rejectedThenable.reason;\n          throw rejectedError;\n        }\n      }\n    }\n  }\n  throw thenable;\n}\n\nfunction mapIntoArray(\n  children: ?ReactNodeList,\n  array: Array<React$Node>,\n  escapedPrefix: string,\n  nameSoFar: string,\n  callback: (?React$Node) => ?ReactNodeList,\n): number {\n  const type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  let invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'bigint':\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch ((children: any).$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n            break;\n          case REACT_LAZY_TYPE:\n            const payload = (children: any)._payload;\n            const init = (children: any)._init;\n            return mapIntoArray(\n              init(payload),\n              array,\n              escapedPrefix,\n              nameSoFar,\n              callback,\n            );\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    const child = children;\n    let mappedChild = callback(child);\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows:\n    const childKey =\n      nameSoFar === '' ? SEPARATOR + getElementKey(child, 0) : nameSoFar;\n    if (isArray(mappedChild)) {\n      let escapedChildKey = '';\n      if (childKey != null) {\n        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n      }\n      mapIntoArray(mappedChild, array, escapedChildKey, '', c => c);\n    } else if (mappedChild != null) {\n      if (isValidElement(mappedChild)) {\n        if (__DEV__) {\n          // The `if` statement here prevents auto-disabling of the safe\n          // coercion ESLint rule, so we must manually disable it below.\n          // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n          if (mappedChild.key != null) {\n            if (!child || child.key !== mappedChild.key) {\n              checkKeyStringCoercion(mappedChild.key);\n            }\n          }\n        }\n        const newChild = cloneAndReplaceKey(\n          mappedChild,\n          // Keep both the (mapped) and old keys if they differ, just as\n          // traverseAllChildren used to do for objects as children\n          escapedPrefix +\n            // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n            (mappedChild.key != null &&\n            (!child || child.key !== mappedChild.key)\n              ? escapeUserProvidedKey(\n                  // $FlowFixMe[unsafe-addition]\n                  '' + mappedChild.key, // eslint-disable-line react-internal/safe-string-coercion\n                ) + '/'\n              : '') +\n            childKey,\n        );\n        if (__DEV__) {\n          // If `child` was an element without a `key`, we need to validate if\n          // it should have had a `key`, before assigning one to `mappedChild`.\n          // $FlowFixMe[incompatible-type] Flow incorrectly thinks React.Portal doesn't have a key\n          if (\n            nameSoFar !== '' &&\n            child != null &&\n            isValidElement(child) &&\n            child.key == null\n          ) {\n            // We check truthiness of `child._store.validated` instead of being\n            // inequal to `1` to provide a bit of backward compatibility for any\n            // libraries (like `fbt`) which may be hacking this property.\n            if (child._store && !child._store.validated) {\n              // Mark this child as having failed validation, but let the actual\n              // renderer print the warning later.\n              newChild._store.validated = 2;\n            }\n          }\n        }\n        mappedChild = newChild;\n      }\n      array.push(mappedChild);\n    }\n    return 1;\n  }\n\n  let child;\n  let nextName;\n  let subtreeCount = 0; // Count of children found in the current subtree.\n  const nextNamePrefix =\n    nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getElementKey(child, i);\n      subtreeCount += mapIntoArray(\n        child,\n        array,\n        escapedPrefix,\n        nextName,\n        callback,\n      );\n    }\n  } else {\n    const iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      const iterableChildren: Iterable<React$Node> & {\n        entries: any,\n      } = (children: any);\n\n      if (__DEV__) {\n        // Warn about using Maps as children\n        if (iteratorFn === iterableChildren.entries) {\n          if (!didWarnAboutMaps) {\n            console.warn(\n              'Using Maps as children is not supported. ' +\n                'Use an array of keyed ReactElements instead.',\n            );\n          }\n          didWarnAboutMaps = true;\n        }\n      }\n\n      const iterator = iteratorFn.call(iterableChildren);\n      let step;\n      let ii = 0;\n      // $FlowFixMe[incompatible-use] `iteratorFn` might return null according to typing.\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getElementKey(child, ii++);\n        subtreeCount += mapIntoArray(\n          child,\n          array,\n          escapedPrefix,\n          nextName,\n          callback,\n        );\n      }\n    } else if (type === 'object') {\n      if (typeof (children: any).then === 'function') {\n        return mapIntoArray(\n          resolveThenable((children: any)),\n          array,\n          escapedPrefix,\n          nameSoFar,\n          callback,\n        );\n      }\n\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      const childrenString = String((children: any));\n\n      throw new Error(\n        `Objects are not valid as a React child (found: ${\n          childrenString === '[object Object]'\n            ? 'object with keys {' +\n              Object.keys((children: any)).join(', ') +\n              '}'\n            : childrenString\n        }). ` +\n          'If you meant to render a collection of children, use an array ' +\n          'instead.',\n      );\n    }\n  }\n\n  return subtreeCount;\n}\n\ntype MapFunc = (child: ?React$Node, index: number) => ?ReactNodeList;\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(\n  children: ?ReactNodeList,\n  func: MapFunc,\n  context: mixed,\n): ?Array<React$Node> {\n  if (children == null) {\n    // $FlowFixMe limitation refining abstract types in Flow\n    return children;\n  }\n  const result: Array<React$Node> = [];\n  let count = 0;\n  mapIntoArray(children, result, '', '', function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children: ?ReactNodeList): number {\n  let n = 0;\n  mapChildren(children, () => {\n    n++;\n    // Don't return anything\n  });\n  return n;\n}\n\ntype ForEachFunc = (child: ?React$Node) => void;\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(\n  children: ?ReactNodeList,\n  forEachFunc: ForEachFunc,\n  forEachContext: mixed,\n): void {\n  mapChildren(\n    children,\n    // $FlowFixMe[missing-this-annot]\n    function () {\n      forEachFunc.apply(this, arguments);\n      // Don't return anything.\n    },\n    forEachContext,\n  );\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\nfunction toArray(children: ?ReactNodeList): Array<React$Node> {\n  return mapChildren(children, child => child) || [];\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild<T>(children: T): T {\n  if (!isValidElement(children)) {\n    throw new Error(\n      'React.Children.only expected to receive a single React element child.',\n    );\n  }\n\n  return children;\n}\n\nexport {\n  forEachChildren as forEach,\n  mapChildren as map,\n  countChildren as count,\n  onlyChild as only,\n  toArray,\n};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n * @flow\n */\n\nimport type {RefObject} from 'shared/ReactTypes';\n\n// an immutable object with a single mutable value\nexport function createRef(): RefObject {\n  const refObject = {\n    current: null,\n  };\n  if (__DEV__) {\n    Object.seal(refObject);\n  }\n  return refObject;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Dispatcher} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  ReactContext,\n  StartTransitionOptions,\n  Usable,\n  Awaited,\n} from 'shared/ReactTypes';\nimport {REACT_CONSUMER_TYPE} from 'shared/ReactSymbols';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\ntype BasicStateAction<S> = (S => S) | S;\ntype Dispatch<A> = A => void;\n\nfunction resolveDispatcher() {\n  const dispatcher = ReactSharedInternals.H;\n  if (__DEV__) {\n    if (dispatcher === null) {\n      console.error(\n        'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +\n          ' one of the following reasons:\\n' +\n          '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' +\n          '2. You might be breaking the Rules of Hooks\\n' +\n          '3. You might have more than one copy of React in the same app\\n' +\n          'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.',\n      );\n    }\n  }\n  // Will result in a null access error if accessed outside render phase. We\n  // intentionally don't throw our own error because this is in a hot path.\n  // Also helps ensure this is inlined.\n  return ((dispatcher: any): Dispatcher);\n}\n\nexport function getCacheForType<T>(resourceType: () => T): T {\n  const dispatcher = ReactSharedInternals.A;\n  if (!dispatcher) {\n    // If there is no dispatcher, then we treat this as not being cached.\n    return resourceType();\n  }\n  return dispatcher.getCacheForType(resourceType);\n}\n\nexport function useContext<T>(Context: ReactContext<T>): T {\n  const dispatcher = resolveDispatcher();\n  if (__DEV__) {\n    if (Context.$$typeof === REACT_CONSUMER_TYPE) {\n      console.error(\n        'Calling useContext(Context.Consumer) is not supported and will cause bugs. ' +\n          'Did you mean to call useContext(Context) instead?',\n      );\n    }\n  }\n  return dispatcher.useContext(Context);\n}\n\nexport function useState<S>(\n  initialState: (() => S) | S,\n): [S, Dispatch<BasicStateAction<S>>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\n\nexport function useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S,\n): [S, Dispatch<A>] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\n\nexport function useRef<T>(initialValue: T): {current: T} {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\n\nexport function useEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\n\nexport function useInsertionEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useInsertionEffect(create, deps);\n}\n\nexport function useLayoutEffect(\n  create: () => (() => void) | void,\n  deps: Array<mixed> | void | null,\n): void {\n  if (__DEV__) {\n    if (create == null) {\n      console.warn(\n        'React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?',\n      );\n    }\n  }\n\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\n\nexport function useCallback<T>(\n  callback: T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\n\nexport function useMemo<T>(\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\n\nexport function useImperativeHandle<T>(\n  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,\n  create: () => T,\n  deps: Array<mixed> | void | null,\n): void {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\n\nexport function useDebugValue<T>(\n  value: T,\n  formatterFn: ?(value: T) => mixed,\n): void {\n  if (__DEV__) {\n    const dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\n\nexport function useTransition(): [\n  boolean,\n  (callback: () => void, options?: StartTransitionOptions) => void,\n] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useTransition();\n}\n\nexport function useDeferredValue<T>(value: T, initialValue?: T): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useDeferredValue(value, initialValue);\n}\n\nexport function useId(): string {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useId();\n}\n\nexport function useSyncExternalStore<T>(\n  subscribe: (() => void) => () => void,\n  getSnapshot: () => T,\n  getServerSnapshot?: () => T,\n): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot,\n  );\n}\n\nexport function useCacheRefresh(): <T>(?() => T, ?T) => void {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useCacheRefresh();\n}\n\nexport function use<T>(usable: Usable<T>): T {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.use(usable);\n}\n\nexport function useMemoCache(size: number): Array<mixed> {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useMemoCache(size);\n}\n\nexport function useEffectEvent<Args, F: (...Array<Args>) => mixed>(\n  callback: F,\n): F {\n  const dispatcher = resolveDispatcher();\n  // $FlowFixMe[not-a-function] This is unstable, thus optional\n  return dispatcher.useEffectEvent(callback);\n}\n\nexport function useOptimistic<S, A>(\n  passthrough: S,\n  reducer: ?(S, A) => S,\n): [S, (A) => void] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useOptimistic(passthrough, reducer);\n}\n\nexport function useActionState<S, P>(\n  action: (Awaited<S>, P) => S,\n  initialState: Awaited<S>,\n  permalink?: string,\n): [Awaited<S>, (P) => void, boolean] {\n  const dispatcher = resolveDispatcher();\n  return dispatcher.useActionState(action, initialState, permalink);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n */\n\nimport {REACT_FORWARD_REF_TYPE, REACT_MEMO_TYPE} from 'shared/ReactSymbols';\n\nexport function forwardRef<Props, ElementType: React$ElementType>(\n  render: (\n    props: Props,\n    ref: React$RefSetter<React$ElementRef<ElementType>>,\n  ) => React$Node,\n) {\n  if (__DEV__) {\n    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n      console.error(\n        'forwardRef requires a render function but received a `memo` ' +\n          'component. Instead of forwardRef(memo(...)), use ' +\n          'memo(forwardRef(...)).',\n      );\n    } else if (typeof render !== 'function') {\n      console.error(\n        'forwardRef requires a render function but was given %s.',\n        render === null ? 'null' : typeof render,\n      );\n    } else {\n      if (render.length !== 0 && render.length !== 2) {\n        console.error(\n          'forwardRef render functions accept exactly two parameters: props and ref. %s',\n          render.length === 1\n            ? 'Did you forget to use the ref parameter?'\n            : 'Any additional parameter will be undefined.',\n        );\n      }\n    }\n\n    if (render != null) {\n      if (render.defaultProps != null) {\n        console.error(\n          'forwardRef render functions do not support defaultProps. ' +\n            'Did you accidentally pass a React component?',\n        );\n      }\n    }\n  }\n\n  const elementType = {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render,\n  };\n  if (__DEV__) {\n    let ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name;\n\n        // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.forwardRef((props, ref) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n        if (!render.name && !render.displayName) {\n          Object.defineProperty(render, 'name', {\n            value: name,\n          });\n          render.displayName = name;\n        }\n      },\n    });\n  }\n  return elementType;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Wakeable, Thenable, ReactDebugInfo} from 'shared/ReactTypes';\n\nimport {REACT_LAZY_TYPE} from 'shared/ReactSymbols';\n\nconst Uninitialized = -1;\nconst Pending = 0;\nconst Resolved = 1;\nconst Rejected = 2;\n\ntype UninitializedPayload<T> = {\n  _status: -1,\n  _result: () => Thenable<{default: T, ...}>,\n};\n\ntype PendingPayload = {\n  _status: 0,\n  _result: Wakeable,\n};\n\ntype ResolvedPayload<T> = {\n  _status: 1,\n  _result: {default: T, ...},\n};\n\ntype RejectedPayload = {\n  _status: 2,\n  _result: mixed,\n};\n\ntype Payload<T> =\n  | UninitializedPayload<T>\n  | PendingPayload\n  | ResolvedPayload<T>\n  | RejectedPayload;\n\nexport type LazyComponent<T, P> = {\n  $$typeof: symbol | number,\n  _payload: P,\n  _init: (payload: P) => T,\n  _debugInfo?: null | ReactDebugInfo,\n};\n\nfunction lazyInitializer<T>(payload: Payload<T>): T {\n  if (payload._status === Uninitialized) {\n    const ctor = payload._result;\n    const thenable = ctor();\n    // Transition to the next state.\n    // This might throw either because it's missing or throws. If so, we treat it\n    // as still uninitialized and try again next time. Which is the same as what\n    // happens if the ctor or any wrappers processing the ctor throws. This might\n    // end up fixing it if the resolution was a concurrency bug.\n    thenable.then(\n      moduleObject => {\n        if (\n          (payload: Payload<T>)._status === Pending ||\n          payload._status === Uninitialized\n        ) {\n          // Transition to the next state.\n          const resolved: ResolvedPayload<T> = (payload: any);\n          resolved._status = Resolved;\n          resolved._result = moduleObject;\n        }\n      },\n      error => {\n        if (\n          (payload: Payload<T>)._status === Pending ||\n          payload._status === Uninitialized\n        ) {\n          // Transition to the next state.\n          const rejected: RejectedPayload = (payload: any);\n          rejected._status = Rejected;\n          rejected._result = error;\n        }\n      },\n    );\n    if (payload._status === Uninitialized) {\n      // In case, we're still uninitialized, then we're waiting for the thenable\n      // to resolve. Set it as pending in the meantime.\n      const pending: PendingPayload = (payload: any);\n      pending._status = Pending;\n      pending._result = thenable;\n    }\n  }\n  if (payload._status === Resolved) {\n    const moduleObject = payload._result;\n    if (__DEV__) {\n      if (moduleObject === undefined) {\n        console.error(\n          'lazy: Expected the result of a dynamic imp' +\n            'ort() call. ' +\n            'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' +\n            \"ort('./MyComponent'))\\n\\n\" +\n            'Did you accidentally put curly braces around the import?',\n          moduleObject,\n        );\n      }\n    }\n    if (__DEV__) {\n      if (!('default' in moduleObject)) {\n        console.error(\n          'lazy: Expected the result of a dynamic imp' +\n            'ort() call. ' +\n            'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' +\n            \"ort('./MyComponent'))\",\n          moduleObject,\n        );\n      }\n    }\n    return moduleObject.default;\n  } else {\n    throw payload._result;\n  }\n}\n\nexport function lazy<T>(\n  ctor: () => Thenable<{default: T, ...}>,\n): LazyComponent<T, Payload<T>> {\n  const payload: Payload<T> = {\n    // We use these fields to store the result.\n    _status: Uninitialized,\n    _result: ctor,\n  };\n\n  const lazyType: LazyComponent<T, Payload<T>> = {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: payload,\n    _init: lazyInitializer,\n  };\n\n  return lazyType;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @noflow\n */\n\nimport {REACT_MEMO_TYPE} from 'shared/ReactSymbols';\n\nexport function memo<Props>(\n  type: React$ElementType,\n  compare?: (oldProps: Props, newProps: Props) => boolean,\n) {\n  if (__DEV__) {\n    if (type == null) {\n      console.error(\n        'memo: The first argument must be a component. Instead ' +\n          'received: %s',\n        type === null ? 'null' : typeof type,\n      );\n    }\n  }\n  const elementType = {\n    $$typeof: REACT_MEMO_TYPE,\n    type,\n    compare: compare === undefined ? null : compare,\n  };\n  if (__DEV__) {\n    let ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name;\n\n        // The inner component shouldn't inherit this display name in most cases,\n        // because the component may be used elsewhere.\n        // But it's nice for anonymous functions to inherit the name,\n        // so that our component-stack generation logic will display their frames.\n        // An anonymous function generally suggests a pattern like:\n        //   React.memo((props) => {...});\n        // This kind of inner function is not used elsewhere so the side effect is okay.\n        if (!type.name && !type.displayName) {\n          Object.defineProperty(type, 'name', {\n            value: name,\n          });\n          type.displayName = name;\n        }\n      },\n    });\n  }\n  return elementType;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nconst UNTERMINATED = 0;\nconst TERMINATED = 1;\nconst ERRORED = 2;\n\ntype UnterminatedCacheNode<T> = {\n  s: 0,\n  v: void,\n  o: null | WeakMap<Function | Object, CacheNode<T>>,\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>,\n};\n\ntype TerminatedCacheNode<T> = {\n  s: 1,\n  v: T,\n  o: null | WeakMap<Function | Object, CacheNode<T>>,\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>,\n};\n\ntype ErroredCacheNode<T> = {\n  s: 2,\n  v: mixed,\n  o: null | WeakMap<Function | Object, CacheNode<T>>,\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>,\n};\n\ntype CacheNode<T> =\n  | TerminatedCacheNode<T>\n  | UnterminatedCacheNode<T>\n  | ErroredCacheNode<T>;\n\nfunction createCacheRoot<T>(): WeakMap<Function | Object, CacheNode<T>> {\n  return new WeakMap();\n}\n\nfunction createCacheNode<T>(): CacheNode<T> {\n  return {\n    s: UNTERMINATED, // status, represents whether the cached computation returned a value or threw an error\n    v: undefined, // value, either the cached result or an error, depending on s\n    o: null, // object cache, a WeakMap where non-primitive arguments are stored\n    p: null, // primitive cache, a regular Map where primitive arguments are stored.\n  };\n}\n\nexport function cache<A: Iterable<mixed>, T>(fn: (...A) => T): (...A) => T {\n  return function () {\n    const dispatcher = ReactSharedInternals.A;\n    if (!dispatcher) {\n      // If there is no dispatcher, then we treat this as not being cached.\n      // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.\n      return fn.apply(null, arguments);\n    }\n    const fnMap: WeakMap<any, CacheNode<T>> = dispatcher.getCacheForType(\n      createCacheRoot,\n    );\n    const fnNode = fnMap.get(fn);\n    let cacheNode: CacheNode<T>;\n    if (fnNode === undefined) {\n      cacheNode = createCacheNode();\n      fnMap.set(fn, cacheNode);\n    } else {\n      cacheNode = fnNode;\n    }\n    for (let i = 0, l = arguments.length; i < l; i++) {\n      const arg = arguments[i];\n      if (\n        typeof arg === 'function' ||\n        (typeof arg === 'object' && arg !== null)\n      ) {\n        // Objects go into a WeakMap\n        let objectCache = cacheNode.o;\n        if (objectCache === null) {\n          cacheNode.o = objectCache = new WeakMap();\n        }\n        const objectNode = objectCache.get(arg);\n        if (objectNode === undefined) {\n          cacheNode = createCacheNode();\n          objectCache.set(arg, cacheNode);\n        } else {\n          cacheNode = objectNode;\n        }\n      } else {\n        // Primitives go into a regular Map\n        let primitiveCache = cacheNode.p;\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = new Map();\n        }\n        const primitiveNode = primitiveCache.get(arg);\n        if (primitiveNode === undefined) {\n          cacheNode = createCacheNode();\n          primitiveCache.set(arg, cacheNode);\n        } else {\n          cacheNode = primitiveNode;\n        }\n      }\n    }\n    if (cacheNode.s === TERMINATED) {\n      return cacheNode.v;\n    }\n    if (cacheNode.s === ERRORED) {\n      throw cacheNode.v;\n    }\n    try {\n      // $FlowFixMe[incompatible-call]: We don't want to use rest arguments since we transpile the code.\n      const result = fn.apply(null, arguments);\n      const terminatedNode: TerminatedCacheNode<T> = (cacheNode: any);\n      terminatedNode.s = TERMINATED;\n      terminatedNode.v = result;\n      return result;\n    } catch (error) {\n      // We store the first error that's thrown and rethrow it.\n      const erroredNode: ErroredCacheNode<T> = (cacheNode: any);\n      erroredNode.s = ERRORED;\n      erroredNode.v = error;\n      throw error;\n    }\n  };\n}\n\nexport function cacheSignal(): null | AbortSignal {\n  const dispatcher = ReactSharedInternals.A;\n  if (!dispatcher) {\n    // If there is no dispatcher, then we treat this as not having an AbortSignal\n    // since in the same context, a cached function will be allowed to be called\n    // but it won't be cached. So it's neither an infinite AbortSignal nor an\n    // already resolved one.\n    return null;\n  }\n  return dispatcher.cacheSignal();\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst reportGlobalError: (error: mixed) => void =\n  typeof reportError === 'function'\n    ? // In modern browsers, reportError will dispatch an error event,\n      // emulating an uncaught JavaScript error.\n      reportError\n    : error => {\n        if (\n          typeof window === 'object' &&\n          typeof window.ErrorEvent === 'function'\n        ) {\n          // Browser Polyfill\n          const message =\n            typeof error === 'object' &&\n            error !== null &&\n            typeof error.message === 'string'\n              ? // eslint-disable-next-line react-internal/safe-string-coercion\n                String(error.message)\n              : // eslint-disable-next-line react-internal/safe-string-coercion\n                String(error);\n          const event = new window.ErrorEvent('error', {\n            bubbles: true,\n            cancelable: true,\n            message: message,\n            error: error,\n          });\n          const shouldLog = window.dispatchEvent(event);\n          if (!shouldLog) {\n            return;\n          }\n        } else if (\n          typeof process === 'object' &&\n          // $FlowFixMe[method-unbinding]\n          typeof process.emit === 'function'\n        ) {\n          // Node Polyfill\n          process.emit('uncaughtException', error);\n          return;\n        }\n        console['error'](error);\n      };\n\nexport default reportGlobalError;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport type {Fiber} from 'react-reconciler/src/ReactInternalTypes';\nimport type {\n  StartTransitionOptions,\n  GestureProvider,\n  GestureOptions,\n} from 'shared/ReactTypes';\nimport type {TransitionTypes} from './ReactTransitionType';\n\nimport ReactSharedInternals from 'shared/ReactSharedInternals';\n\nimport {\n  enableTransitionTracing,\n  enableViewTransition,\n  enableGestureTransition,\n} from 'shared/ReactFeatureFlags';\n\nimport reportGlobalError from 'shared/reportGlobalError';\n\nimport noop from 'shared/noop';\n\nexport type Transition = {\n  types: null | TransitionTypes, // enableViewTransition\n  gesture: null | GestureProvider, // enableGestureTransition\n  name: null | string, // enableTransitionTracing only\n  startTime: number, // enableTransitionTracing only\n  _updatedFibers: Set<Fiber>, // DEV-only\n  ...\n};\n\nfunction releaseAsyncTransition() {\n  if (__DEV__) {\n    ReactSharedInternals.asyncTransitions--;\n  }\n}\n\nexport function startTransition(\n  scope: () => void,\n  options?: StartTransitionOptions,\n): void {\n  const prevTransition = ReactSharedInternals.T;\n  const currentTransition: Transition = ({}: any);\n  if (enableViewTransition) {\n    currentTransition.types =\n      prevTransition !== null\n        ? // If we're a nested transition, we should use the same set as the parent\n          // since we're conceptually always joined into the same entangled transition.\n          // In practice, this only matters if we add transition types in the inner\n          // without setting state. In that case, the inner transition can finish\n          // without waiting for the outer.\n          prevTransition.types\n        : null;\n  }\n  if (enableGestureTransition) {\n    currentTransition.gesture = null;\n  }\n  if (enableTransitionTracing) {\n    currentTransition.name =\n      options !== undefined && options.name !== undefined ? options.name : null;\n    currentTransition.startTime = -1; // TODO: This should read the timestamp.\n  }\n  if (__DEV__) {\n    currentTransition._updatedFibers = new Set();\n  }\n  ReactSharedInternals.T = currentTransition;\n\n  try {\n    const returnValue = scope();\n    const onStartTransitionFinish = ReactSharedInternals.S;\n    if (onStartTransitionFinish !== null) {\n      onStartTransitionFinish(currentTransition, returnValue);\n    }\n    if (\n      typeof returnValue === 'object' &&\n      returnValue !== null &&\n      typeof returnValue.then === 'function'\n    ) {\n      if (__DEV__) {\n        // Keep track of the number of async transitions still running so we can warn.\n        ReactSharedInternals.asyncTransitions++;\n        returnValue.then(releaseAsyncTransition, releaseAsyncTransition);\n      }\n      returnValue.then(noop, reportGlobalError);\n    }\n  } catch (error) {\n    reportGlobalError(error);\n  } finally {\n    warnAboutTransitionSubscriptions(prevTransition, currentTransition);\n    if (prevTransition !== null && currentTransition.types !== null) {\n      // If we created a new types set in the inner transition, we transfer it to the parent\n      // since they should share the same set. They're conceptually entangled.\n      if (__DEV__) {\n        if (\n          prevTransition.types !== null &&\n          prevTransition.types !== currentTransition.types\n        ) {\n          // Just assert that assumption holds that we're not overriding anything.\n          console.error(\n            'We expected inner Transitions to have transferred the outer types set and ' +\n              'that you cannot add to the outer Transition while inside the inner.' +\n              'This is a bug in React.',\n          );\n        }\n      }\n      prevTransition.types = currentTransition.types;\n    }\n    ReactSharedInternals.T = prevTransition;\n  }\n}\n\nexport function startGestureTransition(\n  provider: GestureProvider,\n  scope: () => void,\n  options?: GestureOptions & StartTransitionOptions,\n): () => void {\n  if (!enableGestureTransition) {\n    // eslint-disable-next-line react-internal/prod-error-codes\n    throw new Error(\n      'startGestureTransition should not be exported when the enableGestureTransition flag is off.',\n    );\n  }\n  if (provider == null) {\n    // We enforce this at runtime even though the type also enforces it since we\n    // use null as a signal internally so it would lead it to be treated as a\n    // regular transition otherwise.\n    throw new Error(\n      'A Timeline is required as the first argument to startGestureTransition.',\n    );\n  }\n  const prevTransition = ReactSharedInternals.T;\n  const currentTransition: Transition = ({}: any);\n  if (enableViewTransition) {\n    currentTransition.types = null;\n  }\n  if (enableGestureTransition) {\n    currentTransition.gesture = provider;\n  }\n  if (enableTransitionTracing) {\n    currentTransition.name =\n      options !== undefined && options.name !== undefined ? options.name : null;\n    currentTransition.startTime = -1; // TODO: This should read the timestamp.\n  }\n  if (__DEV__) {\n    currentTransition._updatedFibers = new Set();\n  }\n  ReactSharedInternals.T = currentTransition;\n\n  try {\n    const returnValue = scope();\n    if (__DEV__) {\n      if (\n        typeof returnValue === 'object' &&\n        returnValue !== null &&\n        typeof returnValue.then === 'function'\n      ) {\n        console.error(\n          'Cannot use an async function in startGestureTransition. It must be able to start immediately.',\n        );\n      }\n    }\n    const onStartGestureTransitionFinish = ReactSharedInternals.G;\n    if (onStartGestureTransitionFinish !== null) {\n      return onStartGestureTransitionFinish(\n        currentTransition,\n        provider,\n        options,\n      );\n    }\n  } catch (error) {\n    reportGlobalError(error);\n  } finally {\n    ReactSharedInternals.T = prevTransition;\n  }\n  return noop;\n}\n\nfunction warnAboutTransitionSubscriptions(\n  prevTransition: Transition | null,\n  currentTransition: Transition,\n) {\n  if (__DEV__) {\n    if (prevTransition === null && currentTransition._updatedFibers) {\n      const updatedFibersCount = currentTransition._updatedFibers.size;\n      currentTransition._updatedFibers.clear();\n      if (updatedFibersCount > 10) {\n        console.warn(\n          'Detected a large number of updates inside startTransition. ' +\n            'If this is due to a subscription please re-write it to use React provided hooks. ' +\n            'Otherwise concurrent mode guarantees are off the table.',\n        );\n      }\n    }\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {REACT_POSTPONE_TYPE} from 'shared/ReactSymbols';\n\ndeclare class Postpone extends Error {\n  $$typeof: symbol;\n}\n\nexport type {Postpone};\n\nexport function postpone(reason: string): void {\n  // eslint-disable-next-line react-internal/prod-error-codes\n  const postponeInstance: Postpone = (new Error(reason): any);\n  postponeInstance.$$typeof = REACT_POSTPONE_TYPE;\n  throw postponeInstance;\n}\n","export default '19.2.0-canary-602917c8-20250701';\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nconst getPrototypeOf = Object.getPrototypeOf;\n\nexport default getPrototypeOf;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n// Turns a TypedArray or ArrayBuffer into a string that can be used for comparison\n// in a Map to see if the bytes are the same.\nexport default function binaryToComparableString(\n  view: $ArrayBufferView,\n): string {\n  return String.fromCharCode.apply(\n    String,\n    new Uint8Array(view.buffer, view.byteOffset, view.byteLength),\n  );\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nimport {enableTaint} from 'shared/ReactFeatureFlags';\n\nimport getPrototypeOf from 'shared/getPrototypeOf';\n\nimport binaryToComparableString from 'shared/binaryToComparableString';\n\nimport ReactSharedInternals from './ReactSharedInternalsServer';\nconst {\n  TaintRegistryObjects,\n  TaintRegistryValues,\n  TaintRegistryByteLengths,\n  TaintRegistryPendingRequests,\n} = ReactSharedInternals;\n\ninterface Reference {}\n\n// This is the shared constructor of all typed arrays.\nconst TypedArrayConstructor = getPrototypeOf(Uint32Array.prototype).constructor;\n\nconst defaultMessage =\n  'A tainted value was attempted to be serialized to a Client Component or Action closure. ' +\n  'This would leak it to the client.';\n\nfunction cleanup(entryValue: string | bigint): void {\n  const entry = TaintRegistryValues.get(entryValue);\n  if (entry !== undefined) {\n    TaintRegistryPendingRequests.forEach(function (requestQueue) {\n      requestQueue.push(entryValue);\n      entry.count++;\n    });\n    if (entry.count === 1) {\n      TaintRegistryValues.delete(entryValue);\n    } else {\n      entry.count--;\n    }\n  }\n}\n\n// If FinalizationRegistry doesn't exist, we assume that objects life forever.\n// E.g. the whole VM is just the lifetime of a request.\nconst finalizationRegistry =\n  typeof FinalizationRegistry === 'function'\n    ? new FinalizationRegistry(cleanup)\n    : null;\n\nexport function taintUniqueValue(\n  message: ?string,\n  lifetime: Reference,\n  value: string | bigint | $ArrayBufferView,\n): void {\n  if (!enableTaint) {\n    throw new Error('Not implemented.');\n  }\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  message = '' + (message || defaultMessage);\n  if (\n    lifetime === null ||\n    (typeof lifetime !== 'object' && typeof lifetime !== 'function')\n  ) {\n    throw new Error(\n      'To taint a value, a lifetime must be defined by passing an object that holds ' +\n        'the value.',\n    );\n  }\n  let entryValue: string | bigint;\n  if (typeof value === 'string' || typeof value === 'bigint') {\n    // Use as is.\n    entryValue = value;\n  } else if (\n    value instanceof TypedArrayConstructor ||\n    value instanceof DataView\n  ) {\n    // For now, we just convert binary data to a string so that we can just use the native\n    // hashing in the Map implementation. It doesn't really matter what form the string\n    // take as long as it's the same when we look it up.\n    // We're not too worried about collisions since this should be a high entropy value.\n    TaintRegistryByteLengths.add(value.byteLength);\n    entryValue = binaryToComparableString(value);\n  } else {\n    const kind = value === null ? 'null' : typeof value;\n    if (kind === 'object' || kind === 'function') {\n      throw new Error(\n        'taintUniqueValue cannot taint objects or functions. Try taintObjectReference instead.',\n      );\n    }\n    throw new Error(\n      'Cannot taint a ' +\n        kind +\n        ' because the value is too general and not unique enough to block globally.',\n    );\n  }\n  const existingEntry = TaintRegistryValues.get(entryValue);\n  if (existingEntry === undefined) {\n    TaintRegistryValues.set(entryValue, {\n      message,\n      count: 1,\n    });\n  } else {\n    existingEntry.count++;\n  }\n  if (finalizationRegistry !== null) {\n    finalizationRegistry.register(lifetime, entryValue);\n  }\n}\n\nexport function taintObjectReference(\n  message: ?string,\n  object: Reference,\n): void {\n  if (!enableTaint) {\n    throw new Error('Not implemented.');\n  }\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  message = '' + (message || defaultMessage);\n  if (typeof object === 'string' || typeof object === 'bigint') {\n    throw new Error(\n      'Only objects or functions can be passed to taintObjectReference. Try taintUniqueValue instead.',\n    );\n  }\n  if (\n    object === null ||\n    (typeof object !== 'object' && typeof object !== 'function')\n  ) {\n    throw new Error(\n      'Only objects or functions can be passed to taintObjectReference.',\n    );\n  }\n  TaintRegistryObjects.set(object, message);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport {default as __SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE} from './ReactSharedInternalsServer';\n\nimport {forEach, map, count, toArray, only} from './ReactChildren';\nimport {\n  REACT_FRAGMENT_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_SUSPENSE_LIST_TYPE,\n  REACT_VIEW_TRANSITION_TYPE,\n  REACT_ACTIVITY_TYPE,\n} from 'shared/ReactSymbols';\nimport {\n  cloneElement,\n  createElement,\n  isValidElement,\n} from './jsx/ReactJSXElement';\nimport {createRef} from './ReactCreateRef';\nimport {\n  use,\n  useId,\n  useCallback,\n  useDebugValue,\n  useMemo,\n  getCacheForType,\n} from './ReactHooks';\nimport {forwardRef} from './ReactForwardRef';\nimport {lazy} from './ReactLazy';\nimport {memo} from './ReactMemo';\nimport {cache, cacheSignal} from './ReactCacheServer';\nimport {startTransition} from './ReactStartTransition';\nimport {postpone} from './ReactPostpone';\nimport version from 'shared/ReactVersion';\n\nconst Children = {\n  map,\n  forEach,\n  count,\n  toArray,\n  only,\n};\n\n// These are server-only\nexport {\n  taintUniqueValue as experimental_taintUniqueValue,\n  taintObjectReference as experimental_taintObjectReference,\n} from './ReactTaint';\n\nexport {\n  Children,\n  REACT_FRAGMENT_TYPE as Fragment,\n  REACT_PROFILER_TYPE as Profiler,\n  REACT_STRICT_MODE_TYPE as StrictMode,\n  REACT_SUSPENSE_TYPE as Suspense,\n  cloneElement,\n  createElement,\n  createRef,\n  use,\n  forwardRef,\n  isValidElement,\n  lazy,\n  memo,\n  cache,\n  cacheSignal,\n  startTransition,\n  getCacheForType as unstable_getCacheForType,\n  postpone as unstable_postpone,\n  useId,\n  useCallback,\n  useDebugValue,\n  useMemo,\n  version,\n  // Experimental\n  REACT_SUSPENSE_LIST_TYPE as unstable_SuspenseList,\n  REACT_VIEW_TRANSITION_TYPE as unstable_ViewTransition,\n  REACT_ACTIVITY_TYPE as unstable_Activity,\n};\n"],"names":["TaintRegistryObjects","WeakMap","TaintRegistryValues","Map","TaintRegistryByteLengths","Set","TaintRegistryPendingRequests","ReactSharedInternals","H","A","formatProdErrorMessage","code","url","arguments","length","encodeURIComponent","i","isArrayImpl","Array","isArray","a","noop","REACT_ELEMENT_TYPE","Symbol","for","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_ACTIVITY_TYPE","REACT_POSTPONE_TYPE","REACT_VIEW_TRANSITION_TYPE","MAYBE_ITERATOR_SYMBOL","iterator","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","hasOwnProperty","Object","prototype","assign","getOwner","hasValidRef","config","ref","undefined","hasValidKey","key","ReactElement","type","self","source","owner","props","debugStack","debugTask","refProp","element","$$typeof","createElement","children","propName","call","childrenLength","childArray","defaultProps","cloneAndReplaceKey","oldElement","newKey","clonedElement","cloneElement","Error","_formatProdErrorMessage","isValidElement","object","SEPARATOR","SUBSEPARATOR","escape","escapeRegex","escaperLookup","escapedString","replace","match","userProvidedKeyEscapeRegex","escapeUserProvidedKey","text","getElementKey","index","toString","resolveThenable","thenable","status","fulfilledValue","value","rejectedError","reason","then","pendingThenable","fulfilledThenable","error","rejectedThenable","mapIntoArray","array","escapedPrefix","nameSoFar","callback","invokeCallback","payload","_payload","init","_init","child","mappedChild","childKey","escapedChildKey","c","newChild","push","nextName","subtreeCount","nextNamePrefix","iteratorFn","iterableChildren","step","ii","next","done","childrenString","String","keys","join","mapChildren","func","context","result","count","countChildren","n","forEachChildren","forEachFunc","forEachContext","apply","toArray","onlyChild","_formatProdErrorMessage2","createRef","refObject","current","resolveDispatcher","dispatcher","getCacheForType","resourceType","useCallback","deps","useMemo","create","useDebugValue","formatterFn","useId","use","usable","forwardRef","render","elementType","Uninitialized","Pending","Resolved","Rejected","lazyInitializer","_status","ctor","_result","moduleObject","resolved","rejected","pending","default","lazy","lazyType","memo","compare","UNTERMINATED","TERMINATED","ERRORED","createCacheRoot","createCacheNode","s","v","o","p","cache","fn","fnMap","fnNode","get","cacheNode","set","l","arg","objectCache","objectNode","primitiveCache","primitiveNode","terminatedNode","erroredNode","cacheSignal","reportGlobalError","reportError","window","ErrorEvent","message","event","bubbles","cancelable","shouldLog","dispatchEvent","process","emit","console","releaseAsyncTransition","startTransition","scope","options","prevTransition","T","currentTransition","types","gesture","returnValue","onStartTransitionFinish","S","__DEV__","postpone","postponeInstance","getPrototypeOf","binaryToComparableString","view","fromCharCode","Uint8Array","buffer","byteOffset","byteLength","TypedArrayConstructor","Uint32Array","constructor","defaultMessage","cleanup","entryValue","entry","forEach","requestQueue","delete","finalizationRegistry","FinalizationRegistry","taintUniqueValue","lifetime","DataView","add","kind","_formatProdErrorMessage3","_formatProdErrorMessage4","existingEntry","register","taintObjectReference","_formatProdErrorMessage6","_formatProdErrorMessage7","Children","map","only"],"mappings":"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"}
